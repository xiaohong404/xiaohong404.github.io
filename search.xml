<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bof</title>
    <url>/xiaohong404.github.io/2020/10/15/bof/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/4.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/1.png" class></strong></p>
<h3 id="查看给出的c语言源代码"><a href="#查看给出的c语言源代码" class="headerlink" title="查看给出的c语言源代码"></a>查看给出的c语言源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/2.png" class></strong></p>
<p>显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。</p>
<h3 id="IDA32打开文件"><a href="#IDA32打开文件" class="headerlink" title="IDA32打开文件"></a>IDA32打开文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/bof/3.png" class></strong></p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&#x27;pwnable.kr&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x2C</span> + <span class="string">&#x27;junk&#x27;</span> + <span class="string">&#x27;junk&#x27;</span> + p32(<span class="number">0xcafebabe</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>fd</title>
    <url>/xiaohong404.github.io/2020/10/15/fd/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/2.png" class></strong></p>
<h3 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/3.png" class></strong></p>
<h3 id="ls-la查看文件信息"><a href="#ls-la查看文件信息" class="headerlink" title="ls -la查看文件信息"></a>ls -la查看文件信息</h3><p><strong><a href="https://blog.csdn.net/u013197629/article/details/73608613">linux文件权限知识</a></strong></p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/4.png" class></strong></p>
<p>发现fd.c和其对应的可执行文件fd（用户有执行权限）</p>
<h3 id="cat-fd-c查看c语言代码"><a href="#cat-fd-c查看c语言代码" class="headerlink" title="cat fd.c查看c语言代码"></a>cat fd.c查看c语言代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/5.png" class></strong></p>
<p>有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/6.png" class></strong></p>
<h3 id="read-fd-buf-32"><a href="#read-fd-buf-32" class="headerlink" title="read(fd,buf,32)"></a>read(fd,buf,32)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read(fd, buf, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">fd == <span class="number">0</span>时：则表示标准输入；</span><br><span class="line">fd == <span class="number">1</span>时：则表示 标准输出；</span><br><span class="line">fd == <span class="number">2</span>时，则表示标准输出错误。</span><br><span class="line">buf 表示读入的缓冲区；</span><br><span class="line"><span class="number">32</span>表示读入<span class="number">32</span>字节；</span><br></pre></td></tr></table></figure>

<p>因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。</p>
<p>注意到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = atoi(argv[<span class="number">1</span>]) - <span class="number">0x1234</span></span><br></pre></td></tr></table></figure>

<p>要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$</p>
<h3 id="fd-4660"><a href="#fd-4660" class="headerlink" title="./fd 4660"></a>./fd 4660</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/fd/7.png" class></strong></p>
<p>注意这里参数需要转为10进制   $0x1234_{16} = 4660_{10}$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag: mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>collision</title>
    <url>/xiaohong404.github.io/2020/10/15/collision/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/2.png" class></strong></p>
<h3 id="查看C语言源代码"><a href="#查看C语言源代码" class="headerlink" title="查看C语言源代码"></a>查看C语言源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/3.png" class></strong></p>
<h3 id="main-int-argc-char-argv"><a href="#main-int-argc-char-argv" class="headerlink" title="main(int argc, char* argv[])"></a><a href="https://blog.csdn.net/LYJ_viviani/article/details/51873961">main(int argc, char* argv[])</a></h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/4.png" class></strong></p>
<p>传递三个参数$aa,bb,cc$, 程序运行结果如下:</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/5.png" class></strong></p>
<p><strong>注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递）</strong></p>
<h3 id="分析col-c"><a href="#分析col-c" class="headerlink" title="分析col.c"></a>分析col.c</h3><ul>
<li>函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。</li>
<li>argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。</li>
<li>check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。</li>
<li>如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。</li>
</ul>
<p>最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，<strong>注意不能设置为0x00</strong>，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。</p>
<p>另外，注意数据按照小端序存放：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/6.png" class></strong></p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/7.png" class></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./col $(python -c <span class="string">&quot;print &#x27;\x01\x01\x01\x01&#x27;*4 + &#x27;\xe8\x05\xd9\x1d&#x27;&quot;</span>)</span><br><span class="line"><span class="comment"># 这一inline的python表达式可以将生成的结果作为argv[1]参数</span></span><br></pre></td></tr></table></figure>

<h3 id="拿到flag"><a href="#拿到flag" class="headerlink" title="拿到flag"></a>拿到flag</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/collision/8.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>flag</title>
    <url>/xiaohong404.github.io/2020/10/15/flag/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/2.png" class></strong></p>
<h3 id="checksec查看文件属性"><a href="#checksec查看文件属性" class="headerlink" title="checksec查看文件属性"></a>checksec查看文件属性</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/3.png" class></strong></p>
<h3 id="windows下使用upx-d命令解压缩"><a href="#windows下使用upx-d命令解压缩" class="headerlink" title="windows下使用upx -d命令解压缩"></a>windows下使用upx -d命令解压缩</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/4.png" class></strong></p>
<h3 id="IDA64打开解压缩的文件"><a href="#IDA64打开解压缩的文件" class="headerlink" title="IDA64打开解压缩的文件"></a>IDA64打开解压缩的文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/5.png" class></strong></p>
<p>将flag的值存放到dest中，直接查看flag即可</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/flag/6.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>passcode</title>
    <url>/xiaohong404.github.io/2020/10/15/passcode/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/11.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/1.png" class></strong></p>
<h3 id="查看passcode-c源文件"><a href="#查看passcode-c源文件" class="headerlink" title="查看passcode.c源文件"></a>查看passcode.c源文件</h3><p><strong></strong></p>
<p>第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/3.png" class></strong></p>
<p>login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/4.png" class></strong></p>
<p>welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。</p>
<h3 id="gdb-passcode查看其汇编代码"><a href="#gdb-passcode查看其汇编代码" class="headerlink" title="gdb passcode查看其汇编代码"></a>gdb passcode查看其汇编代码</h3><h4 id="disassemble-r-welcome"><a href="#disassemble-r-welcome" class="headerlink" title="disassemble /r welcome"></a>disassemble /r welcome</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/5.png" class></strong></p>
<h4 id="disassemble-r-login"><a href="#disassemble-r-login" class="headerlink" title="disassemble /r login"></a>disassemble /r login</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/6.png" class></strong></p>
<p>发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。</p>
<h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><h4 id="查看文件保护措施"><a href="#查看文件保护措施" class="headerlink" title="查看文件保护措施"></a>查看文件保护措施</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/7.png" class></strong></p>
<p>栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在<strong>scanf(“%d”, passcode1);**后立即使用了</strong>fflush函数<strong>，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用</strong>system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。</p>
<p><strong>注意这里区分got表本身的地址和写入got表项中的地址</strong></p>
<h4 id="fflush函数的地址"><a href="#fflush函数的地址" class="headerlink" title="fflush函数的地址"></a>fflush函数的地址</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/8.png" class></strong></p>
<p>fflush地址为$0x0804a004$</p>
<h4 id="system函数的地址"><a href="#system函数的地址" class="headerlink" title="system函数的地址"></a>system函数的地址</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/9.png" class></strong></p>
<p>这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。</p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27; * 96 + &#x27;\x04\xa0\x04\x08&#x27; + &#x27;134514147\n&#x27;&quot;</span> | ./passcode</span><br></pre></td></tr></table></figure>

<p>因为passcode是输入int型，即输入$0x080485e3 = 134514147$。</p>
<h3 id="获得flag"><a href="#获得flag" class="headerlink" title="获得flag"></a>获得flag</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/passcode/10.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>random</title>
    <url>/xiaohong404.github.io/2020/10/15/random/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/2.png" class></strong></p>
<h3 id="查看random-c源代码"><a href="#查看random-c源代码" class="headerlink" title="查看random.c源代码"></a>查看random.c源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/random/3.png" class></strong></p>
<p>函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。</p>
<h3 id="rand（）函数"><a href="#rand（）函数" class="headerlink" title="rand（）函数"></a>rand（）函数</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/random/4.png" class></strong></p>
<p>由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。</p>
<h3 id="查看随机数"><a href="#查看随机数" class="headerlink" title="查看随机数"></a>查看随机数</h3><h4 id="disassemble-r-main-查看汇编代码"><a href="#disassemble-r-main-查看汇编代码" class="headerlink" title="$disassemble /r \ main$查看汇编代码"></a>$disassemble /r \ main$查看汇编代码</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/random/5.png" class></strong></p>
<h4 id="在cmp处下断点"><a href="#在cmp处下断点" class="headerlink" title="在cmp处下断点"></a>在cmp处下断点</h4><p>汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \ $rbp-4$查看内存的值即可。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/6.png" class></strong></p>
<p>所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。</p>
<h3 id="获得flag"><a href="#获得flag" class="headerlink" title="获得flag"></a>获得flag</h3><p>求出$0x6b8b4567\oplus 0xdeadbeef$的值输入即可</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/random/7.png" class></strong></p>
]]></content>
      <tags>
        <tag>Pwnable.kr</tag>
      </tags>
  </entry>
</search>
