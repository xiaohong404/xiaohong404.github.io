{"meta":{"title":"Mr.red","subtitle":"","description":"Things always start to get better after you give up","author":"Xiao Hong","url":"https://github.com/xiaohong404/xiaohong404.github.io","root":"/xiaohong404.github.io/"},"pages":[{"title":"tags","date":"2020-10-15T04:55:36.000Z","updated":"2020-10-16T11:11:48.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/index.html","excerpt":"","text":"Learnig Pwnable.kr"},{"title":"Categories","date":"2020-10-15T08:23:06.000Z","updated":"2020-10-15T08:41:40.000Z","comments":true,"path":"Categories/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-15T04:55:40.000Z","updated":"2020-10-15T10:16:30.000Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/about/index.html","excerpt":"","text":"小红童鞋，请多指教！"}],"posts":[{"title":"Heap I","slug":"Heap-I","date":"2020-10-16T14:10:00.000Z","updated":"2020-10-17T07:43:08.000Z","comments":true,"path":"2020/10/16/Heap-I/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/Heap-I/","excerpt":"","text":"原版传送门 WHAT IS THE HEAP, AND WHY DO PEOPLE USE IT?堆是C/C++程序员在程序执行期间手动分配的新的区域。程序员通过调用堆相关的函数如malloc向堆管理器请求这部分区域。这些被分配的内存区域，或者称为“allocations”，之后可以被程序员一直使用、修改或者引用，直到他们不再需要这部分区域，会调用free函数将这部分区域返还给堆管理器。 下面是一个C语言程序分配、使用并且释放堆上的结构体的例子： 123456789101112131415161718typedef struct &#123; int field1; char* field2;&#125; SomeStruct;int main()&#123; SomeStruct* myObject = (SomeStruct*)malloc(sizeof(SomeStruct)); if(myObject != NULL) &#123; myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); free(myObject); &#125; return 0;&#125; 所以只要程序员遵循下面几个小的规则，堆管理器将确保每个已分配的堆不会相互重叠。这个特点使得堆非常有用并且高效，这和大多数C/C++程序追求性能的要求相符合。 接下来的图表列出了一些程序员在使用堆时的基本规则，以及在程序员违反这些规则时发生的一些漏洞类别。之后，我将更详细地讨论所有这些与堆相关的漏洞类别，目前只讨论堆使用正确时的表现。 HEAP RULES 当然，malloc和free并不是C和C++程序员与堆进行交互的唯一方式。相反，C++开发人员通常通过C++运算符new和new []分配内存。必须使用相应的C++运算符delete和delete []而不是free释放这些分配。程序员还可以通过与malloc兼容的堆函数（例如calloc，realloc和memalign）来分配内存，这些函数最终也通过free释放，就像malloc一样。 为简单起见，将首先讨论malloc和free，下面是一个C++程序如何分配，使用和释放堆上的结构体的例子： 12345678910111213141516class SomeClass&#123;public: int field1; char* field2;&#125;;int main()&#123; SomeClass* myObject = new SomeClass(); myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); delete myObject; return 0;&#125; MEMORY CHUNKS AND THE CHUNK ALLOCATION STRATEGIES假设一个程序员通过malloc需求10字节内存，为了满足这个请求，堆管理器不仅仅只随机寻找一个10字节的程序员可以写的区域，而是需要做更多的事情。堆管理器也需要存储此次分配的元数据。这个元数据被存储在紧邻分配的10字节区域处。 堆管理器还需要确保分配空间在32位系统上是8字节对齐的，在64位系统上是16字节对齐的。如果程序员只想存储文本字符串或字节数组之类的数据，那么分配空间的对齐方式无关紧要。但是如果程序员打算使用分配空间来存储更多复杂的数据结构，则对齐方式会对程序的正确性和性能会产生重大影响。由于malloc无法知道程序员将在分配空间中存储什么内容，因此堆管理器必须默认确保所有分配空间均对齐。 此分配元数据和对齐填充字节与malloc的内存区域将一起被存储并返回给程序员。因此，堆管理器在内部分配的“块”内存比程序员最初要求的稍大。当程序员要求10个字节的内存时，堆管理器会找到或创建一个新的内存块，该块足以存储10个字节的空间、元数据以及对齐填充字节。然后，堆管理器将此块标记为“已分配”，并返回指向块内对齐的10字节“用户数据”区域的指针，程序员将收到malloc调用的返回值。 CHUNK ALLOCATION: BASIC STRATEGY那么堆管理器如何在内部分配这些块呢？ 首先，让我们看一下堆管理器的大部分工作，分配小块内存的（大大简化的）策略。我将在详细地解释每个步骤，之后我们就可以研究分配大块内存的特殊情况。 简化的小块分配策略如下： 如果有一个先前释放的内存块，并且该块足够大，可以满足用户的请求，则堆管理器将使用这个释放的块进行新的分配。 否则，如果堆顶部有可用空间，则堆管理器将从这个空闲的空间中分配一个新的块并使用它。 否则，堆管理器将要求内核向堆的末尾添加新的内存，并且从新分配的空间中分配一个新块给用户。 如果前面所有策略均失败，则无法为提供分配服务，并且malloc返回NULL。 ALLOCATING FROM FREE’D CHUNKS 从概念上讲，分配之前释放的块非常简单。因为当一个块在内存中被释放，堆管理器会在一系列称为“bins”的不同链表中记录这些释放的块。用户发出一个分配请求后，堆管理器会在这些“bins”中搜索一个足够大的空闲块，为用户提供服务。如果可以成功找到一个，则将这个空闲块从特定的bin中删除，并标记为“已分配”，然后这个指向该“user data”区域块的指针，会作为malloc的返回值返回给程序员。 出于性能原因，有几种不同类型的bins，即fast bins 、unsorted bins 、small bins、large bins 、per-thread tcache。下个部分将详细讨论这些不同种类的bins。 ALLOCATING FROM THE TOP OF THE HEAP 如果没有可用的空闲块可以满足分配请求，则堆管理器必须从头开始构造一个新块。为此，堆管理器首先查看堆顶部是否有足够的可用空间（有时称为“top chunk”或“remainder chunk”）。如果存在，堆管理器将在此可用空间基础上构造一个新块。 ASKING THE KERNEL FOR MORE MEMORY AT THE TOP OF THE HEAP 一旦堆顶部的可用空间用完，堆管理器将不得不要求内核在堆的末尾增加更多内存。 在建立堆的开始阶段上，堆管理器通过调用sbrk，要求内核在堆末尾分配更多的内存。在大多数基于Linux的系统上，在内部使用称为“ brk ”的系统调用。这个系统调用的名称很容易混淆，它最初的意思是“更改程序中断位置”，通俗来说，它表示在程序加载到内存之后，该区域会增加更多的内存。因为这是堆管理器从一开始创建堆的地方，所以此系统调用的作用是在程序堆的末尾分配更多的内存。 最终，如果一直使用sbrk扩展堆会导致分配失败，因为堆空间增长得太大之后，进一步扩展将导致其与进程地址空间中的其他内容发生冲突，例如内存映射，共享库或线程的堆栈区域。因此sbrk无法分配时，堆管理器将使用mmap调用将新的非连续内存附加到初始程序堆。 如果mmap也失败，则该进程根本无法分配更多的内存，并且malloc将返回NULL。 OFF-HEAP ALLOCATIONS VIA MMAP很大的分配请求（超过某个阈值*）在堆管理器中会得到特殊处理。通过直接调用mmap可以在堆外分配这些大块，并使用块中元数据的标记位来标记这一事实。当这些巨大块通过调用free释放到堆管理器时，堆管理器将通过munmap将整个mmap 过的区域返还给系统。 *默认情况下，此阈值 在32位系统上为128KB~512KB，在64位系统上为32MB，但是，如果堆管理器检测到这些分配的大块内存只需要被临时使用，则此阈值也会动态增加。 ARENAS在多线程应用程序上，堆管理器需要保护内部堆数据结构免受可能导致程序崩溃的竞争条件的影响。在ptmalloc2之前，堆管理器通过在每次堆操作之前简单地使用全局互斥锁，以确保在任何给定时间只有一个线程可以与堆进行交互。 尽管此策略有效，但堆分配器对高利用率和性能非常敏感，以至于导致使用大量线程的应用程序出现严重的性能问题。为了解决这个问题，ptmalloc2堆分配器引入了“arenas”的概念。每个“arenas”本质上是一个完全不同的堆，它完全独立地管理自己的块分配和free bins。每个“arenas”仍然使用互斥锁来序列化不同线程对内部数据结构的访问，但是只要线程与不同的“arenas”进行交互，线程就可以安全地执行堆操作而不会彼此停顿。 程序的初始（“main”）“arenas”仅包含我们已经看到的堆，对于单线程应用程序，这是堆管理器将使用的唯一arena。但是，随着新线程加入该进程，堆管理器会为每个新线程分配并附加“arenas”，以减少malloc和free等操作的等待时间。 对于每个加入该进程的新线程，堆管理器将先查找没有被其他线程在使用的“arenas”，并将该“arenas”附加到该线程。一旦所有可用的“arenas”都是在其它线程使用中，堆管理器将创建一个新的“arenas”，直到“arenas”的数目达到最大（32位进程为CPU核心数的2倍、64位进程位CPU核心的8倍）。一旦最终达到该限制，堆管理器就会放弃分配，这样多个线程将必须共享一个“arenas”，即执行堆操作将需要那些线程中的一个等待另一个线程。 但是这些二级“arenas”如何工作？我们看到，主堆在程序加载到内存的紧邻其后的位置，并使用brk系统调用对其进行扩展开始工作，但二级“arenas”并不相同，这些二级“arenas”使用mmap和mprotect创建的一个或多个“子堆”来模拟主堆的行为。 SUBHEAPS 子堆的工作方式与初始程序堆基本相同，主要存在两个区别。初始堆位于程序加载到内存之后的紧邻其后的位置，并且由sbrk动态扩展。相比之下，每个子堆使用mmap定位到内存中，堆管理器使用mprotect手动模拟增长子堆。 当堆管理器想要创建子堆时，它首先通过调用mmap要求内核保留该子堆可能增长到的内存区域。保留该区域不会将内存直接分配到子堆中；它只是要求内核不要在该区域内分配诸如线程堆栈，mmap区域或者其它的分配任务。*默认情况下，子堆大小最大（即保留该子堆使用的内存区域）在32位上为1MB，在64位系统上为64MB。 这是通过mmap询问标记为PROT_NONE的页面来完成的，这表明内核仅需要为该区域保留地址范围，不需要内核将内存直接分配给它。 在使用sbrk增长初始堆的地方，堆管理器通过手动调用mprotect将区域中的页面从PROT_NONE更改为PROT_READ | PROT_WRITE来将子堆“增长”到此保留的地址范围。这导致内核将物理内存附加到那些地址，实际上也会导致子堆缓慢增长，直到整个mmap区域已满。一旦整个子堆都用完，arenas便会分配另一个子堆。这将允许二级”arenas”几乎无限期地保持增长，直到内核耗尽内存或进程耗尽地址空间时才会失败。 Recap：初始（“main”）arena仅包含主堆，该主堆位于将程序二进制文件加载到内存之后的位置，并使用sbrk进行扩展。这是用于单线程应用程序的唯一arena。在多线程应用程序上，为新线程分配了二级arena，从中可以分配这些二级arena。使用arenas可以降低线程在执行堆操作之前需要等待互斥锁的可能性，从而提高了程序的速度。与main arena不同，这些二级arena从一个或多个子堆中分配块，这些子堆在内存中的位置首先使用mmap进行确定，并通过使用mprotect进行扩展。 CHUNK METADATA现在，了解了分配块的所有不同方式，这些块不仅包含提供给程序员的“用户数据”区域（作为malloc的返回值），同时包含元数据。下面介绍元数据实际记录的值以及存放的位置。 块的元数据在内存中的确切布局可能会很混乱，因为堆管理器源代码将一个块末尾的元数据与下一个块末尾的元数据组合在一起，并且几个存在并被使用的元数据字段取决于不同种类的chunk。 现在，我们仅看一下实时分配，它具有单个size_t * 标头，该标头位于给程序员的“用户数据”区域的后面。此字段（在源代码中称为mchunk_size）是在malloc期间写入的，之后由free决定如何处理该分配空间的释放。 * size_t值在32位系统上为4字节整数，在64位系统上为8字节整数。 该mchunk_size存储了四种信息：块的大小，以及被称为“A”,“M”和“P”三比特位。这些都被存储在相同的size_t字段中，因为块大小始终是8字节对齐的（在64位上是16字节对齐），因此，块大小的低三位始终为零。 “ A ”标志是用来告诉堆管理器，是否该块属于二级arena，而不是在main arena。在free期间，堆管理器仅仅给了一个指向程序员想要释放空间的指针，并且堆管理器需要确定该指针属于哪一个arena。如果在块的元数据中A标志被设置，则堆管理器必须搜索每个arena，并查看指针是否位于该arena的任何子堆中。如果未设置该标志，则堆管理器可以减少搜索，因为它知道该块来自初始的arena。 “ M ”标志用于指示该块是一个通过mmap进行堆外分配的巨大分配。当此分配空间最终返回给free时，堆管理器将通过munmap立即将整个块返回给操作系统，而不是尝试对其进行回收。因此，空闲即已经被释放的块永远不会设置该标志位。 “ P ”标志令人困惑，因为它实际上属于先前的块。它指示先前的块是一个空闲块。这意味着当这个块被释放时，可以将其安全地连接到先前的块上，以创建更大的空闲块。 下面是一些和堆相关的文章： Once upon a free() Malloc des-maleficarum The house of lore Advanced Doug Lea’s malloc exploits Yet another free() exploitation technique","categories":[],"tags":[{"name":"Heap_Learning","slug":"Heap-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Heap-Learning/"}]},{"title":"uaf","slug":"uaf","date":"2020-10-16T02:26:47.000Z","updated":"2020-10-16T07:43:32.000Z","comments":true,"path":"2020/10/16/uaf/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/uaf/","excerpt":"","text":"查看uaf.cpp文件源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system(&quot;/bin/sh&quot;); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; 程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为： use：Man和Woman分别调用introduce()方法，即使用指针指向的函数 after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate free：delete释放掉创建的对象的空间，即将指针指向的内存释放 三者的组合即可构成UAF漏洞 背景知识前置知识1：虚函数的内存地址空间在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 1234567891011121314151617181920212223242526272829303132class Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int base; protected: private: &#125;; //子类1，无虚函数重载 class Child1 : public Base &#123; public: virtual void f1() &#123; cout &lt;&lt; &quot;Child1::f1&quot; &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; &quot;Child1::g1&quot; &lt;&lt; endl; &#125; virtual void h1() &#123; cout &lt;&lt; &quot;Child1::h1&quot; &lt;&lt; endl; &#125; int child1; protected: private: &#125;; //子类2，有1个虚函数重载 class Child2 : public Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Child2::f&quot; &lt;&lt; endl; &#125; virtual void g2() &#123; cout &lt;&lt; &quot;Child2::g2&quot; &lt;&lt; endl; &#125; virtual void h2() &#123; cout &lt;&lt; &quot;Child2::h2&quot; &lt;&lt; endl; &#125; int child2; protected: private: &#125;; 单一继承，无虚函数重载 单一继承，重载了虚函数 多重继承 总结 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr Use-After-FreeDangling pointer Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。 UAF原理对Dangling pointer所指向内存进行use，如指针解引用等。 利用思路将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串） 举个栗子123456typedef struct&#123; int id; char *name; int (*func)() //函数指针，可以理解为类里面的方法&#125;; 假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为此时p指针指向的内存包含的内容已经改变。 数据控制 任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$ 任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$ 控制流劫持：$p-&gt;func()———————&gt;call\\ addr3$ 解题思路查看文件保护措施 思路分析可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。 基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。 寻找vtable的地址 直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。 10x401570 - 8 = 0x401568 -&gt; \\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00 确定每个对象分配的空间大小 可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。） 整理如下 输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman） 输入2（allocate）：先将woman释放的空间重新拿回 输入2（allocate）：再将man释放的空间重新拿回 输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag 拿到flag1python -c &quot;print &#x27;\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00&#x27;&quot; &gt; /tmp/exp.txt","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"random","slug":"random","date":"2020-10-15T11:10:35.000Z","updated":"2020-10-15T11:18:36.000Z","comments":true,"path":"2020/10/15/random/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/random/","excerpt":"","text":"查看random.c源代码 函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。 rand（）函数 由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。 查看随机数$disassemble /r \\ main$查看汇编代码 在cmp处下断点汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \\ $rbp-4$查看内存的值即可。 所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。 获得flag求出$0x6b8b4567\\oplus 0xdeadbeef$的值输入即可","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"collision","slug":"collision","date":"2020-10-15T11:10:23.000Z","updated":"2020-10-15T11:15:32.000Z","comments":true,"path":"2020/10/15/collision/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/collision/","excerpt":"","text":"查看C语言源代码 main(int argc, char* argv[]) 传递三个参数$aa,bb,cc$, 程序运行结果如下: 注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递） 分析col.c 函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。 argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。 check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。 如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。 最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，注意不能设置为0x00，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。 另外，注意数据按照小端序存放： 编写python脚本 12./col $(python -c &quot;print &#x27;\\x01\\x01\\x01\\x01&#x27;*4 + &#x27;\\xe8\\x05\\xd9\\x1d&#x27;&quot;)# 这一inline的python表达式可以将生成的结果作为argv[1]参数 拿到flag","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"flag","slug":"flag","date":"2020-10-15T11:10:06.000Z","updated":"2020-10-15T11:16:14.000Z","comments":true,"path":"2020/10/15/flag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/flag/","excerpt":"","text":"checksec查看文件属性 windows下使用upx -d命令解压缩 IDA64打开解压缩的文件 将flag的值存放到dest中，直接查看flag即可","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"fd","slug":"fd","date":"2020-10-15T10:59:24.000Z","updated":"2020-10-15T11:03:54.000Z","comments":true,"path":"2020/10/15/fd/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/fd/","excerpt":"","text":"登录远程服务器 ls -la查看文件信息linux文件权限知识 发现fd.c和其对应的可执行文件fd（用户有执行权限） cat fd.c查看c语言代码 有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN read(fd,buf,32)1234567read(fd, buf, 32)fd == 0时：则表示标准输入；fd == 1时：则表示 标准输出；fd == 2时，则表示标准输出错误。buf 表示读入的缓冲区；32表示读入32字节； 因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。 注意到 1fd = atoi(argv[1]) - 0x1234 要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$ ./fd 4660 注意这里参数需要转为10进制 $0x1234_{16} = 4660_{10}$ 1flag: mommy! I think I know what a file descriptor is!!","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"passcode","slug":"passcode","date":"2020-10-15T07:08:39.000Z","updated":"2020-10-15T11:08:46.000Z","comments":true,"path":"2020/10/15/passcode/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/passcode/","excerpt":"","text":"查看passcode.c源文件 第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。 login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。 welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。 gdb passcode查看其汇编代码disassemble /r welcome disassemble /r login 发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。 转换思路查看文件保护措施 栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在scanf(“%d”, passcode1);**后立即使用了fflush函数，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。 注意这里区分got表本身的地址和写入got表项中的地址 fflush函数的地址 fflush地址为$0x0804a004$ system函数的地址 这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。 编写python脚本1python -c &quot;print &#x27;A&#x27; * 96 + &#x27;\\x04\\xa0\\x04\\x08&#x27; + &#x27;134514147\\n&#x27;&quot; | ./passcode 因为passcode是输入int型，即输入$0x080485e3 = 134514147$。 获得flag","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"bof","slug":"bof","date":"2020-10-15T06:33:21.000Z","updated":"2020-10-16T02:27:24.000Z","comments":true,"path":"2020/10/15/bof/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/bof/","excerpt":"","text":"查看给出的c语言源代码 显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。 IDA32打开文件 编写python脚本123456from pwn import *io = remote(&#x27;pwnable.kr&#x27;,9000)payload = &#x27;a&#x27;*0x2C + &#x27;junk&#x27; + &#x27;junk&#x27; + p32(0xcafebabe)io.interactive()","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]}],"categories":[],"tags":[{"name":"Heap_Learning","slug":"Heap-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Heap-Learning/"},{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]}