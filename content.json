{"meta":{"title":"Mr.red","subtitle":"","description":"Things always start to get better after you give up","author":"Xiao Hong","url":"https://github.com/xiaohong404/xiaohong404.github.io","root":"/xiaohong404.github.io/"},"pages":[{"title":"about","date":"2020-10-15T04:55:40.000Z","updated":"2020-10-15T10:16:30.000Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/about/index.html","excerpt":"","text":"小红童鞋，请多指教！"},{"title":"Categories","date":"2020-10-15T08:23:06.000Z","updated":"2020-10-15T08:41:40.000Z","comments":true,"path":"Categories/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-15T04:55:36.000Z","updated":"2020-10-15T10:17:12.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/index.html","excerpt":"","text":"Pwnable.kr"}],"posts":[{"title":"random","slug":"random","date":"2020-10-15T11:10:35.000Z","updated":"2020-10-15T11:18:36.000Z","comments":true,"path":"2020/10/15/random/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/random/","excerpt":"","text":"查看random.c源代码 函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。 rand（）函数 由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。 查看随机数$disassemble /r \\ main$查看汇编代码 在cmp处下断点汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \\ $rbp-4$查看内存的值即可。 所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。 获得flag求出$0x6b8b4567\\oplus 0xdeadbeef$的值输入即可","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"collision","slug":"collision","date":"2020-10-15T11:10:23.000Z","updated":"2020-10-15T11:15:32.000Z","comments":true,"path":"2020/10/15/collision/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/collision/","excerpt":"","text":"查看C语言源代码 main(int argc, char* argv[]) 传递三个参数$aa,bb,cc$, 程序运行结果如下: 注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递） 分析col.c 函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。 argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。 check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。 如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。 最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，注意不能设置为0x00，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。 另外，注意数据按照小端序存放： 编写python脚本 12./col $(python -c &quot;print &#x27;\\x01\\x01\\x01\\x01&#x27;*4 + &#x27;\\xe8\\x05\\xd9\\x1d&#x27;&quot;)# 这一inline的python表达式可以将生成的结果作为argv[1]参数 拿到flag","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"flag","slug":"flag","date":"2020-10-15T11:10:06.000Z","updated":"2020-10-15T11:16:14.000Z","comments":true,"path":"2020/10/15/flag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/flag/","excerpt":"","text":"checksec查看文件属性 windows下使用upx -d命令解压缩 IDA64打开解压缩的文件 将flag的值存放到dest中，直接查看flag即可","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"fd","slug":"fd","date":"2020-10-15T10:59:24.000Z","updated":"2020-10-15T11:03:54.000Z","comments":true,"path":"2020/10/15/fd/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/fd/","excerpt":"","text":"登录远程服务器 ls -la查看文件信息linux文件权限知识 发现fd.c和其对应的可执行文件fd（用户有执行权限） cat fd.c查看c语言代码 有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN read(fd,buf,32)1234567read(fd, buf, 32)fd == 0时：则表示标准输入；fd == 1时：则表示 标准输出；fd == 2时，则表示标准输出错误。buf 表示读入的缓冲区；32表示读入32字节； 因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。 注意到 1fd = atoi(argv[1]) - 0x1234 要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$ ./fd 4660 注意这里参数需要转为10进制 $0x1234_{16} = 4660_{10}$ 1flag: mommy! I think I know what a file descriptor is!!","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"passcode","slug":"passcode","date":"2020-10-15T07:08:39.000Z","updated":"2020-10-15T11:08:46.000Z","comments":true,"path":"2020/10/15/passcode/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/passcode/","excerpt":"","text":"查看passcode.c源文件 第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。 login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。 welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。 gdb passcode查看其汇编代码disassemble /r welcome disassemble /r login 发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。 转换思路查看文件保护措施 栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在scanf(“%d”, passcode1);**后立即使用了fflush函数，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。 注意这里区分got表本身的地址和写入got表项中的地址 fflush函数的地址 fflush地址为$0x0804a004$ system函数的地址 这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。 编写python脚本1python -c &quot;print &#x27;A&#x27; * 96 + &#x27;\\x04\\xa0\\x04\\x08&#x27; + &#x27;134514147\\n&#x27;&quot; | ./passcode 因为passcode是输入int型，即输入$0x080485e3 = 134514147$。 获得flag","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]},{"title":"bof","slug":"bof","date":"2020-10-15T06:33:21.000Z","updated":"2020-10-15T11:06:50.000Z","comments":true,"path":"2020/10/15/bof/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/bof/","excerpt":"","text":"查看给出的c语言源代码 显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。 IDA32打开文件 编写python脚本123456from pwn import *io = remote(&#x27;pwnable.kr&#x27;,9000)payload = &#x27;a&#x27;*0x2C + &#x27;junk&#x27; + &#x27;junk&#x27; + p32(0xcafebabe)io.interactive()","categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]}],"categories":[],"tags":[{"name":"Pwnable.kr","slug":"Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Pwnable-kr/"}]}