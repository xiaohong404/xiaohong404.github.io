{"meta":{"title":"Mr.red","subtitle":"","description":"Things always start to get better after you give up","author":"Xiao Hong","url":"https://github.com/xiaohong404/xiaohong404.github.io","root":"/xiaohong404.github.io/"},"pages":[{"title":"about","date":"2020-10-15T04:55:40.000Z","updated":"2020-10-15T10:16:30.000Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/about/index.html","excerpt":"","text":"小红童鞋，请多指教！"},{"title":"tags","date":"2020-10-15T04:55:36.000Z","updated":"2020-10-19T03:50:04.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-19T03:31:01.000Z","updated":"2020-10-19T03:50:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"blukat","slug":"Pwnable_kr/blukat","date":"2020-10-22T14:01:47.000Z","updated":"2020-10-22T14:35:12.000Z","comments":true,"path":"2020/10/22/Pwnable_kr/blukat/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/22/Pwnable_kr/blukat/","excerpt":"","text":"查看blukat.c源文件123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;char flag[100];char password[100];char* key = &quot;3\\rG[S/%\\x1c\\x1d#0?\\rIS\\x0f\\x1c\\x1d\\x18;,4\\x1b\\x00\\x1bp;5\\x0b\\x1b\\x08\\x45+&quot;;void calc_flag(char* s)&#123; int i; for(i=0; i&lt;strlen(s); i++)&#123; flag[i] = s[i] ^ key[i]; &#125; printf(&quot;%s\\n&quot;, flag);&#125;int main()&#123; FILE* fp = fopen(&quot;/home/blukat/password&quot;, &quot;r&quot;); fgets(password, 100, fp); char buf[100]; printf(&quot;guess the password!\\n&quot;); fgets(buf, 128, stdin); if(!strcmp(password, buf))&#123; printf(&quot;congrats! here is your flag: &quot;); calc_flag(password); &#125; else&#123; printf(&quot;wrong guess!\\n&quot;); exit(0); &#125; return 0;&#125; 程序先读取password文件中的内容到password数组中，之后使用buf缓冲区读取用户输入的字符，buf缓冲区的大小为100，而读取的字符为128，之后比较用户输入的字符和password数组中的内容，如果相等，则可以执行cacl_flag函数，经过和密钥的异或运算计算出flag。如果采用缓冲区溢出覆盖fgets的返回地址为函数calc_flag的地址，由于不知道password的内容，无法正确计算出flag，因此这里缓冲区溢出攻击行不通。 PWN想到本题题干中的描述，本题应该是具有一种巧妙的解法。 这里看到password文件的用户组含有blukat_pwn，而当前用户在blukat_pwn组，因此是具有读权限的，那运行cat命令： 提示没有访问权限？不，这里的文件内容就是这句话，那直接将这句话输入到可执行文件中即可拿到flag。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"阅读深度学习的对抗攻击方法综述及实例","slug":"AI安全/阅读深度学习的对抗攻击方法综述及实例","date":"2020-10-22T07:24:07.000Z","updated":"2020-10-22T08:02:12.000Z","comments":true,"path":"2020/10/22/AI安全/阅读深度学习的对抗攻击方法综述及实例/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/22/AI%E5%AE%89%E5%85%A8/%E9%98%85%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0%E5%8F%8A%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"对抗样本攻击大体原理如下： 在这里，从熊猫的图像开始，攻击者在原始图像上添加小的扰动，这导致模型将此图像标记为长臂猿，且具有很高的可信度。 又或者，原始图像（左图），对抗噪声（中图），扰动后的图片即对抗样本（右图）被错误地分类为数字 2。 下面展示简单的利用FGSM原理实现的示例。 FGSM的工作原理是利用神经网络的梯度来创建一个Adversarial example。对于输入图像，该方法使用相对于输入图像的损失的梯度来创建使损失函数最大化的新图像。这个新图像被称为对抗图像。 在这里，梯度是相对于输入的图像的。这样做是因为其目标是创造一个最大化损失的图像。实现这一点的方法是找出图像中每个像素对损失值的贡献程度，并相应地添加一个扰动（使用链式规则去计算梯度可以很容易地找到每个输入像素的贡献程度）。此外，由于模型不再被训练（因此梯度不针对可训练变量，即模型参数），因此模型参数保持不变。唯一的目的就是使一个已经受过训练的模型发生错误的分类。在这篇文章中，模型是MobileNetV2模型，在ImageNet上进行了预训练。 导入所需要的库123import tensorflow as tfimport matplotlib as mplimport matplotlib.pyplot as plt 设置图片相关信息1234# 图片像素mpl.rcParams[&#x27;figure.figsize&#x27;] = (8, 8)# 图片网格mpl.rcParams[&#x27;axes.grid&#x27;] = False 载入MobileNetV2模型12pretrained_model = tf.keras.applications.MobileNetV2(include_top=True, weights=&#x27;imagenet&#x27;)pretrained_model.trainable = False 图像预处理1234567891011121314def preprocess(image): image = tf.cast(image, tf.float32) image = image/255 image = tf.image.resize(image, (224, 224)) image = image[None, ...] return image# 获取图片信息image_path = tf.keras.utils.get_file(&#x27;YellowLabradorLooking_new.jpg&#x27;,&#x27;https://storage.googleapis.com/download.tensorflow.org/example_images/YellowLabradorLooking_new.jpg&#x27;)image_raw = tf.io.read_file(image_path)image = tf.image.decode_image(image_raw)image = preprocess(image) 将图像输入模型并得到概率最高的分类结果12345# Helper function to extract labels from probability vectordef get_imagenet_label(probs): return tf.keras.applications.mobilenet_v2.decode_predictions(probs, top=1)[0][0]image_probs = pretrained_model.predict(image) 展示图像12345plt.figure()plt.imshow(image[0])_, image_class, class_confidence = get_imagenet_label(image_probs)plt.title(&#x27;&#123;&#125; : &#123;:.2f&#125;% Confidence&#x27;.format(image_class, class_confidence*100))plt.show() 可以准确地预测出图像为拉布拉多犬（可能性最高为37.16%） 计算梯度12345678910111213loss_object = tf.keras.losses.CategoricalCrossentropy()def create_adversarial_pattern(input_image, input_label): with tf.GradientTape() as tape: tape.watch(input_image) prediction = pretrained_model(input_image) loss = loss_object(input_label, prediction) # Get the gradients of the loss w.r.t to the input image. gradient = tape.gradient(loss, input_image) # Get the sign of the gradients to create the perturbation signed_grad = tf.sign(gradient) return signed_grad 打印添加的噪音图像1234567# Get the input label of the image.labrador_retriever_index = 208label = tf.one_hot(labrador_retriever_index, image_probs.shape[-1])label = tf.reshape(label, (1, image_probs.shape[-1]))perturbations = create_adversarial_pattern(image, label)plt.imshow(perturbations[0]) 定义显示图像的函数1234567def display_images(image, description): _, label, confidence = get_imagenet_label(pretrained_model.predict(image)) plt.figure() plt.imshow(image[0]) plt.title(&#x27;&#123;&#125; \\n &#123;&#125; : &#123;:.2f&#125;% Confidence&#x27;.format(description, label, confidence*100)) plt.show() 加入噪声后再将图像输入模型进行判断12345678epsilons = [0, 0.01, 0.1, 0.15]descriptions = [(&#x27;Epsilon = &#123;:0.3f&#125;&#x27;.format(eps) if eps else &#x27;Input&#x27;) for eps in epsilons]for i, eps in enumerate(epsilons): adv_x = image + eps*perturbations adv_x = tf.clip_by_value(adv_x, 0, 1) display_images(adv_x, descriptions[i]) 其中epsilons 表示噪声的干扰程度。 输入图片 噪声为0.01 识别为Ibizan柴犬 噪声为0.1 识别为浴巾 噪声为0.15 识别为脑珊瑚 噪声为0.20 识别为毛毯 可见，输入图片添加噪声之后已经不能正确分类。","categories":[{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/"},{"name":"Adversarial sample","slug":"AI/Adversarial-sample","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/Adversarial-sample/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/AI/"}]},{"title":"cmd2","slug":"Pwnable_kr/cmd2","date":"2020-10-20T06:07:54.000Z","updated":"2020-10-20T07:27:30.000Z","comments":true,"path":"2020/10/20/Pwnable_kr/cmd2/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd2/","excerpt":"","text":"这里登录的密码为cmd1解出的flag： 1mommy now I get what PATH environment is for :) 查看cmd2.c源代码12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, &quot;=&quot;)!=0; r += strstr(cmd, &quot;PATH&quot;)!=0; r += strstr(cmd, &quot;export&quot;)!=0; r += strstr(cmd, &quot;/&quot;)!=0; r += strstr(cmd, &quot;`&quot;)!=0; r += strstr(cmd, &quot;flag&quot;)!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; delete_env(); putenv(&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;); if(filter(argv[1])) return 0; printf(&quot;%s\\n&quot;, argv[1]); system( argv[1] ); return 0;&#125; cmd2在cmd1的基础上，加强了过滤操作。这里$=、PATH、export、/、$`$、flag$都不可以用。 下面介绍一种方法： 思路分析创建linux软链接方法如下： 12ln -s [源文件或目录][目标文件或目录]# 这里如果当前文件夹下不存在该目标文件，会自动创建，软链接相当于windows的快捷方式 首先在/tmp目录下建立自己的目录xiaohong404(这个目录可以任意取名，但不能和已经存在的文件名重复），然后创建目录*/tmp/xiaohong404/c。那么，如果在/tmp/xiaohong404/c目录下执行pwd命令就可以得到这个路径字符”/tmp/xiaohong404/c“。然后在/tmp/exploit目录下构造cat的软链接ln -s /bin/cat cat，在/tmp/exploit/c下建立flag的软链接ln -s /home/cmd2/flag flag。然后在/tmp/exploit/c下执行命令/home/cmd2/cmd2”$(pwd)at f**，这里表示执行cmd2程序，相当于*./cmd2 “$(pwd)at f\\“就可以得到flag了。其原理就是利用”$(pwd)at”构造出/tmp/xiaohong404/cat**命令。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"cmd1","slug":"Pwnable_kr/cmd1","date":"2020-10-20T02:01:26.000Z","updated":"2020-10-20T07:26:42.000Z","comments":true,"path":"2020/10/20/Pwnable_kr/cmd1/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/20/Pwnable_kr/cmd1/","excerpt":"","text":"查看cmd1.c源代码 putenv函数是添加或者改变一个环境变量。 filter函数的作用是通过strstr函数匹配$flag、sh、tmp$三个字符串，如果检测到这三个字符串，则函数返回值不为0，会导致主函数退出，无法执行system函数。所以这里需要将我们输入的字符串隐藏起来，绕过filter函数的检查，但这里我们需要得到flag。又不能直接输入flag，于是想到可以使用通配符来代替flag。system命令的默认PWD环境变量应该是与这个程序的PWD环境变量相同，这个环境变量是什么，就是默认“./”执行的文件夹目录，一般是根据程序调用的bash窗口目录来的。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"lotto","slug":"Pwnable_kr/lotto","date":"2020-10-19T12:56:14.000Z","updated":"2020-10-20T00:50:22.000Z","comments":true,"path":"2020/10/19/Pwnable_kr/lotto/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/19/Pwnable_kr/lotto/","excerpt":"","text":"查看lotto.c源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play()&#123; int i; printf(&quot;Submit your 6 lotto bytes : &quot;); fflush(stdout); int r; r = read(0, submit, 6); printf(&quot;Lotto Start!\\n&quot;); //sleep(1); // generate lotto numbers int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1)&#123; printf(&quot;error. tell admin\\n&quot;); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf(&quot;error2. tell admin\\n&quot;); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; // win! if(match == 6)&#123; system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;bad luck...\\n&quot;); &#125;&#125;void help()&#123; printf(&quot;- nLotto Rule -\\n&quot;); printf(&quot;nlotto is consisted with 6 random natural numbers less than 46\\n&quot;); printf(&quot;your goal is to match lotto numbers as many as you can\\n&quot;); printf(&quot;if you win lottery for *1st place*, you will get reward\\n&quot;); printf(&quot;for more details, follow the link below\\n&quot;); printf(&quot;http://www.nlotto.co.kr/counsel.do? method=playerGuide#buying_guide01\\n\\n&quot;); printf(&quot;mathematical chance to win this game is known to be 1/8145060.\\n&quot;);&#125;int main(int argc, char* argv[])&#123; // menu unsigned int menu; while(1)&#123; printf(&quot;- Select Menu -\\n&quot;); printf(&quot;1. Play Lotto\\n&quot;); printf(&quot;2. Help\\n&quot;); printf(&quot;3. Exit\\n&quot;); scanf(&quot;%d&quot;, &amp;menu); switch(menu)&#123; case 1: play(); break; case 2: help(); break; case 3: printf(&quot;bye\\n&quot;); return 0; default: printf(&quot;invalid menu\\n&quot;); break; &#125; &#125; return 0;&#125; 程序的大致逻辑为，用户输入6个字符，如果与系统中/dev/urandom随机生成的数相同，累计可以达到6分则最后可拿到flag。显然，需要寻找措施进行绕过，重点在于play函数。 查看play函数 判断用户输入的字符和随机数是否相同本应该是一重for循环，而这里使用了两重for循环，判断的是要求的每一位只要我们输入的6位中存在就可以了，不管是哪一位都可以，只要有六个相等就好了。那只需要一直尝试同一个字符串，总有一次人品好。另外，注意这里随机生成的字符ASCII码范围为1~45，参照ASCII码表，只有 DEC 33 开始才是可见字符，所以需要输入的字符为 ASCII DEC 33 到 45 。 PWN可以编写python脚本，也可以直接自己多次重复输入。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"blackjack","slug":"Pwnable_kr/blackjack","date":"2020-10-19T00:54:25.000Z","updated":"2020-10-19T07:09:34.000Z","comments":true,"path":"2020/10/19/Pwnable_kr/blackjack/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/19/Pwnable_kr/blackjack/","excerpt":"","text":"思路分析本题链接打不开了！！！ 只能参考别人的wp 有两个比较关键的点 判断用户下注的金额如果大于用户拥有的金额，则会提示用户不能下注，但程序的漏洞在于如果输入的金额是负数，会直接通过，并且返回输入的下注金额。 如果用户输了，则会扣除用户下注的金额，这里使用简单的减法操作，结合前面下注金额可以为负数，则直接输入一个很大的负数，之后故意输掉比赛，使得金额超过阈值拿到flag。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"coin","slug":"Pwnable_kr/coin","date":"2020-10-18T13:26:46.000Z","updated":"2020-10-19T07:09:48.000Z","comments":true,"path":"2020/10/18/Pwnable_kr/coin/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/Pwnable_kr/coin/","excerpt":"","text":"使用netcat连接上远程的服务器 题目是一个游戏，大致意思是，一堆硬币，有一个假币，重量为9，而其他为10，要通过给定的C次机会内找到假币。一共要在30s内找到100个假币，也就是完成100次游戏，最终会给出flag。 思路分析简单的二分法，但这里不能从本地直接连远程服务器，这样会超时，需要通过之前的连接登录远程服务器，之后在服务器上编写脚本运行，下面的代码即可成功运行： 1234567891011121314151617181920212223242526272829303132333435from pwn import *import rep = remote(&#x27;localhost&#x27;, 9007)print(p.recv())for i in range(100): N, C = re.findall(&quot;N=(\\d+) C=(\\d+)&quot;, p.recv())[0] N = int(N) C = int(C) print(N, C) start, end = 0, N-1 while start &lt;= end and C &gt; 0: mid = (start + end) // 2 x = &quot; &quot;.join([str(j) for j in range(start, mid+1)]) # build range list p.sendline(x) res = int(p.recvline()[:-1]) if res % 10 == 0: start = mid+1 # through first half else: end = mid-1 # through second half C -= 1 while C &gt; 0: # use all the tries p.sendline(&quot;0&quot;) p.recv(1024) C -= 1 p.sendline(str(start)) # final answer print(p.recv())print(p.recv()) 注意这里有个细节是需要先进入服务器的/tmp文件夹下，之后自己再主动建立一个新的文件夹，否则会没有权限访问python的库，一直提示未定义的错误。之后在这个新的文件夹下建立一个python文件，可以随便取个名字，这里我就命名为coin.py。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"shellshock","slug":"Pwnable_kr/shellshock","date":"2020-10-18T06:00:22.000Z","updated":"2020-10-19T07:10:16.000Z","comments":true,"path":"2020/10/18/Pwnable_kr/shellshock/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/Pwnable_kr/shellshock/","excerpt":"","text":"查看shellshock.c源文件 程序依次运行三个函数*setresuid、setresgid、system* 查看程序的执行权限 以shellshock身份启动时，程序的权限是other权限r-x，而在setresuid和setresgid中使用的是effective gid，也就是shellshock_pwn的权限r-s，当程序执行到system时，程序已经具有shellshock_pwn组权限了。 这个组权限对于flag文件来说是可读的（r–），但是问题在于这一段程序并没有涉及对flag的读操作，权限虽然有了，但怎么办呢？显然这里利用shellshock漏洞。可通过下面的命令证明确实存在shellshock漏洞： 1env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; ./bash -c &quot;echo this is a test&quot; 实际上，“x=’() { :;}; echo vulnerable”​是new出来了一个新的环境变量： 12KEY=xVALUE=() &#123;:;&#125;; echo vulnerable 而当我们后续执行bash的时候，最终会定位到initialize_shell_variables中，这个函数内部会遍历所有的环境变量，而我们设计的VALUE绕过了其中一个export函数的定义检查，使得最终执行的是后面的echo vulnerable串。所以，调用bash的时候，自定义的这个语句就会触发。简而言之，这个漏洞会把用户输入的指令当作代码执行。 于是，我们在这条语句的基础上将自定义语句换为bash -c “cat ./flag”，执行的程序bash -c换成./shellshock(它内部调用了bash -c ‘echo shock_me’)，因此当执行shellshock中的system函数会调用bash，总而自动执行cat flag这条命令，因为./shellshock执行时拿到了shellshock_pwn的权限，从而破壳漏洞可以在此权限上成功执行了cat ./flag，即成功实现了提权操作。 PWN运行下面语句拿到flag 1env x=&#x27;() &#123; :;&#125;; bash -c &quot;cat ./flag&quot;&#x27; ./shellshock 关于shellshock漏洞相关知识可参考： 1、关于ShellShock漏洞的利用过程和原理解析 - CSDN博客 2、破壳（ShellShock）漏洞样本分析报告","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"mistake","slug":"Pwnable_kr/mistake","date":"2020-10-18T05:13:53.000Z","updated":"2020-10-19T07:10:04.000Z","comments":true,"path":"2020/10/18/Pwnable_kr/mistake/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/18/Pwnable_kr/mistake/","excerpt":"","text":"查看mistake.c源文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)&#123; printf(&quot;can&#x27;t open password %d\\n&quot;, fd); return 0; &#125; printf(&quot;do not bruteforce...\\n&quot;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf(&quot;read error\\n&quot;); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf(&quot;input password : &quot;); scanf(&quot;%10s&quot;, pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf(&quot;Password OK\\n&quot;); system(&quot;/bin/cat flag\\n&quot;); &#125; else&#123; printf(&quot;Wrong Password\\n&quot;); &#125; close(fd); return 0;&#125; 整个程序的执行逻辑为，打开系统目录下保存密码的文件，之后开辟了一个数组读取该密码文件中的密码并保存，之后由用户输入10字节长的密码，存放到一个新的数组中，将用户输入的密码进行与$0x1$进行异或（按位取反）操作，之后将两个数组的内容进行比较，如果数组中的内容相同，则验证通过，可执行system函数拿到flag。 思路分析最自然的想法是直接爆破10位用户的密码，但代码中打印“do not bruteforce”，并且在题目中提示operator priority，因此审查源代码中存在两个运算符以上的语句： 这里$&lt;$运算符的优先级高于$=$运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对。这里的正确写法如下： 1if((fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400)) &lt; 0) 而另一方面，0作为文件描述符，它指向的是stdin。 因此，后面的read函数实际上是从stdin读取，而不是password文件，而stdin我们可以控制，则我们可以输入任意已知的密码，之后再输入与$0x1$异或的值，使得两次输入的密码相匹配。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Heap II","slug":"Heap-II","date":"2020-10-17T13:32:43.000Z","updated":"2020-10-19T07:10:32.000Z","comments":true,"path":"2020/10/17/Heap-II/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/17/Heap-II/","excerpt":"","text":"[原版传送门] UNDERSTANDING THE GLIBC HEAP IMPLEMENTATION前一部分解释了malloc和free的基本行为。我们看到，malloc通过分配内存块来处理内存分配请求。每个块不仅存储程序员将与之交互的malloc返回的“用户数据”区域，还存储与该块关联的元数据。 我们看到了堆管理器的基本块分配策略是如何工作的，并且看到了当没有已经释放的块可以被用于响应用户的请求时，如何从堆的顶部创建新块。 接下来这篇文章，将解释这种块回收策略是如何工作的，即如何将已经分配的块被free然后保存起来，并最终回收以服务之后的malloc请求。许多堆利用技术都依赖于这些内部机制，但是现在，让我们看看堆正确运行时如何通过free回收这些块。 HOW DOES FREE WORK?当程序员完成malloc的分配块的任务（或malloc兼容的分配，如calloc）后，程序员将通过free将其释放回堆管理器。在C标准定义了free（NULL）什么也不做，但对于所有其他free调用，堆管理器的第一份工作是使指针指回其相应的块。堆管理器通过从传递给free的指针中减去该块元数据的大小来实现此目的。 从指针到块的这种转换之所以有效，是因为用户数据区域位于块内，但是，仅当传递给free的指针确实来自malloc的实时分配时，该转换才有效。如果将其他一些指针传递给free，则堆管理器可能释放或回收无效的块，从而导致内存损坏问题，这可能导致进程崩溃，甚至可能使黑客远程接管该进程。 因此，free首先进行了一些基本的检查，检查是否这个释放的块是显然无效的，防止之后再分配。如果其中任何一个检查失败，则程序中止。检查包括： 检查分配是否在8字节（或64位为16字节）边界上对齐，因为malloc确保所有分配都对齐。 检查块的大小字段是否可能，因为它可能太小，太大，或者没有对齐字节，还是因为它与进程地址空间的末尾重叠。 检查块位于arena的边界内。 通过检查位于下一个块开头的元数据中的相应“ P”位，检查该块是否尚未标记为空闲。 这里的堆管理器检查并不详尽。攻击者控制的指向数据的指针可能会绕过这些完整性检查，并且仍会在进程中触发内存崩溃。我们将在以后的文章中更详细地介绍这一点。 FREE CHUNK METADATA在上一篇文章中，展示了已分配块如何将元数据与程序员使用的“用户数据”区域一起存储。这些已经分配的块存储了“块大小”以及其元数据中的三个位，分别称为“ A”，“ M”和“ P”。这些位可分别帮助堆管理器记住该块是否是从非主arena分配的，是否是通过mmap进行堆外分配的，以及前一个块是否是空闲的。 空闲块也存储元数据。类似已分配的块，他们存储“块大小”，“A”和“P”字段，但他们不使用“M”字段，因为一个MMAP过的块在释放期间将永远是munmap-ed（取消虚拟内存映射），而不是转变成一个free块回收，即空闲块的”M“字段是一个确定的值，一定不会通过mmap从堆外分配。 空闲块还使用称为“边界标签”的技术在用户数据区域之后存储信息。这些边界标签在块之前和之后携带大小信息。这允许从任何已知的块开始并在任何方向上遍历块，从而能够非常快速地合并相邻的空闲块。 这些释放的块存储在相应的”free bins“中，这些“free bins”用作链表。这要求每个空闲块还存储指向其他块的指针。由于释放的块中的“用户数据”（根据定义）是免费供堆管理器使用的，因此堆管理器将释放的块中的“用户数据”区域重新定位为额外的元数据所在的位置。 RECYCLING MEMORY WITH BINS在内部，堆管理器需要记录释放的块，以便malloc可以在分配请求期间重用它们。在最初的实现中，堆管理器可以通过将所有释放的块简单地存储在某个巨大的链表中来完成此操作。这可以工作，但是会使malloc变慢。由于malloc是大多数程序的高利用率组件，因此这种缓慢将对系统上运行的程序的整体性能产生巨大影响。 为了提高性能，堆管理器而是维护一系列称为“ bins”的列表，这些列表旨在最大程度地提高分配和释放的速度。共有5种类型bins：每个线程62 small bins, 63 large bins, 1 unsorted bin, 10 fast bins and 64 tcache bins 。 small，large，unsorted bins是最古老的bin类型，其实现这里将其称为堆的基本回收策略。fast bins和tcache bins是在这些基础上的优化。 容易混淆的地方在于，在堆管理器的源代码中，small，large，unsorted bins都一起存在同一数组中。索引0没有被使用，索引1是unsorted bin，2-64是small bins，65-127是large bins。 CHUNK RECYCLING: THE BASIC STRATEGY在tcache和fastbin优化之前，首先来看一下堆管理器使用的基本回收策略。 free的基本算法如下（低地址在前，高地址在后）： 如果块在元数据中设置了M位，则分配是在堆外分配的，则应该被munmap。 否则，如果该块之前的块是空闲的，则将之前的块向后合并以创建更大的空闲块。 同样，如果此块之后的块是空闲的，则将之后的块将向前合并以创建更大的空闲块。 如果这个之后可能更大的块与堆的“顶部”相邻，则整个块将被存储到堆的末端，而不是存储在“ bin”中。 否则，该块将被标记为空闲并将其放置在适当的bin中。 SMALL BINSsmall bins是最容易理解的基本bin。它们有62个，每个small bin都存储相同大小的固定块。在32位系统上小于512字节（在64位系统上小于1024字节）的每个块都有一个对应的small bin。由于每个small bin仅存储一个特定大小的块，它们会自动排序，因此在这些列表中插入和删除条目的速度非常快。 LARGE BINSsmall bins的策略非常适合小型分配，但是我们无法为每个可能的块大小都设置一个存储区。对于超过512字节（64位为1024字节）的块，堆管理器将改为使用large bins。 63个large bins中的每个大都与small bins以相同的方式运行，但是它们不是存储固定大小的块，而是存储一定大小范围内的块。每个large bins的大小范围都设计为与small bins的块大小或其他large bins的范围不重叠。换句话说，在给定块的大小的情况下，恰好只有一个对应于此大小的small bin或large bin。 由于large bins存储一定大小范围的块，因此向large bin中插入一个块必须手动进行排序，并且从链表中的分配也需要遍历该列表。这使得large bins本质上比small bins慢。但是，在大多数程序中，large bins的使用频率较低。这是因为平均意义上说，程序更倾向于以更高的频率分配（或释放）小的分配块。出于相同的原因，large bins的使用频率会聚集在覆盖范围较小的large bin中；最小的large bin仅覆盖从512字节到576字节的64字节范围的块，而第二大的large bin则覆盖256KB的大小范围的块。最大的large bin覆盖了1MB以上的所有已释放块。 UNSORTED BIN堆管理器使用称为unsorted bins的优化缓存层面进一步改善了基本的分配算法。此优化基于以下观察结果：通常这些free的块都聚集在一起，并且释放后通常立即分配大小相似的块。例如，释放树或列表的程序通常会一次释放大多数分配空间中的所有条目，或者更新列表中条目的程序可能会释放前一个条目，然后再分配新的空间替换条目。 在这些情况下，在将较大的块放入正确的bin中之前合并这些释放的块将避免一些开销，并且在分配过程中能够快速返回最近释放的块将简单地加快整个过程。 因此堆管理器引入了unsorted bin，当一个块释放时，堆管理器没有立即将新释放的块放入相应的bin中，而是与相邻的块合并，然后将其转储到常规的unsorted的链表中。在malloc期间，将检查unsorted bins上的每个项目，以查看其是否“适合“请求。如果大小匹配，malloc可以立即使用它。如果没有匹配的块，则malloc之后会将块放入其相应的small bins或large bins中。 FAST BINSfast bins是在之前看到的三个基本bin基础上的进一步优化。这些bins实际上将最近释放的小块保留在“fast-turnaround queue”中，并且在块被释放之后不将其与相邻的块合并，使得这些块始终保持活跃状态，以便在释放后不久若有匹配该块大小的malloc请求，可以立即重新利用该块。 像small bins一样，每个fast bins仅负责单个固定大小的块。有10个这样的fast bins，覆盖大小为16、24、32、40、48、56、64、72、80和88字节的块以及块元数据。 与small bins不同，fast bins的块永远不会与相邻的块合并。实际上，这是堆管理器不会在下一个块的开头设置“ P”位的方式。换句话说，在概念上可以认为，堆管理器不会“真正”释放fast bins中的块。 和small bins相同的部分在于，fast bins也仅覆盖固定的大小的块，并且会自动排序分类，因此插入和删除的速度也非常快。而且，由于fast-binned的块永远不会合并，因此它们只需要被存储在单链表，而不需要存储在双向链表中，因为其不存在合并块时从列表中进行删除的操作。 当然，fast bin的缺点是，fast bin块不会“真正”释放或合并，最终会导致进程的内存空间随着时间的流逝而碎片化和膨胀。为了解决这个问题，堆管理器会定期“合并”堆。通过“实际释放”它（即将其与相邻的空闲块合并），并将生成的空闲块放置到unsorted bins上，以供malloc之后使用，从而“刷新”fast bins中的每个条目。 每当释放任何大于64KB的块（其中64KB为近似值 ），或用户发出大于fast bin可以处理的malloc请求（即对于32位中512字节以上的块或64位中1024字节以上的块）时，或者当程序调用malloc_trim或mallopt时，都会发生“合并”阶段。 TCACHE (PER-THREAD CACHE) BINS堆管理器用来加快分配速度的最终优化是每个线程进行缓存或“ tcache”分配器。首先让我们看一下tcache试图解决的问题。 假如一个计算机系统上的每个进程都同时运行一个或多个线程。多线程允许一个进程执行多个并发操作。例如，一个大容量的Web服务器可能同时具有多个传入请求，并且该Web服务器可能让每个传入请求都在自己的线程上进行服务，而不是让每个请求都排成一队等待服务。 给定进程中的每个线程共享相同的地址空间，也就是说，每个线程可以在内存中看到相同的代码和数据。每个线程都有自己的寄存器和堆栈来存储临时局部变量，但是诸如全局变量和堆之类的资源在所有线程之间共享。 协调访问诸如堆之类的全局资源是一个复杂的话题，它出错可能导致一个称为“race condition”的问题，这会导致难以调试的崩溃，通常也可被黑客利用。 假设在一个线程上提供服务的Web请求尝试更新数据库某一行，而另一个并发Web请求尝试从同一行读取。通常，我们将要确保第二个线程永远不会看到中间写入的值，但因为它正被另一个线程覆盖使用，从而第二个线程可能看到部分或损坏形式的行数据。数据库通过使读写操作看起来像原子操作来解决此问题：如果两个线程试图同时访问同一行，则必须先完成一个操作，然后才能开始下一个操作。解决这些竞争条件的一种非常常见的方法是通过使用锁，使其他同时访问全局资源的请求强制进入顺序队列。 通常，锁是通过一个线程在其使用之前“标记”它拥有全局资源的所有权，然后执行其操作，然后标记该资源不再使用来进行锁定的。如果出现另一个线程并希望使用该资源并看到其他线程正在使用该资源，则该线程将等待，直到另一个线程完成。这样可以确保全局资源一次仅由一个线程使用。但这带来了成本：正在等待资源的线程停滞并浪费时间。这称为“lock contention”（锁争用）。 对于许多全局变量，这个开销还可以接受。但是对于所有线程都在不断使用的堆，此开销会很快导致整个程序的速度变慢。 堆管理器主要通过为每个线程创建自己的arena解决这个问题，直到达到arena分配数目的阈值。此外，tcache 中per-thread cache的目的是减少锁本身的成本，因为锁指令开销很大，并且最终会占用”fast-path“中很大一部分执行时间。此功能已添加到glibc 2.26中的malloc内存分配功能中，并且默认情况下启用。 Per-thread caching通过准备好小块的per-thread bins来加快分配速度。这样，当线程请求一个块时，如果该线程在其tcache上有一个块可用，则它可以为分配提供服务，而不必等待堆锁。 默认情况下，每个线程都有64个单链接的tcache bins。每个bin最多包含7个相同大小的块，在64位系统上为24到1032字节，在32位系统上为12到516字节。 HOW DO CHUNKS END UP IN TCACHE BINS?一个块被释放后，堆管理器将查看该块是否存在与该块大小相对应的tcache容器。与fast bin一样，tcache bin 上的块被视为“正在使用”，并且不会与相邻释放的块合并。 如果匹配该块大小的tcache已满（或者该块对于tcache bin而言太大），则堆管理器将恢复到我们以前的”slow-path“策略，即获取堆锁，然后像以前一样处理该块。 相应的tcache分配策略也非常简单。如果在匹配的tcache bin上有块可用，则给定一个块请求，堆将返回该块，而不会获得堆锁。如果块对于tcache来说太大，继续采用”slow-path“策略。 在我们尝试进行分配的情况下，有一个对应的tcache bin，但如果这个bin已满，我们进行了稍微修改的分配策略。我们不只是获取堆锁并查找单个块，还获取了堆锁，并趁机将尽可能多的这种大小的块提升到tcache，（时间局部性和空间局部性）同时我们仍然保持堆锁，直到tcache bin限制为七个，并且将最后匹配的块返回给用户。 PUTTING IT ALL TOGETHER下面让我们整体回顾一下，glibc中整个malloc、free的实现的算法。 首先，每个分配的内存块是对齐的，并包含元数据以及用户区域。当程序员从堆中请求内存时，堆管理器首先计算出分配请求对应的块大小，然后按以下顺序搜索内存（这里直接考虑多线程）： 如果请求的块大小与tcache bin相匹配，并且tcache bin中有可用的块，则立即分配返回。 如果请求的块很大，则通过mmap分配堆外资源 否则，我们将获得arena heap lock，并且按照以下策略顺序执行： ​ A、尝试fast bin / small bin回收策略 如果存在相应的fast bin，尝试找到一个块匹配（同时用fast bins中的条目（如果存在匹配）预填充tcache） 否则，如果存在对应的small bin，尝试找到一个块匹配（同时预填充tcache） ​ B、解决所有延期释放块 否则，fast bin中的条目将被真正释放，并且将其合并到unsorted bin中。 遍历unsorted bin中的所有条目。如果匹配，则停止。否则，在操作时将unsorted中的条目放在其相应的small/large bin中（同时尽可能提升small bin中的条目到tcache bin） ​ C、默认回到基本回收策略 如果块大小与一个large bin相匹配，则立即搜索相应的large bin ​ D、从头创建一个新的块 否则，将没有可用的块，所以尝试从堆顶部获取一个块 如果堆的顶部空间不足，尝试使用sbrk对其进行扩展 如果遇到了地址空间的其他问题，导致堆不可以扩展，则使用mmap创建一个不连续的扩展并从那里进行分配。 ​ E、如果所有方法均失败，则返回NULL 。 以及相应的free策略： 如果指针为NULL，则C标准将该行为定义为“不执行任何操作”。 否则，通过减去块元数据的大小，将指针指回。 对块执行一些完整性检查，如果完整性检查失败，则中止。 如果该块适合放入tcache bin，则将其存储在其中。 如果该块设置了M位，则通过munmap将其返回给操作系统。 否则，我们将获得arena堆锁，然后： 如果该块适合一个fastbin，将其放在相应的fastbin上，结束。 如果块大于64KB，立即合并fastbin，然后将合并的块放入unsorted bin中。 将数据块与相邻的释放的数据块在small bin、large bin、unsorted bin中前后合并。 如果生成的块位于堆的顶部，则将其合并到堆的顶部，而不是将其存储在bin中。 否则将其存储在unsorted bin中。（Malloc稍后会做工作，将unsorted bin中的条目放入small bin或者large bin中。）","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"Heap I","slug":"Heap-I","date":"2020-10-16T14:10:00.000Z","updated":"2020-10-19T07:10:26.000Z","comments":true,"path":"2020/10/16/Heap-I/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/Heap-I/","excerpt":"","text":"原版传送门 WHAT IS THE HEAP, AND WHY DO PEOPLE USE IT?堆是C/C++程序员在程序执行期间手动分配的新的区域。程序员通过调用堆相关的函数如malloc向堆管理器请求这部分区域。这些被分配的内存区域，或者称为“allocations”，之后可以被程序员一直使用、修改或者引用，直到他们不再需要这部分区域，会调用free函数将这部分区域返还给堆管理器。 下面是一个C语言程序分配、使用并且释放堆上的结构体的例子： 123456789101112131415161718typedef struct &#123; int field1; char* field2;&#125; SomeStruct;int main()&#123; SomeStruct* myObject = (SomeStruct*)malloc(sizeof(SomeStruct)); if(myObject != NULL) &#123; myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); free(myObject); &#125; return 0;&#125; 所以只要程序员遵循下面几个小的规则，堆管理器将确保每个已分配的堆不会相互重叠。这个特点使得堆非常有用并且高效，这和大多数C/C++程序追求性能的要求相符合。 接下来的图表列出了一些程序员在使用堆时的基本规则，以及在程序员违反这些规则时发生的一些漏洞类别。之后，我将更详细地讨论所有这些与堆相关的漏洞类别，目前只讨论堆使用正确时的表现。 HEAP RULES 当然，malloc和free并不是C和C++程序员与堆进行交互的唯一方式。相反，C++开发人员通常通过C++运算符new和new []分配内存。必须使用相应的C++运算符delete和delete []而不是free释放这些分配。程序员还可以通过与malloc兼容的堆函数（例如calloc，realloc和memalign）来分配内存，这些函数最终也通过free释放，就像malloc一样。 为简单起见，将首先讨论malloc和free，下面是一个C++程序如何分配，使用和释放堆上的结构体的例子： 12345678910111213141516class SomeClass&#123;public: int field1; char* field2;&#125;;int main()&#123; SomeClass* myObject = new SomeClass(); myObject-&gt;field1 = 1234; myObject-&gt;field2 = “Hello World!”; do_stuff(myObject); delete myObject; return 0;&#125; MEMORY CHUNKS AND THE CHUNK ALLOCATION STRATEGIES假设一个程序员通过malloc需求10字节内存，为了满足这个请求，堆管理器不仅仅只随机寻找一个10字节的程序员可以写的区域，而是需要做更多的事情。堆管理器也需要存储此次分配的元数据。这个元数据被存储在紧邻分配的10字节区域处。 堆管理器还需要确保分配空间在32位系统上是8字节对齐的，在64位系统上是16字节对齐的。如果程序员只想存储文本字符串或字节数组之类的数据，那么分配空间的对齐方式无关紧要。但是如果程序员打算使用分配空间来存储更多复杂的数据结构，则对齐方式会对程序的正确性和性能会产生重大影响。由于malloc无法知道程序员将在分配空间中存储什么内容，因此堆管理器必须默认确保所有分配空间均对齐。 此分配元数据和对齐填充字节与malloc的内存区域将一起被存储并返回给程序员。因此，堆管理器在内部分配的“块”内存比程序员最初要求的稍大。当程序员要求10个字节的内存时，堆管理器会找到或创建一个新的内存块，该块足以存储10个字节的空间、元数据以及对齐填充字节。然后，堆管理器将此块标记为“已分配”，并返回指向块内对齐的10字节“用户数据”区域的指针，程序员将收到malloc调用的返回值。 CHUNK ALLOCATION: BASIC STRATEGY那么堆管理器如何在内部分配这些块呢？ 首先，让我们看一下堆管理器的大部分工作，分配小块内存的（大大简化的）策略。我将在详细地解释每个步骤，之后我们就可以研究分配大块内存的特殊情况。 简化的小块分配策略如下： 如果有一个先前释放的内存块，并且该块足够大，可以满足用户的请求，则堆管理器将使用这个释放的块进行新的分配。 否则，如果堆顶部有可用空间，则堆管理器将从这个空闲的空间中分配一个新的块并使用它。 否则，堆管理器将要求内核向堆的末尾添加新的内存，并且从新分配的空间中分配一个新块给用户。 如果前面所有策略均失败，则无法为提供分配服务，并且malloc返回NULL。 ALLOCATING FROM FREE’D CHUNKS 从概念上讲，分配之前释放的块非常简单。因为当一个块在内存中被释放，堆管理器会在一系列称为“bins”的不同链表中记录这些释放的块。用户发出一个分配请求后，堆管理器会在这些“bins”中搜索一个足够大的空闲块，为用户提供服务。如果可以成功找到一个，则将这个空闲块从特定的bin中删除，并标记为“已分配”，然后这个指向该“user data”区域块的指针，会作为malloc的返回值返回给程序员。 出于性能原因，有几种不同类型的bins，即fast bins 、unsorted bins 、small bins、large bins 、per-thread tcache。下个部分将详细讨论这些不同种类的bins。 ALLOCATING FROM THE TOP OF THE HEAP 如果没有可用的空闲块可以满足分配请求，则堆管理器必须从头开始构造一个新块。为此，堆管理器首先查看堆顶部是否有足够的可用空间（有时称为“top chunk”或“remainder chunk”）。如果存在，堆管理器将在此可用空间基础上构造一个新块。 ASKING THE KERNEL FOR MORE MEMORY AT THE TOP OF THE HEAP 一旦堆顶部的可用空间用完，堆管理器将不得不要求内核在堆的末尾增加更多内存。 在建立堆的开始阶段上，堆管理器通过调用sbrk，要求内核在堆末尾分配更多的内存。在大多数基于Linux的系统上，在内部使用称为“ brk ”的系统调用。这个系统调用的名称很容易混淆，它最初的意思是“更改程序中断位置”，通俗来说，它表示在程序加载到内存之后，该区域会增加更多的内存。因为这是堆管理器从一开始创建堆的地方，所以此系统调用的作用是在程序堆的末尾分配更多的内存。 最终，如果一直使用sbrk扩展堆会导致分配失败，因为堆空间增长得太大之后，进一步扩展将导致其与进程地址空间中的其他内容发生冲突，例如内存映射，共享库或线程的堆栈区域。因此sbrk无法分配时，堆管理器将使用mmap调用将新的非连续内存附加到初始程序堆。 如果mmap也失败，则该进程根本无法分配更多的内存，并且malloc将返回NULL。 OFF-HEAP ALLOCATIONS VIA MMAP很大的分配请求（超过某个阈值*）在堆管理器中会得到特殊处理。通过直接调用mmap可以在堆外分配这些大块，并使用块中元数据的标记位来标记这一事实。当这些巨大块通过调用free释放到堆管理器时，堆管理器将通过munmap将整个mmap 过的区域返还给系统。 *默认情况下，此阈值 在32位系统上为128KB~512KB，在64位系统上为32MB，但是，如果堆管理器检测到这些分配的大块内存只需要被临时使用，则此阈值也会动态增加。 ARENAS在多线程应用程序上，堆管理器需要保护内部堆数据结构免受可能导致程序崩溃的竞争条件的影响。在ptmalloc2之前，堆管理器通过在每次堆操作之前简单地使用全局互斥锁，以确保在任何给定时间只有一个线程可以与堆进行交互。 尽管此策略有效，但堆分配器对高利用率和性能非常敏感，以至于导致使用大量线程的应用程序出现严重的性能问题。为了解决这个问题，ptmalloc2堆分配器引入了“arenas”的概念。每个“arenas”本质上是一个完全不同的堆，它完全独立地管理自己的块分配和free bins。每个“arenas”仍然使用互斥锁来序列化不同线程对内部数据结构的访问，但是只要线程与不同的“arenas”进行交互，线程就可以安全地执行堆操作而不会彼此停顿。 程序的初始（“main”）“arenas”仅包含我们已经看到的堆，对于单线程应用程序，这是堆管理器将使用的唯一arena。但是，随着新线程加入该进程，堆管理器会为每个新线程分配并附加“arenas”，以减少malloc和free等操作的等待时间。 对于每个加入该进程的新线程，堆管理器将先查找没有被其他线程在使用的“arenas”，并将该“arenas”附加到该线程。一旦所有可用的“arenas”都是在其它线程使用中，堆管理器将创建一个新的“arenas”，直到“arenas”的数目达到最大（32位进程为CPU核心数的2倍、64位进程位CPU核心的8倍）。一旦最终达到该限制，堆管理器就会放弃分配，这样多个线程将必须共享一个“arenas”，即执行堆操作将需要那些线程中的一个等待另一个线程。 但是这些二级“arenas”如何工作？我们看到，主堆在程序加载到内存的紧邻其后的位置，并使用brk系统调用对其进行扩展开始工作，但二级“arenas”并不相同，这些二级“arenas”使用mmap和mprotect创建的一个或多个“子堆”来模拟主堆的行为。 SUBHEAPS 子堆的工作方式与初始程序堆基本相同，主要存在两个区别。初始堆位于程序加载到内存之后的紧邻其后的位置，并且由sbrk动态扩展。相比之下，每个子堆使用mmap定位到内存中，堆管理器使用mprotect手动模拟增长子堆。 当堆管理器想要创建子堆时，它首先通过调用mmap要求内核保留该子堆可能增长到的内存区域。保留该区域不会将内存直接分配到子堆中；它只是要求内核不要在该区域内分配诸如线程堆栈，mmap区域或者其它的分配任务。*默认情况下，子堆大小最大（即保留该子堆使用的内存区域）在32位上为1MB，在64位系统上为64MB。 这是通过mmap询问标记为PROT_NONE的页面来完成的，这表明内核仅需要为该区域保留地址范围，不需要内核将内存直接分配给它。 在使用sbrk增长初始堆的地方，堆管理器通过手动调用mprotect将区域中的页面从PROT_NONE更改为PROT_READ | PROT_WRITE来将子堆“增长”到此保留的地址范围。这导致内核将物理内存附加到那些地址，实际上也会导致子堆缓慢增长，直到整个mmap区域已满。一旦整个子堆都用完，arenas便会分配另一个子堆。这将允许二级”arenas”几乎无限期地保持增长，直到内核耗尽内存或进程耗尽地址空间时才会失败。 Recap：初始（“main”）arena仅包含主堆，该主堆位于将程序二进制文件加载到内存之后的位置，并使用sbrk进行扩展。这是用于单线程应用程序的唯一arena。在多线程应用程序上，为新线程分配了二级arena，从中可以分配这些二级arena。使用arenas可以降低线程在执行堆操作之前需要等待互斥锁的可能性，从而提高了程序的速度。与main arena不同，这些二级arena从一个或多个子堆中分配块，这些子堆在内存中的位置首先使用mmap进行确定，并通过使用mprotect进行扩展。 CHUNK METADATA现在，了解了分配块的所有不同方式，这些块不仅包含提供给程序员的“用户数据”区域（作为malloc的返回值），同时包含元数据。下面介绍元数据实际记录的值以及存放的位置。 块的元数据在内存中的确切布局可能会很混乱，因为堆管理器源代码将一个块末尾的元数据与下一个块末尾的元数据组合在一起，并且几个存在并被使用的元数据字段取决于不同种类的chunk。 现在，我们仅看一下实时分配，它具有单个size_t * 标头，该标头位于给程序员的“用户数据”区域的后面。此字段（在源代码中称为mchunk_size）是在malloc期间写入的，之后由free决定如何处理该分配空间的释放。 * size_t值在32位系统上为4字节整数，在64位系统上为8字节整数。 该mchunk_size存储了四种信息：块的大小，以及被称为“A”,“M”和“P”三比特位。这些都被存储在相同的size_t字段中，因为块大小始终是8字节对齐的（在64位上是16字节对齐），因此，块大小的低三位始终为零。 “ A ”标志是用来告诉堆管理器，是否该块属于二级arena，而不是在main arena。在free期间，堆管理器仅仅给了一个指向程序员想要释放空间的指针，并且堆管理器需要确定该指针属于哪一个arena。如果在块的元数据中A标志被设置，则堆管理器必须搜索每个arena，并查看指针是否位于该arena的任何子堆中。如果未设置该标志，则堆管理器可以减少搜索，因为它知道该块来自初始的arena。 “ M ”标志用于指示该块是一个通过mmap进行堆外分配的巨大分配。当此分配空间最终返回给free时，堆管理器将通过munmap立即将整个块返回给操作系统，而不是尝试对其进行回收。因此，空闲即已经被释放的块永远不会设置该标志位。 “ P ”标志令人困惑，因为它实际上属于先前的块。它指示先前的块是一个空闲块。这意味着当这个块被释放时，可以将其安全地连接到先前的块上，以创建更大的空闲块。 下面是一些和堆相关的文章： Once upon a free() Malloc des-maleficarum The house of lore Advanced Doug Lea’s malloc exploits Yet another free() exploitation technique","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"uaf","slug":"Pwnable_kr/uaf","date":"2020-10-16T02:26:47.000Z","updated":"2020-10-19T07:10:20.000Z","comments":true,"path":"2020/10/16/Pwnable_kr/uaf/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/16/Pwnable_kr/uaf/","excerpt":"","text":"查看uaf.cpp文件源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system(&quot;/bin/sh&quot;); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; 程序定义一个名为human的虚基类，之后定义了Man和Woman两个类继承这个类，并各自重写了父类的introduce()方法，主函数中，分别创建了一个Man和Woman的对象, 用户可以输入三个选项，分别为： use：Man和Woman分别调用introduce()方法，即使用指针指向的函数 after：分配一段地址空间存储main函数传递的数据，我们可以用其将已经被free的内存，重新allocate free：delete释放掉创建的对象的空间，即将指针指向的内存释放 三者的组合即可构成UAF漏洞 背景知识前置知识1：虚函数的内存地址空间在C++中，如果类中有虚函数，那么它就会有一个虚函数表的指针__vfptr，在类对象最开始的内存数据中。之后是类中的成员变量的内存数据。对于子类，最开始的内存数据记录着父类对象的拷贝（包括父类虚函数表指针和成员变量）。 之后是子类自己的成员变量数据。 1234567891011121314151617181920212223242526272829303132class Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125; int base; protected: private: &#125;; //子类1，无虚函数重载 class Child1 : public Base &#123; public: virtual void f1() &#123; cout &lt;&lt; &quot;Child1::f1&quot; &lt;&lt; endl; &#125; virtual void g1() &#123; cout &lt;&lt; &quot;Child1::g1&quot; &lt;&lt; endl; &#125; virtual void h1() &#123; cout &lt;&lt; &quot;Child1::h1&quot; &lt;&lt; endl; &#125; int child1; protected: private: &#125;; //子类2，有1个虚函数重载 class Child2 : public Base &#123; public: virtual void f() &#123; cout &lt;&lt; &quot;Child2::f&quot; &lt;&lt; endl; &#125; virtual void g2() &#123; cout &lt;&lt; &quot;Child2::g2&quot; &lt;&lt; endl; &#125; virtual void h2() &#123; cout &lt;&lt; &quot;Child2::h2&quot; &lt;&lt; endl; &#125; int child2; protected: private: &#125;; 单一继承，无虚函数重载 单一继承，重载了虚函数 多重继承 总结 如果一个类中有虚函数，那么就会建立一张虚函数表vtable，子类继承父类vtable，若，父类的vtable中私有(private)虚函数,则子类vtable中同样有该私有(private)虚函数的地址。注意这并不是直接继承了私有(private)虚函数 当子类重载父类虚函数时，修改vtable同名函数地址，改为指向子类的函数地址，若子类中有新的虚函数，在vtable尾部添加。 vptr每个对象都会有一个，而vptable是每个类有一个，vptr指向vtable，一个类中就算有多个虚函数，也只有一个vptr；做多重继承的时候，继承了多个父类，就会有多个vptr Use-After-FreeDangling pointer Dangling pointer即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为NULL。 UAF原理对Dangling pointer所指向内存进行use，如指针解引用等。 利用思路将Dangling pointer所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串） 举个栗子123456typedef struct&#123; int id; char *name; int (*func)() //函数指针，可以理解为类里面的方法&#125;; 假设有上述这样的一个结构体指针p，在释放掉p之后，没有将p置NULL，所以p变成Dangling pointer，再通过重新分配，再次拿到p之前指向的这段地址空间。之后，通过strcpy(p2,”addr”)，或者其他方式，向这段地址空间写入新数据。然后当我们通过其他函数，再次使用p指针，就会造成无法预料的后果，因为此时p指针指向的内存包含的内容已经改变。 数据控制 任意地址读：$puts(p-&gt;name)—————&gt;puts(char*(addr2))$ 任意地址写：$strcpy(p-&gt;name,data);——&gt;strcpy((char *)(addr2),data)$ 控制流劫持：$p-&gt;func()———————&gt;call\\ addr3$ 解题思路查看文件保护措施 思路分析可以看出Man和Woman都是继承了Human类，并且可以看出只要我们将控制流劫持到Human类的私有虚函数give_shell，就能getshell了。 基本思路为：将main函数创建的两个对象先free，但指针并没有被销毁，之后我们allocate同样的大小，可以得到原先被释放的内存，这样就得到一个可控的地址空间，并且这个空间中记录了之前vptr指针，这样可通过改写这个虚表指针的值，之后再利用use，即m-&gt;introduce()时，劫持程序执行流，将本来执行的introduce函数变成执行give_shell函数。注意main中输入2分配空间是读取传入的两个参数，第一个决定分配空间的大小，第二个是读入一个文件，将文件中的内容写入到刚刚分配的空间中，因此我们首先要取得之前释放的空间，为保证这一点，需要使得传递的参数和之前释放的空间大小相同，而且这里需要分配两次，因为是两个对象，之后文件中的内容需将之前的虚表指针的值覆盖成我们想要的值，因为每个对象空间中的第一项记录的就是vptr，所以直接向文件中写入改写的虚表指针的值即可(从头开始读入，否则中间还需要填充一些字段)。 寻找vtable的地址 直接在将文件拖入IDA64中查看（当然这里也可以用gdb动态调试，从main函数一步步跟进）。因为vptr指向的是vtable中的第一项，由第一项存放的内容是函数give_shell的地址，找到give_shell的位置可以确定vptr的地址为$0x401570$，第二项，即vptr+8所指向的位置，存放的内容是子类重写的函数introduce的地址，main函数中输入1（use）会调用introduce函数，因此我们需要在调用introduce函数时，讲vptr的指针指向give_shell函数，即将指针向前移动8个字节长度。 10x401570 - 8 = 0x401568 -&gt; \\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00 确定每个对象分配的空间大小 可见原本分配的两个对象的空间为$0x18 = 24Byte$，所以之后分配的空间也同样为24字节。（这里没有必要手动计算类对象所占空间的大小，因为不同机器可能会存在差异，知道存在哪些项即可，不必过于纠结为什么是24字节。） 整理如下 输入3（free）：将分配的man和woman的空间释放（这里先释放man，在释放woman） 输入2（allocate）：先将woman释放的空间重新拿回 输入2（allocate）：再将man释放的空间重新拿回 输入（use）：通过传递的参数已经改写了vptr的值，执行introduce即give_shell，拿到flag PWN1python -c &quot;print &#x27;\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00&#x27;&quot; &gt; /tmp/exp.txt","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"random","slug":"Pwnable_kr/random","date":"2020-10-15T11:10:35.000Z","updated":"2020-10-19T07:10:12.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/random/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/random/","excerpt":"","text":"查看random.c源代码 函数的整个执行流程是rand（）产生的随机值和输入的密钥进行异或，若其结果等于$0xdeadbeef$，则可以执行system函数，拿到flag。 rand（）函数 由此可见，如果不重新生成种子（一般情况下，默认生成种子为1），则每次产生的随机数将会是一个固定值，那么接下来的任务就是确定这个固定值。 查看随机数$disassemble /r \\ main$查看汇编代码 在cmp处下断点汇编代码中，在进行cmp之前先进行了一次异或运算，显然这是将用户输入的key和生成的随机数进行异或，由此可以判断随机数的位置为$rbp-4$（先压入栈中），因此使用$x/10x \\ $rbp-4$查看内存的值即可。 所以生成的随机数为0x6b8b4567，可多次运行程序查看其值是否发生变化，这里不做演示。 PWN求出$0x6b8b4567\\oplus 0xdeadbeef$的值输入即可","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"collision","slug":"Pwnable_kr/collision","date":"2020-10-15T11:10:23.000Z","updated":"2020-10-19T07:09:52.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/collision/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/collision/","excerpt":"","text":"查看C语言源代码 main(int argc, char* argv[]) 传递三个参数$aa,bb,cc$, 程序运行结果如下: 注意：若传递n个参数，实际上相当于给main函数传递了n+1个参数，argc=n+1（因为argv[0]是路径名自动传递） 分析col.c 函数传递了两个参数，第一个参数为int型，第二个参数为一个字符数组，main函数首先判断第一个参数如果小于2,即若不显式传递参数，则打印argv[0]之后会直接退出。 argv[1]，即传入的第二个参数，第一个参数为文件所在路径，指向的字符串的长度需要等于20字节。 check_password函数将指向20字节的字符指针转为int指针，因为int是4字节，即将20字节字符串拆分成为5个int类型的数据，之后求和。 如果求和的结果和给定的哈希值0x21DD09EC相等，则会执行system函数拿到flag。 最直接的想法是暴力穷举，寻找哈希碰撞，但实际上这里可以直接凑出这个哈希值，可以令20字节的前16字节都设置为0x01，注意不能设置为0x00，因为0x00是一个截断字符，程序读入argv[1]时如果遇到了0x00会自动截断，从而导致程序结果有误。 另外，注意数据按照小端序存放： 编写python脚本 12./col $(python -c &quot;print &#x27;\\x01\\x01\\x01\\x01&#x27;*4 + &#x27;\\xe8\\x05\\xd9\\x1d&#x27;&quot;)# 这一inline的python表达式可以将生成的结果作为argv[1]参数 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"flag","slug":"Pwnable_kr/flag","date":"2020-10-15T11:10:06.000Z","updated":"2020-10-19T07:10:00.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/flag/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/flag/","excerpt":"","text":"checksec查看文件属性 windows下使用upx -d命令解压缩 IDA64打开解压缩的文件 将flag的值存放到dest中，直接查看flag即可","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"fd","slug":"Pwnable_kr/fd","date":"2020-10-15T10:59:24.000Z","updated":"2020-10-19T07:09:56.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/fd/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/fd/","excerpt":"","text":"登录远程服务器 ls -la查看文件信息linux文件权限知识 发现fd.c和其对应的可执行文件fd（用户有执行权限） cat fd.c查看c语言代码 有源代码可知，这里需要执行system函数的条件为buf缓冲区内容为LETMEIWN read(fd,buf,32)1234567read(fd, buf, 32)fd == 0时：则表示标准输入；fd == 1时：则表示标准输出；fd == 2时，则表示标准输出错误。buf 表示读入的缓冲区；32表示读入32字节； 因此我们需要设置fd为0，读取我们输入的LETMEWIN到buf缓冲区中即可获得flag。 注意到 1fd = atoi(argv[1]) - 0x1234 要使得$fd=0$，就是让main函数的第一个参数argv[1]等于$0x1234$ ./fd 4660 注意这里参数需要转为10进制 $0x1234_{16} = 4660_{10}$ 1flag: mommy! I think I know what a file descriptor is!!","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"passcode","slug":"Pwnable_kr/passcode","date":"2020-10-15T07:08:39.000Z","updated":"2020-10-19T07:10:08.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/passcode/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/passcode/","excerpt":"","text":"查看passcode.c源文件 第一反应为使得passcode1为338150、passcode2为13371337，之后调用system函数。 login函数中要求输入两个密码passcode1和passcode2，但scanf函数用法错误，其后并没有加上&amp;符号取其地址，而是直接使用了栈上两个没有初始化的随机值，因此直接输入则会出现segmentation fault。因此考虑在login函数之前执行的welcome函数。 welcome函数要求用户输入姓名的字符串，但是允许输入100字节长度，因此尝试使用其覆盖栈上两个变量的“随机值”。 gdb passcode查看其汇编代码disassemble /r welcome disassemble /r login 发现char数组在$ebp - 0x70$处，而passcode1、passcode2分别在$ebp - 0x10、ebp - 0xc$处，其相差的距离$0x70 - 0x10 = 96 &lt; 100,0x70 - 0xc = 100$，因此并不能直接通过输入姓名字符串覆盖变量passcode2,只可以覆盖passcode1。 转换思路查看文件保护措施 栈上开启了Canary机制，因此栈溢出很难成功，发现没有开启PIE，因此可以通过修改某些函数got表的地址，进行调用system函数。实际上，既然scanf是一个具有写功能的函数，我们完全可以利用scanf来修改此后使用到的某个函数的got表项。例如，程序在scanf(“%d”, passcode1);**后立即使用了fflush函数，所以我们完全可以先找到fflush的got表项地址（程序没有开PIE，无需leak），把passcode1布局为该地址，并在调用到scanf(“%d”, passcode1)时输入程序代码中调用system(“/bin/cat flag”);**处的地址，这样执行fflush函数时就会执行system函数。 注意这里区分got表本身的地址和写入got表项中的地址 fflush函数的地址 fflush地址为$0x0804a004$ system函数的地址 这里注意system函数需要将参数先压栈之后再调用，即真正调用的函数地址为$0x080485e3$，即在printf函数之后执行。 编写python脚本1python -c &quot;print &#x27;A&#x27; * 96 + &#x27;\\x04\\xa0\\x04\\x08&#x27; + &#x27;134514147\\n&#x27;&quot; | ./passcode 因为passcode是输入int型，即输入$0x080485e3 = 134514147$。 PWN","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]},{"title":"bof","slug":"Pwnable_kr/bof","date":"2020-10-15T06:33:21.000Z","updated":"2020-10-19T07:09:44.000Z","comments":true,"path":"2020/10/15/Pwnable_kr/bof/","link":"","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/2020/10/15/Pwnable_kr/bof/","excerpt":"","text":"查看给出的c语言源代码 显然，简单的缓冲区溢出，将key通过缓冲区溢出覆盖为0xcafebabe，即可通过判断条件，执行system函数。 IDA32打开文件 编写python脚本123456from pwn import *io = remote(&#x27;pwnable.kr&#x27;,9000)payload = &#x27;a&#x27;*0x2C + &#x27;junk&#x27; + &#x27;junk&#x27; + p32(0xcafebabe)io.interactive()","categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"}]}],"categories":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/"},{"name":"Pwnable.kr","slug":"PWN/Pwnable-kr","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/"},{"name":"Toddler's Bottle","slug":"PWN/Pwnable-kr/Toddler-s-Bottle","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Pwnable-kr/Toddler-s-Bottle/"},{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/"},{"name":"Adversarial sample","slug":"AI/Adversarial-sample","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/AI/Adversarial-sample/"},{"name":"Heap","slug":"PWN/Heap","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/"},{"name":"Heap_Basic","slug":"PWN/Heap/Heap-Basic","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/Categories/PWN/Heap/Heap-Basic/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/PWN/"},{"name":"AI","slug":"AI","permalink":"https://github.com/xiaohong404/xiaohong404.github.io/tags/AI/"}]}